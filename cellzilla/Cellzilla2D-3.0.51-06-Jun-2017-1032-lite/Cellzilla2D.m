(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["Cellzilla2D`"];
$Cellzilla2DVersion="3.0.51 (05 June 2017)"  


(* ::Input::Initialization:: *)
If[$VersionNumber<6, Print["This package requires Mathematica Version 6.0.3 or higher."]; Abort[]
]; 
If[$VersionNumber==6 \[And] $ReleaseNumber<3, 
Print["This package requires Mathematica Version 6.0.3 or higher; You have version 6.0."<>ToString[$ReleaseNumber]];
Abort[]; 
];

Needs["XML`"]; 


(* ::Input::Initialization:: *)
MemoryInstalled::usage="MemoryInstalled[] is the missing function in Mathematica that tells you how much memory you have installed. It requires JLink so it may not work on all operating systems.";
MemoryFree::usage="MemoryFree[] is the missing function in Mathematica that tells you how much system memory is free (the complement of MemoryInUse[]). Requires JLink so it may not work on all operating systems.";


(* ::Input::Initialization:: *)
DelaunayMean::usage="DelaunayMean[{{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\)},{\!\(\*SubscriptBox[\(x\), \(2\)]\),\!\(\*SubscriptBox[\(y\), \(2\)]\)},...}]\nReturns the average length of all the links in the Delaunay Triangulation"; 
DelaunayEdges::usage="DelaunayEdges[{{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\)},{\!\(\*SubscriptBox[\(x\), \(2\)]\),\!\(\*SubscriptBox[\(y\), \(2\)]\)},...}]\nReturns a the coordinates of the end points of all the links in the Delaunay Triangulation, {\!\(\*SubscriptBox[\(link\), \(1\)]\), \!\(\*SubscriptBox[\(link\), \(2\)]\),..} where each \!\(\*SubscriptBox[\(link\), \(i\)]\) has the form {{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\)}, {\!\(\*SubscriptBox[\(x\), \(2\)]\),\!\(\*SubscriptBox[\(y\), \(2\)]\)}}."; 
ConvexHullVertices::usage="ConvexHullVertices[{{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\)},{\!\(\*SubscriptBox[\(x\), \(2\)]\),\!\(\*SubscriptBox[\(y\), \(2\)]\)}, ...}]\nReturns the convex hull as a list of vertex coordinates."; 
GenerateBoundaryLayer::usage="GenerateBoundaryLayer[{{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\)},{\!\(\*SubscriptBox[\(x\), \(2\)]\),\!\(\*SubscriptBox[\(y\), \(2\)]\)}, ...}]\nReturns an artificial boundary layer of points obtained by extending the convex hull out by a diameter equal to the average length of the delaunay triangulation (before extension)."; 
BoundedCellVoronoi::usage="BoundedCellVoronoi[{{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\)}, {\!\(\*SubscriptBox[\(x\), \(2\)]\),\!\(\*SubscriptBox[\(y\), \(2\)]\)}, ...}]\nreturns a Tissue[..] object that represente the Bounded-Cell Voronoi Diagram, obtained as the Voronoi Diagram of the original cells after adding artificial cells around the convex hull."; 
PrunedDelaunayEdges::usage="PrunedDelaunayEdges[poitns] gives coordinates of endpoints of links in Pruned Delaunay Triangulation. The Delaunay Triangulation is is pruned by removing links that are not between cells that are touching in the Bounded Cell Voronoi.";
PrunedDelaunayPairs::usage="PrunedDelaunayPairs[points] returns a list of the {i,j} pairs in the pruned Delaunay Triangulation. The indices {i,j} refer to positions in the list of points. Only links between cells that are connected according to the BoundedCellVoronoi are included; other links in the Delaunay Triangulation are excluded. To get the actual coordinates of the links, use PrunedDelaunayEdges.";  
DelaunayPairs::usage="DelaunayPairs[{{\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(y\), \(1\)]\)},{\!\(\*SubscriptBox[\(x\), \(2\)]\),\!\(\*SubscriptBox[\(y\), \(2\)]\)},...}]\nReturns a the indices of the endpoints of the unique edges in the Delaunay Triangulation, as {i,j} pairs in the list of vertices."


(* ::Input::Initialization:: *)
go::usage=""; 
grow::usage=""; 
StaticSimulation::usage="StaticSimulation[DTissue, start, stop, options] is a wrapper for grow that configures a static (non-growing) simulation. The tissue does not grow and cell division does not occur.  Equivalent to grow with a division threshold of \[Infinity] and \"Growing\"\[Rule]False. All non-growth related options for grow are still valid. "; 
RunSim::usage=""; 
BinData::usage=""; 
SimBinData::usage="SimBinData[variable, binspec,options] bins data from a saved simulation into a format that can be used to produce histograms.\nbinspec={min,max,delta}\noptions are:\n\"Samples\"\[Rule]100 (default value), number of time samples, equally space\n\nReturn Value is a list of lists of the form {time, mean, sigma, bins}, where bins is a list of integer counts. "; 
Bins2Histogram::usage="Bins2Histogram[bins,{binmin,binmax,bindelta}] returns a plot, where bins is the output of SimBinData; and {binmin,binmax,bindelta} are the same as were passed to SimBinData. Options include:\n\"Mean\"\[Rule]{Thick,Red} (styles for average histogram)\n\"Style\"\[Rule]{Black} (styles for ensemble histograms)\n\"Scatter\"\[Rule]True (include all histograms; if False, just plot mean)\n\"ErrorBars\"\[Rule]True\n\"Normalize\"\[Rule]False\n\"Rounding\"\[Rule].1 - rounding for printing of stats on plots (on used for printing, not calculation).\nas well as any Plot option."; 
SimBinSides::usage="";
SimPlot::usage="SimPlot[sim, variable, {tstart, tend}, options] (any option for Plot)\nSimPlot[sim, {tstart, tend}, options] - plots all variables\nSimPlot[sim, {variables}, {tstart, tend}, options}] - plot specific variables\nSimPlot[sim, options] - autodetect time span\nOptions:\n\"Grid\"\[Rule]False\n\"Columns\"\[Rule]3 (if Grid=True)";
MultiSimPlot::usage="MultSimPlot[sim, variable, {tstart, tend}, options]";
ShowInitialRates::usage="ShowInitialRates[newtork, ic, rates, BoundaryConditions]"; 
HasSufficientInfo::usage="HasSufficientInfo[network, ic, parameters] returns True if there is sufficient informaiton to run a simulation (NDSolve) and False otherwise\nHasSufficientInfo[network, ic, parameters, True] returns a string `This simulation is (not) complete and may (not) be used to run a simulation.' instead of a Boolean flag. ";
SimShow::usage="SimShow[solution,variable, time, tissue, {rgbfrom, rgbto}, {vmin, vmax}]\nTo display a legend use SimShowAt instead.\nOptions:\n\"Hues\"\[Rule]False or {hmin,hmax} where 0\[LessEqual]hmin,hmax\[LessEqual]1 are hue values that override the rgb color specs. Legends are not implemented with hues. \nAny option for graphics or plot may also be used. ";  
SimShowFinal::usage="SimShowFinal[solution, variable, template, {colormin, colormax}, options]"; 
SimShowThreshold::usage=""; 
SimShowAt::usage="SimShowAt[solution,variable,time, template,{colormin, colormax}, options] or \nSimShowAt[solution,variable,time,template,{colormin,colormax}, {vmin,vmax}, optoins]\nLike SimShow but with a legend."; 
SimAnimate::usage="SimAnimate[solution, Variable, Template, {tstart, tend, deltat}, {colormin, colormax}, {valmin, valmax}, options]"; 
WTAAnimate::usage="
WTAAnimate[{var1, var2,...}, {color1, color2, ...}, opt___?OptionQ]
Winner Take All SimAnimate: Performs a winner-take-all strategy on the variables listed and displays the color of the corresponding maximum variable in each cell
Options are the same as SimAnimate (except colors are defined by arguments)";
WTAShow::usage="
WTAShow[Tissue, Solution, Time, {var1, var2, ...}, {Color1, Color2, ...}, options]
Winner Take All SimShow: Performs a winner-take-all strategy on the variables listed and displays the color of the corresponding maximum variable in each cell
[Tissue, Solution, Time,   {var1, var2, ...}, {Color1, Color2, ...}, backgroundColor,  {min, max},  options]
Allows all values to be displayed using RGBInterpolate on a range of [backgroundColor --> Color] on the same scale
Options for SimShow may be used";
LineageAnimate::usage="LineageAnimate[options] or LineageAnimate[folder, options], displays the tissue as an animation of the lineags of the ancestral cells (in the first tissue). Options are the same as SimAnimate; additionally, \"Colors\" may be specified (up to the number of cells in the original tissue). "; 
LineageShow::usage="LineageShow[Tissue, Lineage] or LineageShow[DTissue, Solution, Time, Lineage]. Lieage is the lineage data structure written by Grow."; 
SaveFrames::usage="SaveFrames[pictures_?ListQ,type_, size_, movieType_:\".avi\",  label_:\"MovieData\", framerate_:8]";
ToAVI::usage="ToAvi[pics_,title_:\"MovieData\",  size_:400, rate_:16]";
ToMOV::usage="ToMOV[pics_,title_:\"MovieData\",  size_:400, rate_:16]"; 
SimRange::usage="SimRange[solution, Variable,time] gives {min, max} of variable over the tissute."; 
SimInterpolate::usage="SimInterpolate[solution, variable, time] returns list of values of variable in each cell."; 
CommonTimeDomain::usage="CommonTimeDomain[solution] returns the time range represented by all variables in the solution."; 
BellCurve::usage="";


(* ::Input::Initialization:: *)
CelleratorNetwork::usage="CelleratorNetwork[tissue,options]\n\"Reactions\"-> network , wherenetwork is any xCellerator reaction network, e.g., as stored in Sigmoid (NOT indexed by cell; the cell indices will be added\n\"Diffusion\"-> {{x,\!\(\*SubscriptBox[\(\[Beta]\), \(x\)]\)}, {y, \!\(\*SubscriptBox[\(\[Beta]\), \(y\)]\)}, ...}, list of species and penetrability coefficients constants.\n\"Verbose\"\[Rule]True, set to false to suppress printing summary message.\n\"Area\"\[Rule]None, specify a symbol to replace \!\(\*SubscriptBox[\(A\), \(i\)]\) with var[i][t] \n\"Edge\"\[Rule]None, specify a symbol to replace  \!\(\*SubscriptBox[\(\[ScriptL]\), \(ij\)]\) with edge[p][t] where p is the edge number between nodes i and j.\n\nIf cell sizes will change during the simulation the options \"Area\" and \"Edge\" must be specified. If one is specified but the other is not a unique variable name will be generated." ; 
WalledNetwork::usage="WalledNetwork[internalReactions,\nDiffusionReactions,
\"Area\"\[Rule]Area Variable Name (None or not used: statis values from tissue),
\"Edge\"\[Rule]Edge Variable Name (None or not used: static values from tissue),
\"WallReactions\"\[Rule]Optional List of (unindexed) reactions to instantiate in walls,
\"BoudaryConditions\"\[Rule]Options List of (uninexed) constant boundary conditions\n]
internalReactions is any (unindexed) Cellerator network; the indices will be instantiated in every cell and edge at run time. Values in cells will be X[i]; values in edges will become x[cellnumber, edgenumber].\nDiffusionReactions = {reaction, reaction, ...} where each reaction is:\n{variable, {betaout, betain, betawall}, {fout, fin, fwall}}\nwhere the out, in, and wall refers to efflux from the cell; influx to the cell; and wall to wall component diffusion. Each wall has two layers, adjacent to each cell, except for the outer boundary of the tissue. The Functions each have three arguments of the form f[cell1, cell2, edgenumber], and are optional. The total penetrability is given by beta*function. "; 
SSANetwork::usage="SSANetwork[network, diffusion, tissue]"; 
X2SSANetwork::usage="";


(* ::Input::Initialization:: *)
DivisionPotential::usage="";
OptimizeDivisionPotential::usage="";
PrincipalGrowthDirection::usage="PrincipalGrowthDirection[DTissue,cellnumber, solution,time,xvar,yvar]\ndetermines the principle direction of cell growth, taken as the eigenvector of the covariance matrix of the velocity vectors, with the largest eigenvalue.";
PrincipalCellDirection::usage="PrincipalGrowthDirection[DTissue,cellnumber, solution,time,xvar,yvar]\ndetermines the principle direction of the cell, taken as the eigenvector of the covariance matrix of the coordinates of the vertices of the cell, with the largest eigenvalue.";  
SetNextIC::usage=""; 
SetRandomizedIC::usage="SetRandomizedIC[tissue_?TissueQ,network_,ell_,area_,resting_,x_,y_,extension_,rmin_,rmax_]";
DetermineCellDivisionPoints::usage=""; 
BalanceLineage::usage=""; 
ShowBalancedLineage::usage==""; 

$SIMDIR::usage="Name of the last folder that simulations were written to";
$ODEFILE::usage="Name of last ODE file saved during a growth simulation.";
$OPTIONFILE::usage="Name of last option file saved during a growth simulation.";
$TISSUEFILE::usage="Name of last tissue file saved during a growth simulation.";
$NETFILE::usage="Name of last reaction network file saved during a growth simulation.";
$EQNFILE::usage="Name of last equation file saved during a growth simulation.";
$SOLUTIONFILE::usage="Name of last solution file saved during a growth simulation.";
$LINEAGEFILE::usage="Name of last lineage file saved during a growth simulation.";
$EDGELINEAGEFILE::usage="Name of last edge lineage file saved during a growth simulation.";
$ICFILE::usage="Name of last set of initial conditions saved during a growth simulation.";
ShowSavedFiles::usage="ShowSavedFiles[] displays all the files saved in $SIMDIR\nShowSavedFiles[type] shows all the files of the specified type in $SIMDIR. Values for type are: \"IC\",\"ODE\",  \"Options\", \"Tissue\", \"Net\", \"Equation\", \"Solution\", \"Lineage\",\"EdgeLineage\". Note that this will only show the files in the most recently run simulation. ";
GetSavedFile::usage="GetSavedFile[folder, type, n] returns the nth saved file of type in folder.\nGetSavedFile[type] returns the last saved object, if it exists, that was saved during a growth simulation. \nValues for type are: \"IC\",\"ODE\",  \"Options\", \"Tissue\", \"Net\", \"Equation\", \"Solution\", \"Lineage\",\"EdgeLineage\". Note that this will only return the last file in the most recent simulation, not earlier files, or earlier simulations.";
GetODES::usage="GetODES[ODES, var] or GetODES[ODES,{var1,var2,...}] extracts all ODES for the specified indexed variables var[i], var[p,1], etc. "; 
ShowResults::usage="ShowResults[directory, number, spec, options] where spec is a list of the form {spec1, spec2, ...} and each spec ={variable, {color, color}, {value, value}}"
Transport::usage="Transport is a header for a Transport Arrow"; 
Diffusion::Usage="Diffusion is a header for a Diffusion Arrow"; 
IGRN::Usage="IGRN is a header for an Intercellular GRN Reaction"


(* ::Input::Initialization:: *)
TemplateHoneycombCover::usage="TemplateHoneycombCover[xmax,ymax]";
TemplateRectangular::usage="TemplateRectangular[nx,ny]\nTemplateRectangular[{xmin,xmax,dx}, {ymin,ymax,dy}]"; 
TemplateRectangularCover::usage="TemplateRectangularCover[xmax, ymax, dx, dy, offset:.5]";
TemplateCircularHoneycomb::usage="TemplateCircularHoneycomb[n,area]\nwhere n is the number layers and area is the desired area of each cell."; 
TemplateCircularHoneycombCover::usage="TemplateCircularHoneycombCover[radius, mode]\nmode=-1: circle\nmode=0: semiscircle\nmode=n>0: semicircle atop base of n rows."; 
RandomizeTemplate::usage="RandomizeTemplate[tissue, rand:.1]";
TemplateRandom::usage="TemplateRandom[npoints, {{x1,y1}, {x2,y2},..} (boundary)] generates a template of totally random cells that fall within the specified boundary (uses a Voronoi based model).";
TemplatePolygon::usage="TemplatePolygon[...] returns a single-cell tissue in the shape of a polygon. Arguments are idential to regularPolygon.";
TemplateRing::usage="TemplateRing[number-of-cells, outer-Radius, Area-Per-Cell]";
TemplateRandomCircularGrid::usage="TemplateRandomCircularGrid[numberOfCells, radius]"; 
TemplateRandomSemicircularGrid::usage="TemplateRandomSemicircularGrid[n, radius, nbottom]"; 
TemplateRandomSquareGrid::usage="TemplateRandom[npoints, {xmin, ymin}, {xmax, ymax}]\n generates a random template in the specified box with the cell centers on a randomized hexagonal grid (uses a Voronoi based model)."; 
TemplateRandomOvalish::usage="TemplateRandomOvalish[n, {a, b}]";
VoronoiToTissue::usage="VoronoiToTissue[points, boundary]"; 
CellVerticesToTissue::usage="CellVerticesToTissue[{cell1, cell2, ...}] where celli={{x,y}, {x,y},...}"; 
TemplateParabolic::usage="TemplateParabolic[height, rows, randomization:0] returns a template constrained to a parabolic dome with width equal to twice the height and `rows` rows of cells arranged in concentric parabolas, offset by one diameter. In the present version the aspect ratio of teh parabola is fixed.";


(* ::Input::Initialization:: *)
(* MultiPlot::usage="MultiPlot[solution, {variables, ...}, {t, tstart, tend}, options]"; 
RowPlot::usage="RowPlot[solution, {variables, ...}, {t, tstart, tend}, options]"; *)
SolutionVariables::usage="SolutionVariables[sim]";
SolutionVars::usage="SoltionVars[sim]";
GeometricSnapShot::usage=""; 


(* ::Input::Initialization:: *)
SmootheCell::usage="SmootheCell[tissue, cellNumber]"; 
SmootheCells::usage="SmootheCells[tissue, {cellNum, cellNum, ...}]\nSmoothCells[tissue] for all cells on boundary";


(* ::Input::Initialization:: *)
Tissue::usage="Tissue[vertices, edges, faces]"; 
Tissue3D::usage=""; 
FlatTissue::usage="Tissue[vertices,faces]"; 
Tissue2FlatTissue::usage="Tissue2FlatTissue[FlatTissue]";
FlatTissue2Tissue::usage="FlatTissue2Tissue[Tissue]"; 
TissueQ::usage="TissueQ[Tissue[...]]"; 
DTissue::usage="DTissue[vertices, edges, {n1->face1,n2->face2,...}]";
DTissueQ::usage="DTissueQ[DTissue[...]]"; 
ISTissue::usage=""; 
Tissue2DTissue::usage="Tissue2DTissue[tissue]\noption: \"Numbers\"\[Rule]list of numbers";
DTissue2Tissue::usage="DTissue2Tissue[tissue]\nDTissue2Tissue[dtissue, sim, time]"; 
TissueCheck::usage="TissueCheck"; 
MidPoint::usage="MidPoint[p1,p2]\nMidPoint[{p1,p2}]\nMidPoint[{p1,p2,...}, i] - find midpoints of edge i (0 means all)\nMidPoint[{p1,p2,...}] - find midpoints of all edges\nMidPoint[Tissue[..]] - find midpoints of all edges in all cells\nMidPoint[Tissue,cellNumber] - find midpoints of all edges in given cell\nMidPoint[Tissue,cellNumber, edgeNumber] - midpoint of given edge in given cell."; 
BoundaryCell::usage="BoundaryCell[Tissue] returns information about a fictitious cell compoese whose vertices are the boundary of the entire tissue. Returned as an option list {\"Coordinates\"->{{x,y,z},{x,y,z},...}, \"Edges\"->{i,j,k,...}, \"Vertices\"->{i,j,k,...}}"; 
SharedWall::usage="SharedWall[Tissue,p,q] returns a list {\"Edges\"->{i,j,..}, \"Vertices\"-> {i,j,..}, \"Coordinates\"-> {{x,y,z},{x,y,z},...}";
AdjacentVertices::usage="AdjacentVertices[g,i] returns a list of the vertices that are adjacent to vertex i in g";
AdjacentBoundaryVertices::usage="AdjacentBoundaryVertices[g,i] returns a list of vertices that are adjacent to vertex i in g and lie on the boundary. If no vertices lie on the boundary then a null list is returned.";  
VerticesOnBottom::usage="";
VerticesOnTop::usage=""; 
VerticesOnRight::usage=""; 
VerticesOnLeft::usage=""; 
CellsOnLeft::usage="";
CellsOnRight::usage=""; 
CellsOnTop::usage="";
CellsOnBottom::usage="";
EdgesOnTop::usage="";
EdgesOnLeft::usage="";
EdgesOnRight::usage="";
EdgesOnBottom::usage=""; 
IntersectingEdges::usage="IntersectingEdges[(D)Tissue,edgenumber]"; 
L1Cells::usage="L1Cells[Tissue, options]; \"Bottom\"->Value will exclude cells with centroid y values smaller than specificed. use \"Bottom\"->Default to exclude cells beneath y = 1 mean cell diameter, \"Bottom\"->Infinity to use all Boundary cells.\n \"MinimumRadius\"->0,in case of central hole ";
L2Cells::usage="L2Cells[Tissue, options]"; 

ConnectionList::usage="ConnectionList[tissue]\nOptions:\n\"UpperTriangular\"\[Rule]False, include both {i,j} and {j,i}; if True, only the one with i<j will be included";
ConnectionMatrix::usage="ConnectionMatrix[tissue] returns a SparseArray[..] object\nOptions are the same as ConnectionList";  
EdgeLengths::usage="EdgeLengths[tissue] returns a list of the lengths of all the edges in the tissue"; 
CellEdgeLengths::usage="CellEdgeLengths[tissue, cellNumber]";
EdgeLength::usage="EdgeLength[tissue, Edge Number]"; 
EdgeVertices::usage="EdgeVertices[edge, list-of-vertices] - where edge = {i,j} is pair of vertex indices and list-of-vertices is a list of coordinate pairs.  Returns {{x1,y1}, {x2,y2}} for the two endpoints of the edge. \nEdgeVertices[list-of-edges, list-of-vertices] - where list-of-vertices is a list of {i,j} pairs. Returns a list of vertex pairs.\nEdgeVertices[tissue] - returns {{x1,y1}, {x2, y2}} for all edges in tissue. "; 
CellVertexNumbers::usage="CellVertexNumbers[cell, list-of-cells]\nCellVertexNumbers[list-of-cells, list-of-vertices]\nCellVertexNumbers[Tissue]\nCellVertexNumbers[Tissue, cellNumber]"; 
SortCellsCounterClockwise::usage="SortCellClockwise[tissue] returns a list {s1,s2,...} where each si is a rule list {\"Edges\"-> {e1,e2, ...}, \"Vertices\"->{v1,v2,...}} where e1,e2,... are edge numbers of si, and v1,v2,... are the vertex numbers of cell i, arranged counter-clockwise.";
SortCellEdges::usage="SortCellEdges[cell, edges] returns a rule list {\"Edges\"-> {e1,e2, ...}, \"Vertices\"->{v1,v2,...}} where e1,e2,... are edge numbers of cell, and v1,v2,... are the vertex numbers of cell. Here cell is the list of edges numbers, and edges is the list of edge vertex pairs, as given in the tissue object."; 
CellVertexCoordinates::usage=""; 
CellsOnBoundary::usage="CellsOnBoundary[tissue]"; 
InteriorCells::usage="InteriorCells[tissue]"; 
VerticesOnBoundary::usage="VerticesOnBoundary[tissue]  returns a list of the indices of the vertices that are on the outer edge of the tissue."; 
VerticesNotOnBoundary::usage="VerticesNotOnBoundary[tissue] returns a list of the indices of the vertices that are not on the out edge of the tissuue."; 
EdgesOnBoundary::usage="EdgesOnBoundary[tissue] returns a list of the indices of the edges that are on the outer edges of the tissue."; 
EdgesNotOnBoundary::usage="EdgesNotOnBoundary[tissue] returns a list of the indices of the edges that are not on the outer boundary of the tissue.";
DivideEdge::usage="DivideEdge[tissue, edgeNumber, number of segments, randomness]"; 
DivideEdges::usage="DivideEdge[tissue, number of segments, randomness] or \nDivideEdge[tissue, {n1,n2,...}, number of segments, randomness]"; 
MergeEdges::usage="MergeEdges[tissue, edge1, edge2] returns a new tissue object with the specified edges merged together; the two edges must share a common vertex. \nOptions:\n\"Undangle\"\[Rule]True - if True, dangling edges and vertices will be removed after the merge; if False, they will not be removed."; 
NeighborQ::usage=""; 
MergeCells::usage=""; 
MergeVertices::usage="MergeVertices[tissue, {v1,v2}] returns a tissue with the edge between {v1,v2} removed; or an error if there is no such edge.\nMergeVertices[tissue, n] returns a tissue with the nth redge removed. \nOptions:\n\"Changes\"->False; if True, a list {changes, newtissue} is returned. the list changes indicates edge number changes, oldNumber -> newNumber, with {} for a removed number."; 
DivideCell::usage="DivideCell[tissue, cellNumber, {{x1,y1}, {x2,y2}}] returns a tissue with the specified cells replaced by two daughter cells; the cell is divided along a single line segment determined by that part of the line through {x1,y1} and {x2,y2} that is not exterior to the cell.\nIf the option \"Changes\"\[Rule]True is used, instead of returning a tissue object, a list {changes, tissue} is returned, where changes is a list of rules giving the edge number changes, e.g., 3->{3,17} means edge 3 becomes edges 3 and 17 and {}-> 42 means the new edge is number 42."; 

DanglingEdges::usage="DanglingEdges[tissue]"; 
DanglingVertices::usage="DanglingVertices[tissue]"; 
UndangleEdge::usage="UndangleEdge[tissue, edgeNumber]"; 
RemoveEdge::usage="RemoveEdge[tissue, edgeNumber]"; 
RemoveEdges::usage="RemoveEdges[tissue, list-of-edge-Numbers]"; 
UndangleEdges::usage="UndangleEdges[tissue]"; 
UndangleVertex::usage="UndangleVertex[tissue, vertexNumber]"; 
RemoveVertex::usage="RemoveVertex[tissue, vertexNumber]"; 
RemoveVertices::usage="RemoveVertices[tissue, list-of-vertex-numbers]"; 
UndangleVertices::usage="UndangleVertices[tissue]"; 
RemoveShortEdges::usage="RemoveShortEdges[tissue, threshold], threshold is fraction of length of average edge."; 

InLineVertices::usage="InLineVertices[tissue] returns a list of the vertices that fall are shared by precisely two edges which are co-linear and fall between those two vertices (and hence the middle vertex could presumably be removed). The return value is a list of the form {{v, {e1,e2}}, {v, {e1,e2}}, ...} where v is the vertex number and e1, e2 are the numbers of the two shared edges. \n\nOptions\n\"Vertices\"\[Rule]{n1,n2,...} subset of list of vertex numbers to check (rather than checking all vertices)."; 

TissueCells::usage="TissueCells[tissue] returns a list of the cells in a tissue object. Each cell is a list of edge numbers.";
TissueEdges::usage="TissueEdges[tissue] returns a list of the edges in a tissue object; each edge is a pair of vertex numbers."; 
TissueVertices::usage="TissueVertices[tissue] returns a list of the vertices in a tissue. Each vertex is a coordinate pair {x,y}."; 
NTissueCells::usage="NTissueCells[tissue] returns the number of cells in a tissue.";
NTissueEdges::usage="NTissueEdges[tissue] returns the number of edges in a tissue."; 
NTissueVertices::usage="NTissueVertices[tissue] returns the number of vertices in a tissue."; 

(* DynamicalEquations::usage=""; *)
(* SpringEquations::usage=""; 
PressureEquations::usage="";*)
DeleteCell::usage="DeleteCell[dtissue,number]"; 
RemoveCell::usage="RemoveCell[tissue, cellNumber]\nremoveCell[tissue,{cell1,cell2,...}]\nremoves a specififed cell (or list of cells) and removes any remaining dangling edges and vertices";
AddVertex::usage="AddVertex[tissue, {x,y}]"; 
AddEdge::usage="AddEdge[tissue, {i,j}]"; 
AddCell::usage="AddCell[tissue, {i1,i2,i3,...}]"; 
EdgesUsed::usage="EdgesUsed[tissue]";
VerticesUsed::usage="VerticesUsed[tissue]";

CellEdgePairs::usage="CellWallPairs[tissue] returns a list {{cell, edge}, {cell, edge}, ...} of pairs of cells of and walls.";
CellNeighbors::usage="CellNeighbors[tissue, n] returns a list of neighbors of cell n in tissue\ncellNeighbors[tissue] returns a list of list of all neighbors of all cells."; 
VertexNeighbors::usage="VertexNeighbors[tissue,n]"; 
TissueOrTorusQ::usage="True if either a tissue or torus; otherwise, False."; 
EdgeBetween::usage="EdgeBetween[tissue, i, j] returns the integer number of the edge between cell i and cell j, or {} if they are not neighbors.";
EdgesBetween::usage="EdgesBetween[tissue] returns a sparse array that gives the number of edge between two cells, if they are neighbors, and a zero otherwise.";  
PartitionPolygon::usage="PartitionPolygon[{point1,point2,...}, n] returns a list of points that represents the polygon partitioning into n edges.";
RadialPolygon::usage="RadialPolygon[Points,n] returns an interpolating function f[theta] that gives the distance from the polygon centroid to its perimeter as a function of central angle.";
AngularPerimeterFunction::usage="AngularPerimeterFunction[points,n] returns a function f[theta] that gives the distance meastured along the perimeter between 0 and theta, where 0 \[LessEqual] theta \[LessEqual] 2\[Pi].";
EquiperimeterPoints::usage="EquiperimeterPoints[points, n] returns a list of n points equally spaced in distance along the perimeter of the cell defined by the list of points.";
RotateTissue::usage="RotateTissue[Tissue, angle in degrees]";
ReflectTissue::usage="ReflectTissueX[Tissue, axis]"; 
TranslateTissue::usage=""; 
TranslateToOrigin::usage="TranslateToOrigin[Tissue]";
Polygonalize::usage="Polygonalize[Tissue, threshold:.5]";



(* ::Input::Initialization:: *)
Rectangularize::usage="Rectangularize[tissue, options]";
Options[Rectangularize]={"Corners"-> "Automatic", "Method"-> "Perpendicular", "Quiet"-> False,  "Debug"-> False, "Randomness"-> 0.25};
ToTorus::usage="ToTorus[Tissue[..],..]";
Options[ToTorus]={"Tolerance"-> 1.0 10^-5, "Debug"-> False};
TorusQ::usage=""; 
TorusCheck::usage=""; 
Torus::usage="Torus[.. TBD ..] is an uninstantiated function indicating a Tissue[..] object with Toroidal connectivity.";
TorusTissue::usage="";
TorusRules::usage=""; 


(* ::Input::Initialization:: *)
Help::usage=""; 
$XLR8RLOAD::usage=""; 
$XSSALOAD::usage=""; 
(* QuadraticFit::usage="QuadraticFit[P0, P1, V0, V1, t]"; 
QuadraticFitCoefficients::usage="QuadraticFitCoefficients[P0, P1, PC]"; *)

Boundary::usage="Boundary[points, directives, options]"; 
(* DrawSpokes::usage="DrawSpokes[outputOfDropSpokes]"; *)

regularPolygon::usage="regularPolygons[NumberOfSides, StartAngle:0, aspect:1, Randomness:-1, RotationAngle:0]"; 
RegularStar::usage="RegularStar[NumberOfSides, Rbig/Rlittle:0, StartAngle:0, AspectRatio:1, Random:-1, RotationAngle:0] ";
Centeroid::usage="Finds the Mean coordinates of a set of points. This function is used when Centroid fails because the Centroid Algorithm only works for Non-intersecting polygons."; 
Centroid::usage="Centroid[{v1,v2, ...}]\nCentroid[tissue, n]\nCentroid[tissue, {n1,n2,...}]\nCentroid[tissue] - list of all centrois."; 
areafunction::usage="areafunction[{v1, v2, ...}] - area of polygon with specified vertices\nareafunction[tissue,i] - area of cell i in tissue\nareafunction[tissue] - list of all areas"; 
perimeterLength::usage="perimeterLength[{v1, v2, ...}]\nperimeterLength[Tissue, CellNumber]\nperimeterLength[Tissue]"; 
IsoPerimetricRatio::usage="IsoPerimetricRatio[{point1,  point2,...)]\nIsoPerimetricRatio[Tissue, CellNumber]\nIsoPerimetricRatio[Tissue]\nComputes Q=4\[Pi]A/\!\(\*SuperscriptBox[\(P\), \(2\)]\) for the polygon, cell, or all cells; where A is the area and P is the perimeter. It is normalized so that the isoperimetric ratio of a circle is 1."; 
InertiaMatrix::usage="InertiaMatrix[{v1, v2, ...}]";  
distance::usage="distance[p1, p2]"; 
unitVector::usage="unitVector[pointFrom, pointTo]"; 
Vector::usage="Vector[from,to]"; 
PointQ::usage="True if {x, y}; otherwise False"; 
NumericPointQ::usage="True if {x,y} are numeric; else False"; 

Inside::usage="Inside[{v1, v2, ...}, point]"; 
NormalVector::usage="NormalVector[{v1,v2,...}, index]"; 
OutwardNormalVector::usage="OutwardNormalVector[{v1,v2,..}, index]\nindex=0 means return all outward normals in the cell\nOutwardNormalVector[{v1,v2,..}] is equivalent to setting index=0\nOutwardNormalVector[tissue] - all cells and all edges\nOutwardNormalVector[tissue, cellnumber] all edges in given cel \nOutwardNormalVector[tissue, cellnumber, edgenumber]"; 
CellOutwardVector::usage="CellOutwardVector[Tissue, cellnumber, vertexnumber]";
VertexOutwardVector::usage="VertexOutwardVector[tissue,i,mean:T/F] Return an outward pointing mean-normal vector to a boundary vertex or a null vector if the vertex is not on the boundary. The mean is the average of the outward normals of the edges on either side of the vertex (when Mean=True). If Mean is False (the default) then a list of vectors is returned for each edge. "; 
PrimaryAxes::usage="PrimaryAxes[{v1, v2, ...}] or \nPrimaryAxes[tissue,i] or \nPrimaryAxes[tissue, {i1,i2,...}] or \nPrimaryAxes[tissue]"; 
PrimaryAxesVectors::usage=""; 
FitEllipse::usage="FitEllipse[{v1, v2, ...}]"; 
LineEdgeIntersection::usage="LineEdgeIntersection[Edge, Point, Direction] where\nEdge={point1, point2}\nPoint={x,y}\nDirection={vx, vy}"; 
DropPerpendicular::usage="DropPerpendicular[Point, Edge, Slide:False]\nIf Slide is True, and the perp. misses the edges, the result will be allowed to slide to the nearest endpoint; if Slide is false, the value $Failed is returned when the perpindiclar line misses the edge."; 

PolygonIntersection::usage="PolygonIntersection[{vx,vy}, {v1, v2, ...}] where {vx,vy} are the coordinates of a direction vector; and the line is assumed to pass through the centroid;  or \nPolygonIntersection[{p1,p2}, {v1,v2,...}], where p1,p2 are two points that determine the line (p1\[NotEqual]p2)";

ShowTissueCells::usage="ShowTissueCells[Tissue[..], {n1,n2,...}, color,opt] highlights specific cells.\nShowTissueCells[Tissue[..],{n1,n2,..}] uses a default color."; 
ShowTissue::usage="ShowTisue[Tissue[..], options]
\"CellStyle\" \[Rule] List of cell colors or Automatic or \"None\". If \"Nucleus\" is in the list the cells will be plotted as points rather than filled polygons. \n\"BoundaryStyle\" \[Rule] Color, thickness of walls (automatic) or \"None\"
\"CellNumbers\" \[Rule] True or False
\"CellNumberStyles\" \[Rule] Text style directives for cell numbers
\"Vertices\ \[Rule] True or False
\"VertexNumbers\" \[Rule] {} or style parameeters to print numbers
\"EdgeNumbers\" \[Rule] True or False
\"EdgeNumberStyle\"\[Rule]{} or styles for edge numbers
\"EdgeCellPairs\"\[Rule]{{cellnumber,edgenumber, style}, {cellnumber, edgenumber, style}, ...}; the edge cellpair colors are slightly offset to the interior of the cell from the edge to indicate a different color on each side of the edge. Use EdgeStyles for the central wall. 
\"EdgeStyles\"\[Rule]{style,style,...}, one for each edge - used for cell edges. If both EdgeStyles and EdgeCellPairs are used a French-Flag type edge with 3 stripes will appear.
\"All\"\[Rule]False, if True, will print any dangling edges or vertices that are not part of cells. Normally Dangling edges are not printed.\n\"Outer\"\[Rule]Style for outer edge of tissue (default is \"None\" which defaults to \"BoundaryStyle\")
\"Dome\"\[Rule]False, if True, plots on a parabolid dome, and optiosn to ParaboloidPlot also apply
\"xrange\"\[Rule]All (default) or {xmin,xmax}, \"yrange\"\[Rule]All (default) or {ymin,ymax} will clip the plotting of cells, vertices and edges (but not the tissue boundary)"; 
ShowTissueFunction::usage="ShowTissueFunction[tissue, f, {fmin, fmax}, {colormin, colormax}, options]\nf[x,y] gives a function that depends on cell centroid location."; 
ShowEdgeNormal::usage="ShowEdgeNormal[{p1,p2}, style:{}, edge:False]"; 
ShowOutwardNormals::usage="ShowOutwardNormals[{p1,p2,...}, style:{}, edge:False]";
PointOnLineSegment::usage="PointOnLineSegment[{{x1,y1}, {x2,y2}}, {x,y}, Tolerance]\nReturns True if {x,y} falls on the line segment from {x1,y1} to {x2, y2} and False otherwise, to within a specified tolerance. If not specified the default tolerance is \!\(\*SuperscriptBox[\(10\), \(-10\)]\)."; 

EntangledVertices::usage="EntangledVertices[tissue] returns a list of lists of vertex numbers that fall on each edge that are not endpoints .. and hence should be resolved because this is a poorly defined tissue.";
DisentangleVertices::usage="DisentangleVertices[tissue] returns a tissue with all the entangled vertices fixed."; 

RGBInterpolate::usage="RGBInterpolate[value, {vmin, vmax}, {rgbfrom, rgbto}]"; 
HueInterpolate::usage="HueInterpolate[value, {vmin, vmax}, {huefrom, hueto}]";
ColorBlendRectangle::usage=""; 
ShowTissueBoundary::usage="ShowTissueBoundary[tissue, style directives]"; 


(* ::Input::Initialization:: *)
LambertPlaneToDome::usage="";
LambertDomeToPlane::usage="";
ShowTissueOnDome::usage=""; 
ParaboloidPlot::usage="ParaboloidPlot[T,r,a,h,k,options]\nParaboloidPlot[T,options]\nwith options\n\"radius\",\"a\",\"h\",\"k\". The paraboloid is parallel to the z-axis, offset by (h,k) (default, (0,0)), and decreases as -a(x^2+y^2). radius gives the radius of the mask.\n\"Boundary\"\[Rule]False(default) or Directive[{color, style, etc}]. Values of True or Automatic are equivalent to Directive[{Thick,Black}]. Used for outer boundary of tissue."; 
Options[ShowTissueOnDome]={"CellStyle"-> Automatic, "EdgeStyle"-> Black, "Radius"-> -1}; 



(* ::Input::Initialization:: *)
TissueCentroid::usage=""; 


(* ::Input::Initialization:: *)
FlatFile::usage="FlatFile[tissue] returns a list\nFlatFile[tissue,file] outputs the tissue to a flat file.";
CSVFile::usage="CSVFile[tissue], CSVFile[tissue, filename], CSVFile[tissue, filename, flat:False]"; 
CSVToTissue::usage="CSVToTissue[filename] returns a Tissue object. The CSV file must either be formatted as 
	n,dimensions
	n,vertices
	n,edges
	n,faces
	x,y
	x,y
	...
	i,j
	i,j
	...
	p,q,r,..
	p,q,r,..
	...
where the strings \"dimensions\",\"vertices\",\"edges\" and \"faces\" are required; n is an integer; x,y (or x,y,z) are the coordinates of the ith vertex; i,j are the vertex indices of the pth edge; and p,q,r,... are the edge indices of the kth cell; or as
	n,dimensions
	n,vertices
	n,faces
	x,y
	x,y
	...
	s,t,u,..
	s,t,u,...
	...
where s,t,u,... are the vertex indices of the kth cell, and everything else is as defined for the first case.
In either case, a Tissue object is returned (the cells are expanded into their edge components, in the second case). 
"; 
TissueToPLY::usage="";
PLYToTissue::usage="";
PLYToTissue3D::usage=""; 


(* ::Input::Initialization:: *)
ShowTissue3D::usage="ShowTissue3D[T,edge-style]\n"<>"ShowTissue3D[T,edgeStyle,cellNumberStyle,edgeNumberStyle]\n"<>
"ShowTissue3D[T,edgeStyle,cellNumberStyle,edgeNumberStyle,xrange,yrange,zrange]";
ShowZProjection::usage="ShowZProjection[T,options]\nSame options as ShowTissue.";
PolygonArea::usage="PolygonArea[vertices]";
ZProjection::usage="ZProjection[Tissue]";


(* ::Input::Initialization:: *)
BelowLine::usage="BelowLine[A, B, C] returns True if y<mx+b, where A=(x,y), and m and b are the slope and y-intercept of the line from B to C; and returns False otherwise"; 
AboveLine::usage="AboveLine[A,B,C] returns True if BelowLine[A,B,C] is False.";
CellsBelowLine::usage="CellsBelowLine[Tissue, point1, point2] returns a list of cell numbers of the cells that fall below (smaller y coordinate) the non-vertical line connecting the two points.";
CellsAboveLine::usage="CellsAboveLine[Tissue, point1, point2] returns a list of cell numbers of the cells that fall above (larger y coordinate) the non-vertical line connecting the two points.";
GetTissueBelowLine::usage="GetTissueBelowLine[Tissue, point1, point2] returns a tissue composed of only those cells with centers below (smaller y coordinated) that the line connecting the two points. The two points must not lie on a vertical line.";
GetTissueAboveLine::usage="GetTissueAboveLine[Tissue, point1, point2] returns a tissue composed of only those cells with centers above (larger y coordinated) that the line connecting the two points. The two points must not lie on a vertical line.";
CellsInsidePolygon::usage="CellsInsidePolygon[Tissue, {v1,v2,..}] retursn a list of the cell numbers of cells with centers falling inside the specified polygon.";
GetTissueInsidePolygon::usage="GetTissueInisdePolygon[Tissue, {v1,v2,...}] returns the tissue composed of cells with centers falling inside the specified polygon.";


(* ::Input::Initialization:: *)
Spring::usage="Spring is an uninstantiated function used by Cellzilla arrows.\nSpring[variable, function] where variable is the spring connstant variable (typically k), and function is a function giving its dependence on cell and edge index length. Identical to the control parameter \"k\" except that it is encapsulated by the function Spring instead of k." 
Grow::usage=="Grow is an uninstantiated function used by the Cellzilla Arrow cell\[LongRightArrow]cell, Grow[Spring[..],Rate[..],Pressure[..]]"; 
GrowthRate::usage="GrowthRate is an uninstantiated function used by Cellzilla arrows.\nRate[variable, function] where variable is the spring rest length variable, and function is a function giving its growth length. Identical to the control parameter \"mu\" except that it is encapsulated by the function Rate instead of List." 
Pressure::usage="Pressure is an uninstantiated function used by Cellzilla arrows.\nPressure[variable, function] is a function that the user supplies to define the pressure as part of a Cellzilla cell growth arrow. Identical to the control parameter \"P\" except that it is encapsulated by the function Pressure instead of List. "; 
(* cell::usage="cell is the default name for a cell; lower case must be used to avoid conflict with the built in Mathematica variable Cell."*) 
ErreraRule::usage=""; 
Potential::usage=""; 
ShowCellExtensions::usage="";



(* ::Input::Initialization:: *)
Begin["`Private`"];
Needs["ComputationalGeometry`"]; 
Needs["ErrorBarPlots`"]; 
Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"];
If[Length[Names["FLAGS`ECHOLOAD"]]>0,
msgflag=ToExpression["FLAGS`ECHOLOAD"],
msgflag=True;];
saveEcho=msgflag;
FLAGS`ECHOLOAD=False; 
Quiet[Needs["xlr8r`"]];
$XLR8RLOAD=True; 
If[Length[Names["$xlr8r$Version"]]<1, 
$XLR8RLOAD=False; 
Print[Style["Warning: ", Bold, Read], Style["Cellzilla2D: xlr8r.m not found in path. It should be loaded manually before any xlr8r simulations can be run.", Bold]];
];
$XLR8RLOAD = If[$XLR8RLOAD, ToExpression["$xlr8r$Version"], "** Not Found **"]; 
FLAGS`ECHOLOAD=False;  (* may get reset in xlr8r load *)
Quiet[Needs["xSSA`"]];
$XSSALOAD=True;
If[Length[Names["$xSSA$Version"]]<1, 
$XSSALOAD=False; 
Print[Style["Warning: ", Bold, Red], Style["Cellzilla2D: xSSA.m not found in path. Some stochastic conversion functions may not work as expected. It should be loaded manually before any xSSA (stochastic) simulations can be run.", Bold]];
];
$XSSALOAD=If[$XSSALOAD, ToExpression["$xSSA$Version"], "** Not Found **"]; 
FLAGS`ECHOLOAD=saveEcho; 


(* ::Input::Initialization:: *)
Needs["JLink`"];
InstallJava[];
LoadJavaClass["java.lang.management.ManagementFactory"];
JMemQuest[x_]:= java`lang`management`ManagementFactory`getOperatingSystemMXBean[]@x[];
MemoryInstalled[]:= JMemQuest[getTotalPhysicalMemorySize];
MemoryFree[]:= JMemQuest[getFreePhysicalMemorySize];


(* ::Input::Initialization:: *)
MyFilterOptions[f_,opt___?OptionQ]:=Sequence@@FilterRules[Flatten[{opt}],Options[f]];


(* ::Input::Initialization:: *)
DifferentQ[x_,y_]:= Not[SameQ[x,y]]; 


(* ::Input::Initialization:: *)
numPairQ[{x_?NumericQ, y_?NumericQ}]:= True;
(* (\[Infinity],\[Infinity]) used as a flag for special vertices *)
numPairQ[{Infinity,Infinity}]:= True;
numPairQ[x___]:= False; 

NumBerQ[x_?NumericQ]:=True;
NumBerQ[Infinity]:=True;
NumBerQ[z___]:= False;

NumTripleQ[{x_,y_,z_}]:=And@@( NumBerQ/@{x,y,z});
NumTripleQ[x___]:= False; 


intPairQ[{i_Integer, j_Integer}]:= True;
intPairQ[x___]:= False

intListQ[{i___Integer}]:= True;
intListQ[x___]:= False; 


(* ::Input::Initialization:: *)
argument[f_[x___]]:= {x}; 


(* ::Input::Initialization:: *)
stringify[x_?StringQ]:= x;
stringify[x_]:= ToString[x];
stringify[x__]:= (Print["Error: Multiple arguments to stringify: ",x]; Abort[]);


(* ::Input::Initialization:: *)
hasvalue[x_]:= ToString[ToExpression[x]]!= x;


(* ::Input::Initialization:: *)
default$context="sim";
current$context=default$context; 

contextify[item_, context_:current$context]:= Module[{res, thecontext, theitem, badcontext},
badcontext[u_]:=  If[hasvalue[ToExpression[u]], Print["Warning: contextify: the symbol: ",u," already has a value assigned to it. This could lead to unexpected results: ", ToExpression[u]];
]; 

badcontext[item];
badcontext[context];
theitem=stringify[item];
thecontext=stringify[context];
While[StringLength[thecontext]>1 \[And]StringTake[thecontext,-1]=="`",thecontext=StringDrop[thecontext,-1] ];
If[thecontext=="" \[Or] ToUpperCase[thecontext]=="NONE", thecontext="Global"]; 
res=thecontext<>"`"<>theitem; 
badcontext[res];
Return[ToExpression[res]]
]


(* ::Input::Initialization:: *)
decontextify[x_?StringQ]:= Module[{p,q},
p = StringPosition[x,"`"];
If[Length[p]<1, Return[x]];
p=Map[First,p];
p = Last[p];
q= StringDrop[x,p];
Return[q];
];
decontextify[x_?ListQ]:= Map[decontextify,x];
decontextify[x_]:= Module[{s},
decontextify[ToString[InputForm[x]]]//ToExpression//Return;
];

decontextify[x_?StringQ, context_?StringQ]:= StringReplace[x, {context-> ""}]; 
decontextify[x_?ListQ, context_?StringQ]:= Map[decontextify[#,context]&,x]; 
decontextify[x_, context_?StringQ]:= Module[{},
decontextify[ToString[InputForm[x]],context]//ToExpression//Return;
]; 


(* ::Input::Initialization:: *)
SymbolAppend[name_?AtomQ, appendix_?StringQ]:=Symbol[stringify[name]<>appendix];

SymbolAppend[x___]:= (Print["Expecting SymbolAppend[Atom, Sring], not SymbolAppend[",x,"]"]; $Failed);


(* ::Input::Initialization:: *)
RuleQ[x_?ListQ]:= And@@RuleQ/@x; 
RuleQ[x_]:= SameQ[Head[x], Rule];
RuleQ[x_, y__]:= False;


(* ::Input::Initialization:: *)
Symbols[expression_]:= Module[{xml, XML, contexts, nonSystem},

XML[_, _, {u___}]:= {u}; 

xml=XML`MathML`ExpressionToSymbolicMathML[expression, "Formats"-> "ContentMathML"];
xml=Cases[xml,XMLElement["ci",__], Infinity];
xml = xml/.{XMLElement-> XML};
xml=Flatten[xml];
xml=Union[xml];
xml = Symbol/@xml;

contexts = Context/@xml;
nonSystem = Not[Equal[#,"System`"]]&/@contexts;
xml = Pick[xml, nonSystem];

Return[xml]; 
]


(* ::Input::Initialization:: *)
\[CapitalPsi][u_]:=(u+Abs[u])/2;


(* ::Input::Initialization:: *)
yymmdd[]:=DateString[{"YearShort","Month","Day"}];
dd\[UnderBracket]mon\[UnderBracket]yy[]:= DateString[{"Day","-","MonthNameShort","-","YearShort"}]; 
dd\[UnderBracket]mon\[UnderBracket]yyyy[]:= DateString[{"Day","-","MonthNameShort","-","Year"}]; 
dd\[UnderBracket]month\[UnderBracket]yyyy[]:= DateString[{"Day","-","MonthName","-","Year"}]; 
hhmmss[] := DateString[{"Hour24", "Minute","Second"}]; 
now[]:= dd\[UnderBracket]mon\[UnderBracket]yyyy[]<>"-at-"<>DateString["Time"];
dmyhms[]:= now[]; 


(* ::Input::Initialization:: *)
CreateHomeFolder[]:= Module[{h,d,i},
i=0;
d=$HomeDirectory; 
h=ToFileName[d, "Cellzilla"]; 
If[FileExistsQ[h],
If[DirectoryQ[h], 
Return[h], 
Print["Error, the file ", h, " exists and is not a directory. Please rename this file or move it to another location. "]; Abort[]
]; 
,
CreateDirectory[h];
Return[h]
]]; 


(* ::Input::Initialization:: *)
createTodaysFolder[base_:"Simulations-"]:= Module[{f,f1,i},
f=ToString[base]<>dd\[UnderBracket]mon\[UnderBracket]yy[];
f1=f;i=0;
While[FileExistsQ[f1],
If[DirectoryQ[f1],Return[f1]]; 
i=i+1;
f1=f<>ToString[i];
];
CreateDirectory[f1];
Return[f1]
]


(* ::Input::Initialization:: *)
createUniqueFolder[base_:"Simulation-"]:= Module[{f,f1,i},
(* f=ToString[base]<>hhmmss[]; *)
f=ToString[base]<>DateString[{"Day","MonthNameShort","YearShort","-","Hour24","Minute"}];
f1=f;i=0;
While[FileExistsQ[f1],
i=i+1;
f1=f<>"-"<>ToString[i];
];
CreateDirectory[f1];
Return[f1]
]


(* ::Input::Initialization:: *)
UniqueFileName[folder_,base_,extension_]:= Module[{f,f1,i,b},
b=base; 
f=ToFileName[folder, base]; 
i=0;
f1= f<>"."<>extension;
While[FileExistsQ[f1],
i=i+1; 
f1=f+ToString[i]<>"."<>extension;
];
f1
];
TimedUniqueFileName[folder_,base_,extension_]:= Module[{b,d},
d=hhmmss[];
b = If[StringLength[base]>0,base<>"-"<>d,d]; 
UniqueFileName[folder,b,extension]
];
UniqueFileName[x___]:= (Print["Expecting UniqueFileName[folder,base,extension], not UniqueFileName[",x,"]"]; Abort[]); 



(* ::Input::Initialization:: *)
Intersects[A_?ListQ,B_?ListQ]:=Length[Intersection[A,B]]>0;



(* ::Input::Initialization:: *)
AbortIf[flag_, message_]:= If[flag, Print[message];Abort[]]; 


(* ::Input::Initialization:: *)
IntervalCheck[x_, All]:= True; 
IntervalCheck[x_, {xmin_,xmax_}]:= IntervalMemberQ[Interval[{xmax,xmin}], x];
IntervalCheck[{x_,y_}, xrange_,yrange_]:= Module[{xok,yok,zok},
xok = IntervalCheck[x, xrange];
yok=IntervalCheck[y, yrange]; 
And[xok,yok]
];
IntervalCheck[{x_,y_,z_}, xrange_,yrange_,zrange_]:= Module[{xok,yok,zok},
xok = IntervalCheck[x, xrange];
yok=IntervalCheck[y, yrange]; 
zok = IntervalCheck[z,zrange]; 
And[xok,yok,zok]
]


(* ::Input::Initialization:: *)
BellCurve[max_, {mux_,muy_},{sigmax_,sigmay_}]:= Module[{m},
m=(2.0*Pi*sigmax*sigmay);
(max*m)*PDF[BinormalDistribution[{mux,muy},{sigmax,sigmay}, 0], {#1,#2}]&
];
BellCurve[max_, mu_, sigma_]:= Module[{m},
m=Sqrt[2.0*Pi]*sigma; 
m*max*PDF[NormalDistribution[mu,sigma]][#]&
]; 


(* ::Input::Initialization:: *)
distance[v1_?ListQ,v2_?ListQ]:=Module[{v,nv1,nv2},
nv1=(Abs[Norm[v1]]==\[Infinity]);
nv2=(Abs[Norm[v2]]==\[Infinity]);
If[nv1 \[And]nv2, Return[Indeterminate]]; 
If[nv1\[Or]nv2, Return[\[Infinity]]]; 
v=v1-v2;
Return[Sqrt[v.v]];];


(* ::Input::Initialization:: *)
Vector[from_?PointQ, to_?PointQ]:= to-from; 
Vector[{from_?PointQ, to_?PointQ}]:= to-from;


(* ::Input::Initialization:: *)
unitVector[v1_?ListQ,v2_?ListQ]:=Module[{v,d},If[v1==v2,Return[{0,0}]];
v=v1-v2;
d=distance[v1,v2];
v=v/d;
Return[v];];


(* ::Input::Initialization:: *)
PointQ[{x_Symbol,y_Symbol}]:=True;
PointQ[{x_[t_], y_[t_]}]:= True;
PointQ[{x_[i_][t_], y_[i_][t_]}]:= True;
PointQ[{x_?NumericQ, y_?NumericQ}]:= True; 
PointQ[x___]:=False;

NumericPointQ[u___]:= numPairQ[u]; 

PointListQ[{p__?PointQ}]:= True;
PointListQ[x___]:= False; 

CZEdgeQ[{p1_?PointQ, p2_?PointQ}]:= True;
CZEdgeQ[x___]:= False; 


(* ::Input::Initialization:: *)
Points2Edges[{points__?PointQ}]:= Partition[{points}, 2, 1,1]


(* ::Input::Initialization:: *)
PointOnLineSegment[{{x1_, y1_}, {x2_, y2_}}, {p_, q_}, tol_:0.00001]:= Module[
{tolerance,x,y, xmin, xmax, ymin, ymax, tx, ty, segLen},
segLen = distance[{x1,y1}, {x2,y2}]; 
tolerance=Max[tol, 0]*segLen; 
xmin=Min[x1,x2]; xmax=Max[x1,x2];
ymin = Min[y1,y2]; ymax=Max[y1, y2];   
If[y1==y2,
y=y1;
Return[(Abs[q-y]<= tolerance)\[And] (xmin-tolerance<= p) \[And] (p<= xmax+tolerance)]; 
]; 
If[x1==x2,
(* Print["x1=x2"]; *)
x=x1;

(* Print[{tolerance, (Abs[p-x]\[LessEqual] tolerance) ,p,x,(ymin-tolerance\[LessEqual] q) ,ymin, q,ymax, (q\[LessEqual] ymax+tolerance)}]; *)

Return[(Abs[p-x]<= tolerance) \[And](ymin-tolerance<= q) \[And] (q<= ymax+tolerance)]; 
]; 
 
tx=(p-x1)/(x2-x1); 
ty=(q-y1)/(y2-y1); 
Return[Abs[tx-ty]<= tolerance]; 
]; 
PointOnLineSegment[x___]:= (Print["Expecting PointOnLineSegment[{{x1,y1}, {x2,y2}}, {xp,yp}, tolerance]"]; $Failed); 


(* ::Input::Initialization:: *)
Boundary[{points__?PointQ}]:= Boundary[{points}, {}]; 

Boundary[{points__?PointQ}, {dir___}, opt___?OptionQ]:= Module[{g}, 

g=Line[Append[{points}, First[{points}]]]; 
If[Length[{dir}]>0, 
g={Directive@@{dir}, g},
g={g}
];

g=Graphics[g, opt];

Return[g];
]


(* ::Input::Initialization:: *)
DrawSpokes[SpokeData_, opt___?OptionQ]:= Module[{g, ep, angles, vectors, pointstyle, spokestyle, points, number, numbers , np, origin, textcolor, textstyle, offset},

ep="Endpoints"/.SpokeData;
vectors="Spokes"/.SpokeData;
angles="Angles"/.SpokeData;
origin="Origin"/.SpokeData;

spokestyle="SpokeStyle"/.{opt}/.{"SpokeStyle"-> {Thin, Blue, Dotted}}; 
pointstyle="PointStyle"/.{opt}/.{"PointStyle"-> {PointSize[.015], Red}}; 
number="Numbers"/.{opt}/.{"Number"-> False}; 
offset = "Offset"/.{opt}/.{"Offset"-> .1}; 
textcolor="TextColor"/.{opt}/.{"TextColor"-> Black}; 
textstyle="TextStyle"/.{opt}/.{"TextStyle"-> {FontFamily-> "Times", FontSize-> 16}};


g = Line/@vectors;

spokestyle=Directive@@Flatten[{spokestyle}]; 
g=Flatten[{spokestyle, g}];

points = Point/@ep;
pointstyle= Directive@@Flatten[{pointstyle}]; 
g=Flatten[{g, pointstyle, points}];

If[number, 
numbers=ToString/@Range[Length[ep]];

vectors = Vector/@vectors;
np = (#(1+offset/Norm[#])+origin)&/@vectors; 

numbers = MapThread[Text, {numbers, np}];
g= Flatten[{g,textcolor,  numbers}];
];

g=Flatten[{g, BaseStyle-> textstyle}]; 
 Return[g]; 
]


(* ::Input::Initialization:: *)
ShowTissue[tissue_?DTissueQ,opt___?OptionQ]:= Module[{cellnumbers,T,g,c,toDynamicNumberRules,toStaticNumberRules},
cellnumbers="CellNumbers"/.{opt}/.{"CellNumbers"-> False}; 
T=DTissue2Tissue[tissue]; 
c=First/@TissueCells[tissue]; toDynamicNumberRules=MapThread[Rule,{Range[Length[c]],c}];toStaticNumberRules=Reverse/@toDynamicNumberRules;
If[cellnumbers,
cellnumbers=First/@TissueCells[tissue];
g=ShowTissue[T,"CellNumbers"-> cellnumbers, "ToDynamic"-> toDynamicNumberRules,"ToStatic"-> toStaticNumberRules, opt]; 
Return[g];
]; 
ShowTissue[T,"ToDynamic"-> toDynamicNumberRules,"ToStatic"-> toStaticNumberRules,opt]
]


(* ::Input::Initialization:: *)
ShowTissue[tissue_?TissueQ, opt___?OptionQ]:= Module[
{cellstyles, n, nv, ne,cells, boundarystyle, cellnumbers,vertexnumbers,vnstyle,vertexstyle,numberstyle, gvertex, gedgenums,edgenumbers, edgenumberstyle, danglingEdges, deg, gdir, outer, picture, edgestyles, firststyle, nuclear, gBoundary,vertexnumberstyle,
poly, polys, v, e, starts, ends,vers, edges, line, edgecellpairs, centroids, gedges, cc,ee,st,
DefaultEDGECCOLOR=Black, 
DefaultCELLCOLOR=LightGreen,
DefaultBORDERCOLOR=Brown,
dbg,dPrint, all,vflags,eflags,eused,vused,toStatic,toDynamic, dome, flat, 
xrange, yrange,vertices, cell1
},

dbg = "DebugShowTissue"/.{opt}/.{"DebugShowTissue"->False};
dPrint[x___]:= If[dbg, Print["ShowTissue: ",x]]; 

dome = "Dome"/.{opt}/.{"Dome"-> False}; 
flat = Not[dome]; 

xrange="xrange"/.{opt}/.{"xrange"-> All};
yrange="yrange"/.{opt}/.{"yrange"-> All}; 

cells=CellVertexCoordinates[tissue]; 
If[Length[cells]<1, Print["No Cells"]; Abort[]]; 
cell1=cells[[1]]; 
If[Length[cell1[[1]]]>2, 
Return[ShowZProjection[tissue, opt]]
];

centroids = Centroid[tissue]; 

dPrint["options: ",{opt}]; 

toStatic = "ToStatic"/.{opt}/.{"ToStatic"-> {}};
toDynamic = "ToDynamic"/.{opt}/.{"ToDynamic"-> {}};


If[MemberQ[cells, $Failed], Print["Warning: ShowTissue: unable to plot some cells becasue of inconsistent data."]; ]; 

n=Length[cells]; 

(** cell colors **)

cellstyles="CellStyles"/.{opt}/.{"CellStyles"-> Table[Automatic, {n}]};
If[!ListQ[cellstyles], cellstyles={cellstyles}];  
firststyle=If[Length[cellstyles]>0,Last[cellstyles],Automatic]; 
If[Length[cellstyles]!=  n, 
cellstyles=PadRight[cellstyles,n,  firststyle]
]; 
dPrint["cellstyles: ", Short[cellstyles,10]]; 

nuclear = "Nucleus"/.{opt}/.{"Nucleus"-> False}; 

nuclear = Flatten[{nuclear}];
firststyle=Last[nuclear]; 
nuclear=PadRight[nuclear,n,firststyle]; 

boundarystyle="BoundaryStyle"/.{opt}/.{"BoundaryStyle"-> Automatic}; 

If[flat,
gBoundary=ShowTissueBoundary[tissue, boundarystyle]; 
];

(** cell boundary and labels **)


cellnumbers="CellNumbers"/.{opt}/.{"CellNumbers"-> False}; 
numberstyle="CellNumberStyle"/.{opt}/.{"CellNumberStyle"-> Automatic};

If[cellnumbers == True,cellnumbers=Range[n]];
If[cellnumbers == False, cellnumbers=Table[-1, {n}]];

poly[vers_, color_, number_,nuclear_]:= Module[{c,x,num,ok},

c=color/.{Automatic-> DefaultCELLCOLOR};
x = Centroid[vers];  
If[number>0, num=ToString[number], num=""]; 
If[nuclear,
Graphics[{Directive[Flatten[{c}]], Point[x],Black, Text[Style[num,Directive[{numberstyle}]], x]}]
,
ok=Or@@(IntervalCheck[#,xrange,yrange]&/@vers);
If[ok,
Graphics[{Directive[Flatten[{c}]], Polygon[vers],Black, Text[Style[num,Directive[{numberstyle}]], x]}],
Graphics[{}]]
]
];  

If[flat,
polys = Show[MapThread[poly, {cells, cellstyles, cellnumbers, nuclear}]]; 
]; 

e=TissueEdges[tissue];
ne = NTissueEdges[tissue]; 

v=TissueVertices[tissue];
nv=NTissueVertices[tissue];

(* do we want to plot ALL the vertices and edges, or just the ones in CELLS? *)

all = "All"/.{opt}/.{"All"-> False}; 


If[all, 
eflags = Table[True,{ne}];
vflags = Table[True, {nv}];
eused=Range[ne];
vused=Range[nv]; 


 ,


eused = EdgesUsed[tissue];
vused = VerticesUsed[tissue]; 
eflags = MemberQ[eused,#]&/@Range[ne];
vflags = MemberQ[vused, #]&/@Range[nv]; 
];


(** label the edges if requested *)




edgenumbers =(( "EdgeNumbers"/.{opt})/.{"EdgeNumbers"-> False}/.{False->Pick[Table[-1, {ne}],eflags]}); 

edgestyles="EdgeStyles"/.{opt}/.{"EdgeStyles"-> Table[Automatic, {ne}]};  
If[!ListQ[edgestyles], edgestyles={edgestyles}];  
firststyle=If[Length[edgestyles]>0,edgestyles//Last,Automatic]; 
If[Length[edgestyles]!=  Length[eused], 
edgestyles=PadRight[edgestyles,ne,  firststyle]]; 
edgestyles = Pick[edgestyles,eflags]; 


edgenumberstyle= Automatic;
If[edgenumbers,  
edgenumbers = Pick[Range[ne],eflags];
edgenumberstyle="EdgeNumberStyle"/.{opt}/.{"EdgeNumberStyle"-> Automatic};
,
edgenumbers=Pick[Table[-1, {ne}],eflags];
]; 
 


line[v1_, v2_,  color_, number_]:= Module[{c,l,text,ok}, 
c=color/.{Automatic-> DefaultEDGECCOLOR};
l=Line[{v1, v2}];
text = If[number>0, ToString[number], ""];
If[ToString[color]=="None",
Graphics[{}]
,
ok=Or@@(IntervalCheck[#,xrange,yrange]&/@{v1,v2});
If[ok, 
Graphics[{Directive[Flatten[{c}]], l, Black, Text[Style[text,Directive[edgenumberstyle]], 0.5*(v1+v2)]}],
Graphics[{}]]
]
];

vers=v[[#]]&/@Pick[e,eflags];

{starts, ends}=Transpose[vers]; 

If[flat,
edges =Show[ MapThread[line, {starts, ends, edgestyles, edgenumbers }]];
 ]; 


(** display the vertices if requested *)


If[flat,
vertexstyle="Vertices"/.{opt}/.{False-> {}}/.{"Vertices"-> {}}; 
If[vertexstyle==True, vertexstyle= {Black}]; 
gvertex=Graphics[{}]; 

allvertices = TissueVertices[tissue]; 
pickable[j_]:= IntervalCheck[allvertices[[j]],xrange,yrange]; 
pickTheseVertices = pickable/@vused;
pickTheseVertices=Select[vused, pickable[#]&]; 
vertices = allvertices[[pickTheseVertices]]; 


If[Length[{vertexstyle}//Flatten]>0, 
vertexstyle=Directive[Flatten[{vertexstyle}]]; 



gvertex = Point/@vertices;  
gvertex=Graphics[Flatten[{vertexstyle, gvertex}]]; 
];
]; 
(** label the vertices if requested **)
If[flat,
vertexnumbers=(("VertexNumbers"/.{opt})/.{False-> {}})/.{"VertexNumbers"-> {}}; 
If[vertexnumbers==True, vertexnumbers={Darker[Red]}]; 

vertexnumberstyle= Automatic;
vertexnumberstyle="VertexNumberStyle"/.{opt}/.{"VertexNumberStyle"-> Automatic};

If[Length[{vertexnumbers}//Flatten]>0,
vnstyle=Directive[Flatten[{vertexnumbers}]]; 

(* vertexnumbers=Pick[Range[nv],vflags];
vertexnumbers = MapThread[Text[Style[#1,Directive[{vertexnumberstyle}]],#2]&, 
{vertexnumbers, Pick[TissueVertices[tissue],vflags]}];
*)

vertexnumbers = MapThread[Text[Style[#1,Directive[{vertexnumberstyle}]],#2]&, 
{pickTheseVertices, vertices}];


vertexnumbers=Graphics[Flatten[{vnstyle, vertexnumbers}]]; 

,
vertexnumbers=Graphics[{}]; 
]; 
]; 

If[flat,
outer = "Outer"/.{opt}/."Outer"-> "None"; 
If[ToString[outer]!= "None", 
outer = ShowTissueBoundary[tissue, outer],
outer=Graphics[]
]; 
]; 


EdgeCellLine[cell_, edge_, style_, offset_:0.02]:= Module[{v1,v2, p1, p2,c},
(* vertex numbers *)
{v1,v2}=e[[edge]]; 
(* vertex coordinates *)
p1=v[[v1]]; p2=v[[v2]];
c = centroids[[cell]]; 
p1 =   p1 + (c-p1)*offset;
p2 = p2 + (c-p2)*offset;
line[p1,p2, style, -1]
];


edgecellpairs="EdgeCellPairs"/.{opt}/.{"EdgeCellPairs"-> {}}; 
dPrint["edgeCellPairs: ", edgecellpairs]; 
 
 
If[Length[edgecellpairs]>0,
{cc,ee,st}=Transpose[edgecellpairs]; 
dPrint["toStatic: ", toStatic]; 
cc = cc/.toStatic;


gedges = Show[MapThread[EdgeCellLine,{cc,ee,st}]];
(* now it is in static coordinates, in case needed for dome *)
edgecellpairs=Transpose[{cc,ee,st}];

, 
gedges=Graphics[{}]; 
]; 


picture=Graphics[{}]; 
If[flat,
picture=
With[{gopt=MyFilterOptions[Graphics,opt]}, 
Show[{polys, edges, gvertex, vertexnumbers,outer, gedges,gBoundary},
gopt]
]; 

]; 
If[dome,
dPrint["cellstyles=", Short[cellstyles,5]]; 
picture=ParaboloidPlot[tissue, "CellStyle"-> (cellstyles/.{Automatic-> DefaultCELLCOLOR}), "EdgeStyle"-> (edgestyles/.{Automatic-> DefaultEDGECCOLOR}),
"EdgeCellPairs"-> edgecellpairs,opt
];
]; 

Return[picture]; 
]


(* ::Input::Initialization:: *)
ShowTissue[tissue_?TorusQ, opt___?OptionQ]:= ShowTissue[TorusTissue[tissue], opt];


(* ::Input::Initialization:: *)
ShowEdgeNormal[{p1_?PointQ, p2_?PointQ}, style_:{}, edge_:False]:= Module[{nv, origin, g, l},
nv=NormalVector[{p1,p2}]; 
origin = (p1+p2)/2; 
nv={style, Arrow[{origin, origin+nv}]};  
g=Graphics[Flatten[nv]]; 
If[edge,
l=Graphics[Line[{p1, p2}]],  
l=Graphics[] ];
Return[Show[g, l]]
]


(* ::Input::Initialization:: *)
ShowOutwardNormals[{p__?PointQ}, style_:{}, edge_:False]:=Module[
{e, vecs, midpoints, arrows, l},
vecs = OutwardNormalVector[{p}, 0]; 
e=Append[{p}, First[{p}]]; 
midpoints = Mean/@Partition[e,2,1];
arrows = MapThread[Arrow[{#1, #2}]&, {midpoints, midpoints+vecs}]; 
arrows={style, arrows}//Flatten; 
arrows=Graphics[arrows]; 
If[edge,
l=Graphics[Line[e]],  
l=Graphics[] ];
Show[arrows, l]
];
ShowOutwardNormals[T_?TissueQ, opt___?OptionQ]:= Module[{edges, cells, CVC, g1, style, v, e, g2},
cells="Cells"/.{opt}/.{"Cells"-> {}};
edges="Edges"/.{opt}/.{"Edges"-> {}}; 
style="Style"/.{opt}/.{"Style"-> {}}; 

g1=Graphics[{}]; 
If[Length[cells]>0, 
CVC = CellVertexCoordinates[T][[cells]]; 
g1=ShowOutwardNormals[#, style]&/@CVC;
]; 

g2=Graphics[{}];
If[Length[edges]>0,  
e=EdgeVertices[T][[edges]]; 
g2=ShowOutwardNormals[#,style]&/@e; 
];

Show[g1,g2]
]


(* ::Input::Initialization:: *)
ShowTissueCells[tissue_?TissueQ, {cells__?IntegerQ}, color_, opt___?OptionQ]:= Module[{colors,p,n, dc, T1,v,e,c},
n=NTissueCells[tissue]; 
dc = "CellStyles"/.{opt}/.{"CellStyle"-> LightGreen}; 
colors = If[MemberQ[{cells}, #], color, dc]&/@Range[n]; 
If[Length[TissueVertices[tissue][[1]]]==3, 
{v,e,c}=tissue/.{Tissue-> List}; 
T1=Tissue[Most/@v,e,c];
,
T1=tissue];
p=ShowTissue[T1, "CellStyles"-> colors, opt];
Return[p]; 
];
ShowTissueCells[tissue_?TissueQ, {cells__?IntegerQ}]:= ShowTissueCells[tissue, {cells}, LightPink];
ShowTissueCells[x___]:= (
Print[Short/@{x},15]; Print["Error: Expecting ShowTissueCells[tissue, {i1,i2,...}] or \nShowTissueCells[tissue, {i1, i2, ..}, color, options]"]; $Failed);


(* ::Input::Initialization:: *)
ShowTissueFunction[tissue_?TissueQ, 
f_, {fmin_, fmax_}, {cmin_, cmax_},
opt___?OptionQ]:=Module[
{n, centroids, values,colors,pic}, 

n=NTissueCells[tissue]; 

centroids = Centroid[tissue]; 
values = (f@@#)&/@centroids;
colors = RGBInterpolate[#, {fmin, fmax}, {cmin, cmax}]&/@values; 
pic = ShowTissue[tissue, "CellStyle"-> colors, opt]; 
Return[pic]
];


(* ::Input::Initialization:: *)
ShowTissueBoundary[q_, style_:{Thin,Black}]:= Module[
{eb,v,e,defaultStyle={Thin,Black}, STYLE},
STYLE=style;
If[ToString[STYLE]=="Automatic", STYLE=defaultStyle]; 
If[ToString[STYLE]=="None", Return[Graphics[{}]]]; 
eb = EdgesOnBoundary[q];
e=TissueEdges[q][[eb]];
v=TissueVertices[q]; 
Graphics[{Directive[STYLE],Line[v[[#]]]&/@e}]
]


(* ::Input::Initialization:: *)
Circle3D[{x_,y_,z_},r_]:=Line[(r*{Cos[#],Sin[#],0}+{x,y,z})&/@Range[0,2 Pi,2 Pi/100.]]


(* ::Input::Initialization:: *)
SolutionVars[system_]:= Union[Head/@SolutionVariables[system]]; 


(* ::Input::Initialization:: *)
SolutionVariables[system_]:= SolutionVariables[system, {}]; 
SolutionVariables[system_, {var___}]:= Module[{s,v, p},
s=Flatten[{system}]; 
v=First/@s;
If[Length[{var}]==0, Return[v]];
v=Join[Cases[ v,#, Infinity], Cases[v, #[_], Infinity], Cases[v, #[_][_], Infinity]]&/@{var}; 
v=Flatten[v]
];
SolutionVariables[x___]:= "??";


(* ::Input::Initialization:: *)
MultiPlot[solution_, {var__},  {time_, tstart_, tend_}, opt___?OptionQ]:= Module[
{variables, points, data, sol1, times, singleLine, singleCurve, dir, n},
points="PlotPoints"/.{opt}/.{"PlotPoints"-> 50};
variables=SolutionVariables[solution, {var}];
sol1=variables/.solution;
times = Range[tstart, tend,1.0* (tend-tstart)/points];
data[oneSolution_]:= (oneSolution/.{time-> #})&/@times;
singleLine[oneSolution_]:= Line[Transpose[{times, data[oneSolution]}]]; 
singleCurve[oneSolution_, graphicsDirectives_]:=Graphics[{graphicsDirectives, singleLine[oneSolution]}]; 

dir="GraphicsDirectives"/.{opt}/.{"GraphicsDirectives"-> Automatic};
n=Length[sol1]; 
If[ToString[dir]=="Automatic",
dir=Hue/@((1.0/n)*Range[0,n-1])
]; 
If[!ListQ[dir], dir = Table[dir, {n}]]; 
dir = PadRight[dir, n, Indeterminate]/.{Indeterminate-> {}}; 


With[{ShowOptions=MyFilterOptions[Graphics,opt]}, 
Show[MapThread[singleCurve, {sol1, dir}], ShowOptions, 
Frame-> True, FrameTicks-> {Automatic,Automatic, None, None}, AspectRatio-> 1]
]

];
MultiPlot[x___]:= Print["??"]; 


(* ::Input::Initialization:: *)
RowPlot[solution_, {var__}, {t_, tstart_, tend_}, opt___?OptionQ]:= With[{gropt=MyFilterOptions[GraphicsRow, opt]}, 
GraphicsRow[
MultiPlot[solution, {#}, {t, tstart, tend}, opt, PlotLabel-> ToString[#]]&/@{var}, gropt]
];


(* ::Input::Initialization:: *)
GeometricSnapShot[tissue_?TissueQ, solution_, {x_, y_}, {timeVariable_, time_}, opt___?OptionQ]:= Module[{c,e, n, v, p},
c=TissueCells[tissue];
e=TissueEdges[tissue];
n=NTissueVertices[tissue]; 
 v=({x[#][timeVariable], y[#][timeVariable]}&/@Range[n])/.solution/.{timeVariable-> time} ;
p=Tissue[v,e,c];
p=ShowTissue[p, opt]; 
Return[p]; 
];
GeometricSnapShot[DT_DTissue, x___]:= Module[{T}, 
T=DTissue2Tissue[DT];
GeometricSnapShot[T, x]
]; 

GeometricSnapShot[x___]:= (Print["Expecting GeometricSnapShot[Tissue, solution, {x,y}, {timevariable, time}]"]; Abort[]); 


(* ::Input::Initialization:: *)
regularPolygon[n_,start_: 0,aspect_: 1.0,rnd_:-1,rotationAngle_: 0]:=Module[{v,angles,rv,RM},(*generate the precise vertex coordinates*)angles=Table[j,{j,0.0+start,0.0+start+2.0*((n-1)/n) Pi,2.0*Pi/n}];
v={Cos[#],aspect*Sin[#]}&/@angles;
(*add randomness if desired*)If[rnd>0,rv:=RandomReal[{-rnd,rnd}];
v=Map[{rv,rv}+#&,v];];
(*rotation through an angle rotationAngle*)RM=RotationMatrix[rotationAngle];
v=v.RM;
Return[v];]


(* ::Input::Initialization:: *)
RegularStar[npoints_,ROverr_: 0,start_: 0,aspect_: 1.0,rand_:-1,rotationAngle_: 0]:=Module[{v,n,angles,rv,RM,Rr,mults,rnd},(*generate the precise vertex coordinates*)n=npoints*2;
rnd=If[rand>0,rand,0];
Rr=Abs[ROverr];
If[Rr==0,Rr=1];
If[Rr<1,Rr=1/Rr];
angles=Table[j,{j,0.0+start,0.0+start+2.0*((n-1)/n) Pi,2.0*Pi/n}];
mults=Table[If[EvenQ[j],Rr,1]*(1+RandomReal[{-rnd,rnd}]),{j,0,n-1}];
v={Cos[#],aspect*Sin[#]}&/@angles;
v=mults*v;
(*rotation through an angle rotationAngle*)RM=RotationMatrix[rotationAngle];
v=v.RM;
Return[v];]


(* ::Input::Initialization:: *)
InertiaMatrix[{xydata__?PointQ}]:=InertiaMatrix[xydata]
InertiaMatrix[xydata__?PointQ]:=Module[{v,n,Ixx,Ixy,Iyy,x,y,Inertia},v={xydata};
n=Length[v];
AppendTo[v,v[[1]]];
x[i_]:=v[[i,1]];
y[i_]:=v[[i,2]];
Ixx=0;Ixy=0;Iyy=0;
For[i=2,i<=n+1,i++,Ixx=Ixx+(x[i]^3+x[i]^2 x[i-1]+x[i] x[i-1]^2+x[i-1]^3) (y[i]-y[i-1]);
Iyy=Iyy+(y[i]^3+y[i]^2 y[i-1]+y[i] y[i-1]^2+y[i-1]^3) (x[i]-x[i-1]);
Ixy=Ixy+(y[i] (3 x[i]^2+2 x[i] x[i-1]+x[i-1]^2)+y[i-1] (x[i]^2+2 x[i] x[i-1]+3 x[i-1]^2)) (y[i]-y[i-1])];
Ixx=Abs[Ixx]/12;
Iyy=Abs[Iyy]/12;
Ixy=Abs[Ixy]/24;
Inertia={{Ixx,Ixy},{Ixy,Iyy}};
Return[Inertia];];

InertiaMatrix[tis_?TissueQ,n_?IntegerQ]:= Module[{},
If[n<1 \[Or] n>NTissueCells[tis], 
Print["Error: InertiaMatrix[tissue,",n,"]; tissue only has ", NTissueCells[tis]," cells."];
Return[$Failed]]; 
Return[InertiaMatrix[CellVertexCoordinates[tis,n]]];
];
InertiaMatrix[tis_?TissueQ]:= InertiaMatrix/@CellVertexCoordinates[tis]; 

InertiaMatrix[x___]:=(Print["Error: Expecting InertiaMatrix[point1, point2, ...] or \nInertiaMatrix[tissue,n] or \nInertiaMatrix[tissue]"]; $Failed);


(* ::Input::Initialization:: *)
Mass[{xydata__?PointQ}]:= Mass[xydata]; 
Mass[xydata__?PointQ]:=Module[{v,j,n,x,y,mass},(*will be negative if cells are clockwise,positive otherwise*)
v={xydata};
n=Length[v];
mass=0;
x[i_]:=If[i==0,v[[n,1]],v[[i,1]]];
y[i_]:=If[i==0,v[[n,2]],v[[i,2]]];
For[j=0,j<n,j++,mass=mass+x[j]*y[j+1]-x[j+1] y[j];];
mass=mass/2;
Return[mass];];
MassSign[xydata__?PointQ]:=Module[{m},m=Mass[xydata];If[m!=0,m=m/Abs[m]];
Return[m]];
MassSign[{x__?PointQ}]:=MassSign[x];
Mass[x___]:= (Print["Expecting Mass[..list of points..]"]; Abort[]); 


(* ::Input::Initialization:: *)
areafunction[{}]:= 0; 
areafunction[xydata__?PointQ]:=Abs[Mass[xydata]]; 
areafunction[{xydata__?PointQ}]:=areafunction[xydata];

areafunction[tis_?TissueQ, i_?IntegerQ]:= areafunction[CellVertexCoordinates[tis,i]];

areafunction[tis_?TissueQ, {i__?IntegerQ}]:= Module[{cvc},
cvc = CellVertexCoordinates[tis]; 
cvc = cvc[[{i}]]; 
Return[areafunction/@cvc]; 
]

areafunction[tis_?TissueQ]:= areafunction/@CellVertexCoordinates[tis]; 

areafunction[DT_?DTissueQ]:= areafunction/@CellVertexCoordinates[DT]; 
areafunction[DT_?DTissueQ, i_?IntegerQ]:= areafunction[CellVertexCoordinates[DT,i]]; 

areafunction[P_?PointList3DQ]:= PolygonArea[P]; 

areafunction[x___]:=(Print["Expecting areafunction[P1, P2, ...] or areafunction[tissue, i] or areafunction[tissue]"]; $Failed);


(* ::Input::Initialization:: *)
CentroidFormula[T_Tissue,j_, x_,y_,area_]:= Module[{cv,n,myx,myy,f,XVAR,YVAR,sign},
cv=CellVertexNumbers[T,j];
sign=MassSign[CellVertexCoordinates[T,j]]; 
n=Length[cv];
myx[i_]:= x[cv[[i]]][Global`t];
myy[i_]:= y[cv[[i]]][Global`t];
f=CentroidFormula[XVAR,YVAR,n]; 
sign*(f/.{XVAR-> myx, YVAR-> myy})/(6*area[j][Global`t])
]


(* ::Input::Initialization:: *)
CentroidFormula[xvar_,yvar_,n_]:=Module[{x,y, cx, cy,j},

x[0]:= xvar[n];
x[i_]:= xvar[i]; 
y[0]:= yvar[n];
y[i_]:=yvar[i]; 
cx = cy = 0; 
For[j=0,j<n,j++,
cx=cx+(x[j]+x[j+1]) (x[j] y[j+1]-x[j+1] y[j]);
cy=cy+(y[j]+y[j+1]) (x[j] y[j+1]-x[j+1] y[j]);
];
{cx, cy}
]


(* ::Input::Initialization:: *)
Centroid[{xydata__?PointQ}]:= Centroid[xydata]; 
Centroid[xydata__?PointQ]:=Module[{v,j,n,x,y,cx,cy,area,sign,centroid},v={xydata};
n=Length[v];
cx=cy=0;
sign=MassSign[xydata];
area=areafunction[xydata];
x[i_]:=If[i==0,v[[n,1]],v[[i,1]]];
y[i_]:=If[i==0,v[[n,2]],v[[i,2]]];
For[j=0,j<n,j++,cx=cx+(x[j]+x[j+1]) (x[j] y[j+1]-x[j+1] y[j]);
cy=cy+(y[j]+y[j+1]) (x[j] y[j+1]-x[j+1] y[j]);];
If[SameQ[area,0],
centroid=sign*{cx,cy};
centroid=Centeroid[{xydata}]; 
Return[centroid];];
If[Equal[area,0],
centroid=sign*{cx,cy};
centroid=Centeroid[{xydata}]; 
Return[centroid];];
centroid=sign*{cx,cy}/(6*area);
Return[centroid];
];
Centroid[tiss_?TissueQ]:= Centroid/@CellVertexCoordinates[tiss]; 
Centroid[tiss_?TissueQ, cellNumber_?IntegerQ]:= Centroid[tiss, {cellNumber}][[1]]; 
Centroid[tiss_?TissueQ, {cells__?IntegerQ}]:= Module[{cvc, centroids,n},
cvc = CellVertexCoordinates[tiss]; 
n=NTissueCells[tiss]; 
If[(#>n)\[Or](#<1), Print["Error: Centroid: Cell ", #, " does not exist."]]&/@{cells}; 
cvc = cvc[[{cells}]]; 
centroids = Centroid/@cvc;
Return[centroids]; 
];
Centroid[q_?DTissueQ, x___]:= Centroid[DTissue2Tissue[q], x]; 


Centroid[x___]:= (Print["Error: Expecting Centroid[{v1,v2, ...}]"]; $Failed);


(* ::Input::Initialization:: *)
Centeroid[{xydata__?PointQ}]:= Mean[{xydata}];
Centeroid[T_?ISTissue]:= Module[{cvc},
cvc=CellVertexCoordinates[T]; 
Centeroid/@cvc
];
Centeroid[T_?ISTissue, n_]:= Module[{cvc},
cvc=CellVertexCoordinates[T,n];
Centeroid[cvc]
];
Centeroid[x___]:= (Print["Expecting Centeroid[{{x1,y1},{x2,y2},...}] or Centeroid[Tissue] or Centeroid[Tissue,number], not:", x]; Abort[];)


(* ::Input::Initialization:: *)
TissueCentroid[g_Tissue]:= Module[{e,v,c, G},
(* create a tissue with a single cell that has only the boundary edges *)
e=TissueEdges[g]; 
v=TissueVertices[g]; 
c={EdgesOnBoundary[g]};
G=Tissue[v,e,c];
(* need to sort the edges to make the algorithm work properly *)
c={"Edges"/.SortCellsCounterClockwise[G][[1]]};
G=Tissue[v,e,c];
Centroid[G,1]
];
TissueCentroid[g_DTissue]:= TissueCentroid[DTissue2Tissue[g]]; 
TissueCentroid[x___]:= (Print["Unexpected Input for TissueCentroid[]"]; {Indeterminate, Indeterminate})


(* ::Input::Initialization:: *)
PerimeterFormula[T_Tissue,j_, edgeVariable_]:= Module[{c},
c=TissueCells[T][[j]];
Plus@@(edgeVariable[#][Global`t]&/@c)
]


(* ::Input::Initialization:: *)
perimeterLength[{points__?PointQ}]:=Module[{pts,c},pts=Partition[{points},2,1,1];
c=distance@@#&/@pts;
Return[Plus@@c]];
perimeterLength[points__?PointQ]:= perimeterLength[{points}]; 
perimeterLength[tissue_?TissueQ, i_]:= perimeterLength[CellVertexCoordinates[tissue,i]]; 
perimeterLength[tissue_?DTissueQ, i_]:= perimeterLength[CellVertexCoordinates[tissue,i]]; 


perimeterLength[tissue_?TissueQ]:= perimeterLength/@CellVertexCoordinates[tissue]; 
perimeterLength[tissue_?DTissueQ]:= perimeterLength[DTissue2Tissue[tissue]];
perimeterLength[x___]:= (Print["Error: Expecting perimeterLength[Point1, Point2, ...] or \nperimeterLength[tissue] or \nperimeterLength[tissue, i]"]; $Failed); 


(* ::Input::Initialization:: *)
IsoPerimetricRatio[{points__?PointQ}]:= Module[{P},
P={points};  
4Pi areafunction[P]/(perimeterLength[P]^2)];
IsoPerimetricRatio[T_?TissueQ, n_]:= Module[{cell},
cell=CellVertexCoordinates[T,n];
IsoPerimetricRatio[cell]
]; 
IsoPerimetricRatio[DT_?DTissueQ, n_]:= Module[{cell},
cell=CellVertexCoordinates[DT,n];
IsoPerimetricRatio[cell]
]; 

IsoPerimetricRatio[T_?TissueQ]:= IsoPerimetricRatio/@CellVertexCoordinates[T]; 

IsoPerimetricRatio[P_?PointList3DQ]:= 4Pi*areafunction[P]/(perimeterLength[P]^2);

IsoPerimetricRatio[x___]:= (Print["Expecting IsoPerimetricRatio[{points}]"]; Abort[]); 


(* ::Input::Initialization:: *)
Inside[{vertices__?PointQ},point_?PointQ]:=Module[{i,j,c,n,xp,yp,x, y,  points},

points={vertices}; 

{x,y}=point; (*from http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/*)xp[k_]:=points[[k,1]];
yp[k_]:=points[[k,2]];
c=False;
n=Length[points];
For[i=1;j=n;,i<=n,j=i++,If[(((yp[i]<=y)&&(y<yp[j]))||((yp[j]<=y)&&(y<yp[i])))&&(x<(xp[j]-xp[i])*(y-yp[i])/(yp[j]-yp[i])+xp[i]),c=\[Not]c]];
Return[c];];

Inside[T_Tissue, cell_?IntegerQ, point_?PointQ]:=Module[{cvc},
AbortIf[cell<1, "Inside: Invalid Cell Number: "<>ToString[cell]]; 
AbortIf[cell>NTissueCells[T],
"Inside: Invalid Cell Number: "<>ToString[cell]]; 
cvc=CellVertexCoordinates[T,cell]; 
Inside[cvc, point]
];

Inside[DT_DTissue, cell_?IntegerQ, point_?PointQ]:= Module[{cvc, cn},
cn=First/@TissueCells[DT];
AbortIf[Not[MemberQ[cn,cell]],
"Inside: Invalid Cell Number: "<>ToString[cell]]; 
cvc=CellVertexCoordinates[DT,cell]; 
Inside[cvc, point]
]

Inside[x___]:= (Print["Error: Expecting Inside[{v1, v2, ...}, point]"]; $Failed;);


(* ::Input::Initialization:: *)
OutsideBox[{objectVertices__?numPairQ}, {boxVertices__?numPairQ}]:= Module[{vertexOutside, outside},
vertexOutside[{x_, y_}]:= !Inside[{boxVertices}, {x,y}]; 
outside = vertexOutside/@{objectVertices};
outside=And@@outside;
Return[outside];
]


(* ::Input::Initialization:: *)
PrimaryAxes[{vertices__?PointQ}, opt___?OptionQ]:=Module[{M,evalues,relativeEigenvalues,evectors,norms,centroid,arrows,g,angles,V, dbg, dPrint, listOfVertices, eigenvalues},

dbg= "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["PrimaryAxes: ", x]]; 

listOfVertices={vertices}; 
dPrint["list of vertices: ", listOfVertices]; 

centroid=Centroid[listOfVertices];
dPrint["centroid: ", centroid]; 

V=(#-centroid)&/@listOfVertices;
M=Transpose[V].V;
eigenvalues=Eigenvalues[M];
evalues=Sqrt/@eigenvalues;
(*find "relative" eigenvalues*)relativeEigenvalues=evalues/Norm[evalues];
(*find eigenvectors and normalize relative to the magnitudes of the eigenvalaues*)evectors=Eigenvectors[M];
norms=Norm/@evectors;
evectors=evectors/norms;
evectors=evectors*relativeEigenvalues;
angles=ArcTan@@#&/@evectors;
(*convert eigenvectors to graphical arrows& vectors from the centroid*)evectors={centroid,centroid+#}&/@evectors;
arrows=Arrow/@evectors;
g=Graphics[{Line[Append[listOfVertices,listOfVertices[[1]]]],

PointSize["PointSize"/.{opt}/.{"PointSize"-> .02}], 
"PointColor"/.{opt}/.{"PointColor"-> Red}, 
Point[centroid],
"Color"/.{opt}/.{"Color"-> Blue},arrows}];
Return[{"Vectors"->evectors,"Graphics"->g,"Eigenvalues"->relativeEigenvalues,"Angles"->angles}]
];
PrimaryAxes[tiss_?TissueQ, {i__?IntegerQ}, opt___?OptionQ]:= Module[{cvc, pa},
cvc=CellVertexCoordinates[tiss][[{i}]]; 
pa=PrimaryAxes[#, opt]&/@cvc; 
Return[pa]; 
];
PrimaryAxes[tiss_?TissueQ, i_?IntegerQ, opt___?OptionQ]:= PrimaryAxes[tiss, {i}, opt][[1]]; 
PrimaryAxes[tiss_?TissueQ, opt___?OptionQ]:= PrimaryAxes[tiss, Range[NTissueCells[tiss]], opt];


(* ::Input::Initialization:: *)
PrimaryAxesVectors[{vertices__?NumericPointQ}, opt___?OptionQ]:= Module[{pa, evectors, evalues},
pa=PrimaryAxes[{vertices}]; 
evectors = "Vectors"/.pa;
evalues = "Eigenvalues"/.pa;
pa = Transpose[{evalues, evectors}]; 
pa = Sort[pa];
pa = Last/@pa; 
Return[pa];
];
PrimaryAxesVectors[tiss_?TissueQ, {i__?IntegerQ}, opt___?OptionQ]:= Module[{cvc, pa},
cvc = CellVertexCoordinates[tiss][[{i}]]; 
pa = PrimaryAxesVectors[#,opt]&/@cvc; 
Return[pa]; 
];
PrimaryAxesVectors[tiss_?TissueQ, i_?IntegerQ, opt___?OptionQ]:= PrimaryAxesVectors[tiss, {i}, opt][[1]]; 
PrimaryAxesVectors[tiss_?TissueQ, opt___?OptionQ]:= PrimaryAxesVectors[tiss, Range[NTissueCells[tiss]], opt]; 


(* ::Input::Initialization:: *)
FitEllipse[V_]:=Module[{axes,V1,V2,\[Lambda]1,\[Lambda]2,K,axis1,axis2,A,Centroid,\[Theta]1,\[Theta]2,g},
axes=PrimaryAxes[V];
{V1,V2}="Vectors"/.axes;
{\[Lambda]1,\[Lambda]2}="Eigenvalues"/.axes;
K=\[Lambda]1/\[Lambda]2;
A=areafunction[V];
axis2=Sqrt[A/(\[Pi]*K)];
axis1=K*axis2;
Centroid=V1[[1]];
{\[Theta]1,\[Theta]2}="Angles"/.axes;
g="Graphics"/.axes;
g=Show[g,Graphics[{Purple,Rotate[Circle[Centroid,{axis1,axis2}],\[Theta]1]}]];
Return[{"Angle"->\[Theta]1,"Axes"->{axis1,axis2},"Graphics"->g}];]


(* ::Input::Initialization:: *)
LineEdgeIntersection[edge_?CZEdgeQ,point_?PointQ,direction_?PointQ]:=Module[{vedge,\[CapitalDelta]y,\[CapitalDelta]x,A,Ainv,b,x,y, p1, p2, xc, yc, v1, v2, x1, y1, x2, y2,dbg=False, dPrint,VERYSMALL,NotSoSmall,dot},
VERYSMALL[u_]:= Abs[u]<10^(-10); 
NotSoSmall[u_]:= Not[VERYSMALL[u]]; 

dPrint[u___]:= If[dbg, Print["LineEdgeIntersection: ", u]]; 

{p1, p2}=edge; 
{x1, y1} =p1; 
dPrint["p1(x1,y1)=", p1]; 
{x2, y2}=p2;
dPrint["p2(x2,y2)=", p2]; 


{xc, yc} = point;  
dPrint["point(xc,yc)=", point]; 
{v1, v2}=Normalize[direction]; 

dPrint["direction (v1,v2):", {v1,v2}]; 

\[CapitalDelta]x=x2-x1;
\[CapitalDelta]y=y2-y1;
vedge=Normalize[{\[CapitalDelta]x,\[CapitalDelta]y}];
{\[CapitalDelta]x,\[CapitalDelta]y}=vedge;
dPrint["vedge {\[CapitalDelta]x,\[CapitalDelta]y}=", vedge]; 

(*both parallel*)
If[\[CapitalDelta]y v1==\[CapitalDelta]x v2,Return[$Failed]];
dot = 1.0-Abs[{v1,v2}.{\[CapitalDelta]x,\[CapitalDelta]y}]; dPrint["**** dot = ", dot]; 
If[VERYSMALL[dot], Return[$Failed]]; 
If[VERYSMALL[\[CapitalDelta]x] \[And] VERYSMALL[v1], Return[$Failed]]; 
If[VERYSMALL[\[CapitalDelta]x],
x=x1;
y = yc + (v2/v1)*(x1-xc)];
If[VERYSMALL[v1],
x=xc; 
y=y1+(\[CapitalDelta]y/\[CapitalDelta]x)*(xc-x1);
];
If[NotSoSmall[\[CapitalDelta]x] \[And] NotSoSmall[v1], 
A={{v2,-v1},{\[CapitalDelta]y,-\[CapitalDelta]x}};
dPrint["A: ", MatrixForm[A]]; 
Ainv=Inverse[A];
dPrint["Ainv:", Ainv//MatrixForm]; 
b={v2 xc-v1 yc,x1 \[CapitalDelta]y-y1 \[CapitalDelta]x};
{x,y}=Ainv.b;
]; 
(*we could use the worked-
out formula but its not as pretty:*)

(*{(v2 (-x1+x2) xc+v1 (x2 (y1-yc)+x1 (-y2+yc)))/(v2 (-x1+x2)+v1 (y1-y2)),(v2 (x2 y1-xc y1-x1 y2+xc y2)+v1 (y1-y2) yc)/(v2 (-x1+x2)+v1 (y1-y2))}*)

(*check to make sure the intersection is within the edge*)

If[x<Min[x1,x2],Return[$Failed]];
If[x>Max[x1,x2],Return[$Failed]];
If[y<Min[y1,y2],Return[$Failed]];
If[y>Max[y1,y2],Return[$Failed]];
Return[{x,y}]];
LineEdgeIntersection[x___]:=(Print["Error: Expecting LineEdgeIntersection[edge, point, direction]: ", {x}]; $Failed);


(* ::Input::Initialization:: *)
DropPerpendicular[point_?PointQ, edge_?CZEdgeQ, slide_:False]:= Module[{perp, intersection, d1, d2},

If[distance@@edge==0, Print["Error: DropPerpendicular: Edge ", edge, " has zero length."]; Return[$Failed]]; 
perp=edge[[2]]-edge[[1]]; 
perp = {-perp[[2]], perp[[1]]}; 
perp =perp/Norm[perp]; 
intersection=LineEdgeIntersection[edge, point, perp]; 

If[DifferentQ[intersection ,$Failed], Return[intersection]]; 

(* The perpendicular missed the edge. Should we slide it to the endpoint? *)
If[!slide, Return[$Failed]]; 

d1 = distance[point, edge[[1]]]; 
d2 = distance[point, edge[[2]]]; 

If[d1 <= d2, 
Return[edge[[1]]], 
Return[edge[[2]]]
];  

];
DropPerpendicular[x___]:= (Print["Error: Expecing DropPerpendicular[point, edge, slide]"]; $Failed);


(* ::Input::Initialization:: *)
DropLineToNearestPointOnEdge[point_?PointQ, edge_?CZEdgeQ]:= DropPerpendicular[point, edge, True];


(* ::Input::Initialization:: *)
PolygonIntersection[vector_?PointQ,{vertex__?PointQ}]:=Module[{nv,centroid,edges,debug=False,int,range,v, ok},nv=Length[{vertex}];
If[nv<3,Print["eh? polygonIntersect: expecting more than ",nv," vertices. Vector: ",vector," vertices: ",{vertex}];
Return[$Failed];];
centroid=Centroid[{vertex}];
Return[
PolygonIntersection[{centroid, centroid+vector}, {vertex}]
];
 
]


(* ::Input::Initialization:: *)
PolygonIntersection[{p1_?PointQ, p2_?PointQ},{vertex__?PointQ}]:=Module[{nv,edges,vector, debug=False,int,range,v,ok, toomany, dPrint},
dPrint[x___]:= If[debug, Print["PolygonIntersection: ", x]]; 
nv=Length[{vertex}];
If[nv<3,Print["eh? polygonIntersect: expecting more than ",nv," vertices. Vector: ",vector," vertices: ",{vertex}];
Return[$Failed];];
edges=Partition[{vertex},2,1,1];
vector=Subtract@@{p1,p2};
int=LineEdgeIntersection[#,p1,vector]&/@edges;

dPrint["polygonIntersect[",vector,{vertex},"]"];
dPrint["p1,p2,vector: ",{p1,p2,vector}];
dPrint["edges: ",edges];
dPrint["intersectons: ",int];

range=Range[nv];
ok=(ToString[#]!="$Failed")&/@int;
int=Pick[Transpose[{range,int}],ok];
nv=Length[int];
dPrint["Edge ",#[[1]]," intersection at ",#[[2]]]&/@int;
(* 2 intersections is normal; 3 or 4 means it occurs at existing vertices *)


toomany=False; 
Which[
nv==0,
Print["Warning: PolygonIntersect: no intersections."];
Print["Points,vector: ", {p1,p2,vector}];
Print["Vertices: ", {vertex}]; 
,

nv==1,
Print["Warning: PolygonIntersect: only 1 intersection: ",int],

nv>2,
dPrint["Warning: PolygonIntersect: too many intersections = ",int];
toomany=True; 

];

If[toomany,
Block[{pts, pos, i, j, points}, 
dPrint["Handling too many intersections."]; 
pts = Last/@int;

(* Fix in the case of non-convex cell *)
(* Also works if the intersections fall on a vertex! *)

If[pts[[1,1]]==pts[[1,2]],
(* vertical line *)
pts = Reverse/@Sort[Reverse/@Append[pts, p1]],
(* not a vertical line - can sort by x coordinate *)
pts = Sort[Append[pts,p1]];
]; 
pos = Position[pts, p1][[1,1]]; 
If[pos==1 \[Or] pos==Length[pts], 
Print["Error: Point p1 ", p1," is not an interior point. "];
If[pos==1,
i = pos+1; j = pos + 2,
i = pos-2; j = pos -1; 
], 
i = pos-1; j = pos + 1;
];
dPrint["p1: ", p1, " pos: ", pos, " i, j: ", i,",", j]; 
dPrint["pts: ", pts]; 
(* Extract Proper Points *)
i=pts[[i]]; j = pts[[j]]; 
i=int[[Position[int, i][[1,1]]]]; 
j = int[[Position[int, j][[1,1]]]]; 

dPrint["{i,j}:", {i,j}]; 
int = Sort[{i,j}]; 
]; 
]; 

Return[int];

]

PolygonIntersection[x___]:= (Print["Error: Expecting PolygonIntersection[{point1, point2}, {vertices}] or PolygonIntersection[DirectionVector, {vertices}]"]; $Failed); 


(* ::Input::Initialization:: *)
NormalVector[{p1_, p2_}]:= NormalVector[{p1,p2}, 1]; 
NormalVector[{p__?PointQ}, i_Integer]:= Module[{v, e, vec},
v=Append[{p}, First[{p}]];
(* edge vector *)
e={v[[i]], v[[i+1]]};
vec=Vector@@e;
(* normal vector *)
vec = {-vec[[2]], vec[[1]]};
vec = vec/Norm[vec]
];
NormalVector[x___]:= (Print["Expecting NormalVector[{vertex, vertex, ...}, index]."]; $Failed); 



(* ::Input::Initialization:: *)
OutwardNormalVector[{pt__?PointQ}]:= OutwardNormalVector[{pt}, 0]; 
OutwardNormalVector[{pt__?PointQ}, j_Integer]:= Module[
{v, OutwardNormal}, 
v=Append[{pt}, First[{pt}]];

OutwardNormal[ i_Integer]:= Module[{ e, vec, origin, epsilon, point},
(* edge vector *)
If[i>= Length[v], Print["Error: OutwardNormalVector: edge ", i, " does not exist: points=", {pt}]; Return[$Failed]]; 

e={v[[i]], v[[i+1]]};
vec=Vector@@e;
(* normal vector *)
vec = {-vec[[2]], vec[[1]]};
vec = vec/Norm[vec];
origin = Mean[e]; 
epsilon=0.01*Norm[e]; 
point=origin+vec*epsilon; 
If[Inside[{pt}, point] , Return[-vec], Return[vec]]; 
];

If[j>0, 
Return[OutwardNormal[j]],
Return[OutwardNormal/@Range[Length[{pt}]]]
];
Print["OutwardNormalVector: Program Error: ", {pt, j}]; 
]; 


OutwardNormalVector[tissue_?TissueQ]:= OutwardNormalVector[tissue, 0, 0]; 
OutwardNormalVector[tissue_?TissueQ, cellNum_]:= OutwardNormalVector[tissue, cellNum, 0]; 
OutwardNormalVector[tissue_?TissueQ, cellNumber_Integer, edgeNumber_Integer]:= Module[{p, nv},
If[cellNumber>0, 
(* single cell *)
p=CellVertexCoordinates[tissue, cellNumber];
Return[OutwardNormalVector[p, edgeNumber]]; 
,
(* all cells *)
(* ignore edge number in this case *)
p=CellVertexCoordinates[tissue];
(* set edgenumber to zero to force all edges *)
nv = OutwardNormalVector[#, 0]&/@p;
Return[nv]; 
];
Print["Error: Outward Normal Vector: Program Error: ", {tissue, cellNumber, edgeNumber}]; 
Return[$Failed]; 
];

OutwardNormalVector[x___]:= (Print["Error; Expecting OutwardNormalVector[{p1,p2,...}, index:0] or OutwardNormalVector[Tissue, cellNumber:0, edgeNumber:0] (0 means all)"]; Return[$Failed]); 


(* ::Input::Initialization:: *)
MidPoint[p1_?PointQ, p2_?PointQ]:= Mean[{p1,p2}];
MidPoint[{p1_?PointQ, p2_?PointQ}]:= Mean[{p1,p2}]; 
MidPoint[{p1_?PointQ, p2_?PointQ, p3__?PointQ}]:=MidPoint[{p1,p2, p3}, 0]; 
MidPoint[{p1_?PointQ, p2_?PointQ, p3__?PointQ}, i_Integer]:= Module[{v, mp},
v={p1,p2, p3, p1};
If[i>= Length[v], Print["Error: Midpoint: edge ", i, " does not exist in polygon ", v]; Return[$Failed]];  
If[i>0,
mp=MidPoint[v[[i]], v[[i+1]]];
, 
v= Partition[v, 2, 1]; 
mp = MidPoint/@v;
];
Return[mp];
];
MidPoint[tissue_?TissueQ, cellNumber_Integer]:= MidPoint[tissue, cellNumber, 0]; 
MidPoint[tissue_?TissueQ]:= MidPoint[tissue, 0, 0]; 
MidPoint[tissue_?TissueQ, cellNumber_Integer, edgeNumber_Integer]:= Module[{v, mp},
If[cellNumber>0, 
v=CellVertexCoordinates[tissue, cellNumber];
mp=MidPoint[v, edgeNumber];
,
v=CellVertexCoordinates[tissue]; 
mp=MidPoint/@v;
]; 
Return[mp];
]; 


(* ::Input::Initialization:: *)
PartitionPolygon[points_?ListQ,n_]:=Module[{input,perimeter,DL,PartitionSegment,segments,partitioning,distances,short},input=Append[points,First[points]];
perimeter=perimeterLength[points];
DL=perimeter/(1.0*n);
PartitionSegment[p1_,p2_,DL_]:=Module[{d,m},d=distance[p1,p2];
m=Round[0.5+(d/DL)];
Table[p1+1.0*j*(p2-p1)/m,{j,0,m}]];
segments=Partition[input,2,1];
partitioning=Flatten[PartitionSegment[#[[1]],#[[2]],DL]&/@segments,1];
distances=distance@@#&/@Partition[partitioning,2,1,1];
short=(#<0.1*DL)&/@distances;
partitioning=Pick[partitioning,Not/@short]
]


(* ::Input::Initialization:: *)
RadialPolygon[inputdata_?ListQ,n_,order_:1]:= Module[{p,c,pts,thetas,rs, data,lastpoint, firstpoint,r,points},
points = inputdata;
If[First[points]==Last[points], points=Most[points]]; 
c=Centroid[points]; 
pts = (#-c)&/@points;
p=PartitionPolygon[pts,n];
thetas = ArcTan@@#&/@p; 
thetas = If[#<0,#+2Pi,#]&/@thetas;
rs = Norm/@p;
(* sort data by angle *) 
data = Transpose[{thetas,rs}]; 
data=Sort[data];
(* copy end points at 0 and 2Pi to ensure full coverage *)
lastpoint = Last[data]; lastpoint = {lastpoint[[1]]-2Pi,lastpoint[[2]]}; 
firstpoint = First[data]; firstpoint = {firstpoint[[1]]+2Pi, firstpoint[[2]]}; 
data = Append[ Prepend[data, lastpoint],firstpoint];
(* Now make it periodic on [0,2Pi] *)
r=Interpolation[data,InterpolationOrder-> order]; 
data = Table[{2.0*Pi*i/n,r[2.0*Pi*i/n]},{i,0,n}];
r=Interpolation[data,InterpolationOrder-> order, PeriodicInterpolation-> True]
]


(* ::Input::Initialization:: *)
AngularPerimeterFunction[points_,n_:100]:= Module[{ptab,pfunc},
ptab = AngularPerimeterInterpolationTable[points,n]; 
pfunc=Interpolation[ptab]; 
Return[pfunc]
];
AngularPerimeterInterpolationTable[points_,n_:100]:= Module[{r,integrand, itab, i, perimeter,ptab,data},
data = points;
If[First[data]==Last[data], data = Most[data]]; 
r=RadialPolygon[data,n]; 
integrand[t_]:=Sqrt[r[t]^2+r'[t]^2];
itab=Table[{t,integrand[t]},{t,0,2 Pi,2.0 Pi/n}];
i=Interpolation[itab];
perimeter[t_]:=Integrate[i[s],{s,0,t}];
ptab=Table[{t,perimeter[t]},{t,0,2 Pi,2.0 Pi/n}];

Return[ptab]
];
EquiperimeterPoints[points_, n_ ]:= Module[{ptab,i, p,perimeter,delta, distances, angles, r, radii, P2R, C},
C=Centroid[points]; 
P2R[r_,theta_]:=C+ {r*Cos[theta], r*Sin[theta]}; 
ptab = AngularPerimeterInterpolationTable[points,100]; 
p=Interpolation[ptab]; 
ptab = Reverse/@ptab;
i = Interpolation[ptab];
perimeter = p[2 Pi]; 
delta = perimeter/n; 
distances = delta*Range[0,n-1];
angles = i/@distances;
r = RadialPolygon[points,100]; 
radii = r/@angles;
MapThread[P2R, {radii, angles}]
]


(* ::Input::Initialization:: *)
Point2DQ[{x_,y_}]:= True;
Point2DQ[x___]:= False;

Point3DQ[{x_,y_,z_}]:= True;
Point3DQ[x___]:= False; 

PointList3DQ[{v___?Point3DQ}]:=True; 
PointList3DQ[x___]:= False;


(* ::Input::Initialization:: *)
perimeterLength[p_?PointList3DQ]:= Module[{pointPairs,segments,lengths},
If[Length[p]<2, Return[0]]; 
pointPairs=Partition[p,2,1,1];
segments = Subtract@@#&/@pointPairs;
lengths = Norm/@segments;
Return[Plus@@lengths]
]


(* ::Input::Initialization:: *)
Centeroid[p_?PointList3DQ]:= If[Length[p]<1, Return[{0,0,0}], Mean[p]]; 
Centroid[p_?PointList3DQ]:= Centeroid[p]; 


(* ::Input::Initialization:: *)
Hero[a_,b_,c_]:= Module[{s,A},
s=(a+b+c)/2;
A=Sqrt[s(s-a)(s-b)(s-c)]; 
Return[Abs[A]]
];
Hero1[p_?Point3DQ, q_?Point3DQ,r_?Point3DQ]:= Module[{sides},
sides=Norm/@(Subtract@@#&/@Partition[{p,q,r},2,1,1]);
Hero@@sides
];
Hero1[{p_?Point3DQ, q_?Point3DQ,r_?Point3DQ}]:= Hero1[p,q,r];
Hero2[r1_, r2_, theta_]:= Module[{c,  teeny=.0001},
c=r1*r1+r2*r2-2r1*r2*Cos[theta];
c=Max[c,0.0];
c=Sqrt[c];
If[c<teeny,Return[0.0]];
Hero[r1,r2,c]
]


(* ::Input::Initialization:: *)
AreaTriangle[p_?Point3DQ, q_?Point3DQ,r_?Point3DQ]:= Hero1[p,q,r]; 
AreaTriangle[p_?Point2DQ, q_?Point2DQ, r_?Point2DQ]:= AreaTriangle[Append[p,0],Append[q,0], Append[r,0]];
AreaTriangle[{p_?Point3DQ, q_?Point3DQ,r_?Point3DQ}]:= AreaTriangle[p,q,r];
AreaTriangle[{p_?Point2DQ, q_?Point2DQ, r_?Point2DQ}]:= AreaTriangle[p,q,r]; 
AreaTriangle[x___]:= (Print["Expecting AreaTriangle[point,point,point], not: ", x]; Abort[]); 


(* ::Input::Initialization:: *)
AltitudeTriangle[a_,b_,c_]:= Module[{s},
Abs[Hero[a,b,c]*2/a]
];
AltitudeTriangle1[r1_, r2_, theta_]:= Module[{a,a2, teeny=.0001},
a2=r1*r1+r2*r2-2r1*r2*Cos[theta];
a2=Max[a2,0.0];
a=Sqrt[a2];
If[a<teeny,Return[r1]];
AltitudeTriangle[a,r1,r2]
]


(* ::Input::Initialization:: *)
PolygonArea[p_]:= Module[{center, triangles, pairs, areas,area},
If[Length[p]<3, Return[0]]; 

center = Centeroid[p]; 
triangles = Partition[p,2,1,1];
triangles = Append[#,center]&/@triangles;
areas = AreaTriangle/@triangles;
area = Plus@@areas;
Return[area];
];


(* ::Input::Initialization:: *)
ZProjection[T_?TissueQ]:= Module[{v,e,c},
{v,e,c}=T/.{Tissue-> List}; 
Tissue[Most/@v,e,c]
];


(* ::Input::Initialization:: *)
ShowZProjection[T_?TissueQ,opt___?OptionQ]:= Module[{T1},
T1=ZProjection[T]; 
ShowTissue[T1,opt]
];
ShowZProjection[x___]:= (Print["Expecting ShowZProjection[Tissue,options]"];Abort[]); 


(* ::Input::Initialization:: *)
ShowTissue3D[T_, edgestyle_:Black,cellnumberstyle_:None, edgenumberstyle_:None, xrange_:All, yrange_:All,zrange_:All]:= Module[{v,e,c,ne,edges,cellnumbers,CVC,CC,CellNumbers,EdgeNumbers,edgenumbers,EVC,EC, edgesUsedInCells,edgeInRange,plottableEdges,plottable},
v=TissueVertices[T];
c=TissueCells[T];
e=TissueEdges[T];

(* Make sure to only plot edges that are ACTUALLY USED in cells*)

(*
ne=Length[e]; 
edges=Line[v[[e[[#]]]]]&/@Range[ne];
*)

edgesUsedInCells = Union[Flatten[c]]; 
edges=Line[v[[e[[#]]]]]&/@edgesUsedInCells;

edgeInRange[j_]:= Or@@(IntervalCheck[#,xrange,yrange,zrange]&/@v[[e[[j]]]]); 
plottableEdges =Select[edgesUsedInCells, edgeInRange[#]&];
edges=Line[v[[e[[#]]]]]&/@plottableEdges;

If[SameQ[cellnumberstyle,None], 
CellNumbers=Graphics3D[{}],
cellnumbers=Range[Length[c]];
CVC=CellVertexCoordinates[T];  
CC=Centroid/@CVC;

plottable=IntervalCheck[#,xrange,yrange,zrange]&/@CC;

cellnumbers=Pick[cellnumbers,plottable];
CC=Pick[CC,plottable]; 

CellNumbers=Graphics3D[Prepend[MapThread[Text,{cellnumbers,CC}],cellnumberstyle]];
];

If[SameQ[edgenumberstyle,None],
EdgeNumbers=Graphics3D[{}],

(* edgenumbers=Range[ne]; *)
edgenumbers = edgesUsedInCells; 

edgenumbers=plottableEdges;

EVC=EdgeVertices[T];
EVC=EVC[[edgenumbers]]; 


EC=Centroid/@EVC;
EdgeNumbers=Graphics3D[Prepend[MapThread[Text,{edgenumbers,EC}],edgenumberstyle]]
];

Show[
Graphics3D[{edgestyle, edges}],
CellNumbers,
EdgeNumbers
]
];
ShowTissue3D[x___]:= (Print["Expecting ShowTissue3D[Tissue, Edge-Styles, Cell-Number-Styles:None, Edge-Number-Styles:None"]; Abort[]);


(* ::Input::Initialization:: *)
LambertPlaneToDome[{p_, q_}]:= Module[{x,y,z, r, theta},
(* transform to a dome with the north pole at (0,0,-1) *)
r=p^2+q^2;
If[r <=2, 
x=p Sqrt[1-(r/4)];
y=q Sqrt[1-(r/4)];
z=(r/2)-1;
(* switch south pole to north pole *)
(* z=2-z-2; *) 
z=1-r/2; 
Return[{x,y,z}]
];
(* Need Code Here for r >4/3*)
theta = ArcTan[p, q];
x=Cos[theta];
y=Sin[theta];  
z=1-r/2; 
z=1-Sqrt[r/2];
(* put the point on the edge of the dome *)
z = 0;
Return[{x,y,z}];
]; 
LambertDomeToPlane[{x_, y_,z_}]:= Module[{p,q, r},
r=2/(1-z); 
p=Sqrt[r*x];
q=Sqrt[r*y];
Return[{p,q}]; 
]


(* ::Input::Initialization:: *)
ProjectPlaneToParaboloid[{x_,y_}, a_:.01, h_:0,k_:0]:= Module[{r, rp, \[Lambda]},
r=Sqrt[(x-h)^2+(y-k)^2]; 
rp = Sqrt[(1.0+6(a * r)^2)^(2/3)-1]/(2.0*a);
If[Abs[rp]<\[Infinity],\[Lambda]=rp/r,\[Lambda]=1];
Return[{h+x*\[Lambda], k+y*\[Lambda],-a*rp^2}] 
];



(* ::Input::Initialization:: *)
ParaboloidPlot[tissue_?TissueQ,r_?NumberQ, a_?NumberQ, h_?NumberQ, k_?NumberQ, opt___?OptionQ]:= Module[{},
ShowTissueOnDome[tissue,"shape"-> "Paraboloid", "Radius"-> r, "A"-> a, "h"-> h, "k"-> k, opt] 
];
 ParaboloidPlot[tissue_?TissueQ,opt___?OptionQ]:= Module[{r,a,h,k},
r = "Radius"/.{opt}/.Options[ShowTissueOnDome]; 
a = "A"/.{opt}/.{"A"-> 0.01}; 
h = "h"/.{opt}/.{"h"-> 0}; 
k="k"/.{opt}/.{"k"-> 0}; 
ShowTissueOnDome[tissue,"shape"-> "Paraboloid", "Radius"-> r, "A"-> a, "h"-> h, "k"-> k, opt] 
];


(* ::Input::Initialization:: *)
ShowTissueOnDome[tissue_Tissue, opt___?OptionQ]:=Module[{v,n,vdome, c, cc,scalefactor,r,colors,cg,edges,cells,ToDome, ToParaboloid, cdome, edome, e, eg, radius, a,h,k, shape, eused,smax,EdgeCellLine,edgecellpairs, centroids, u, xmax, zmax, plotrange, gedges, scale, origin,x0,y0, boundary, circle, shapes={"Paraboloid","Hemisphere"}},
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
n=Length[c];
centroids = Centroid[tissue]; 
origin = "Origin"/.{opt}/.{"Origin"-> {0,0}}; 
scale = "ScaleMultiple"/.{opt}/.{"ScaleMultiple"-> 1.1};
{x0,y0}=origin; 

boundary="Boundary"/.{opt}/.{"Boundary"-> False}; 
Which[
MemberQ[{"None", None, "False"}, boundary], boundary=False,
MemberQ[{"Automatic", Automatic, True, "True"}, boundary], boundary=Directive[Thick, Black],
ListQ[boundary], boundary=Directive@@boundary
];

v=TissueVertices[tissue];

cc=Centroid[v[[VerticesOnBoundary[tissue]]]];

radius = "Radius"/.{opt}/.Options[ShowTissueOnDome]; 
a = "A"/.{opt}/.{"A"-> 0.01}; 
h = "h"/.{opt}/.{"h"-> 0}; 
k="k"/.{opt}/.{"k"-> 0}; 

shape = "shape"/.{opt}/.{"shape"-> "Paraboloid"}; 

cells=CellVertexCoordinates[tissue];

plotrange=Automatic; 
Switch[shape,
"Paraboloid",
ToParaboloid[{x_,y_}]:= ProjectPlaneToParaboloid[{x,y},a,h,k]; 
ToParaboloid[listOfPairs_]:= ToParaboloid/@listOfPairs;
cdome=ToParaboloid/@cells;
vdome = ToParaboloid/@v;

smax[u_]:= (a * u * Sqrt[1+4 a^2 u^2]+1/2 ArcSinh[2 * a * u])/(2 * a);
xmax =u/. FindRoot[smax[u]-radius, {u,radius}, AccuracyGoal-> 4, PrecisionGoal-> 4]; 
zmax = a*xmax*xmax;
plotrange = {{x0-scale*xmax,x0+scale*xmax}, {y0-scale*xmax, y0+scale*xmax}, {-zmax, 0}}; 
, 

"Hemisphere", 

v=(#-cc)&/@v;
If[radius>0,
scalefactor=radius,
scalefactor = Max[Norm/@v]
];  

scalefactor=(1/Sqrt[2])*scalefactor;
v=v/(scalefactor);

vdome = scalefactor*LambertPlaneToDome/@v; 
ToDome[{x_,y_}]:=scalefactor*LambertPlaneToDome[({x,y}-cc)/scalefactor];
ToDome[listOfPairs_]:=ToDome/@listOfPairs;

cdome=ToDome/@cells;,

_, Print["Unknown Shape: ", shape, " - allowed shapes are ", shapes]; Abort[];
]; 

colors = "CellStyle"/.{opt}/.{"CellStyle"-> "Automatic"};

Which[
ListQ[colors], 
colors=Flatten[{colors}]; 
If[Length[colors]==1, colors=PadRight[colors, n, First[colors]]]; 
If[Length[colors]<n,  colors=PadRight[colors, n, White]];
If[Length[colors]>n, colors = Take[colors, n]]; 
cg=MapThread[Graphics3D[{#1,Polygon[#2]}]&,{colors,cdome}];
,
colors == "Colorful"
, 
r:=RandomReal[{0,.7}];
colors=Table[Hue[r],{n}] ; 
cg=MapThread[Graphics3D[{#1,Polygon[#2]}]&,{colors,cdome}];
, 
colors== "Automatic"
, 
cg=Graphics3D[Polygon[#]]&/@cdome; 
]; 
cg = Show[cg]; 

eused=EdgesUsed[tissue];
n=Length[eused]; 
colors = "EdgeStyle"/.{opt}/.Options[ShowTissueOnDome];


colors=Flatten[{colors}]; 
If[Length[colors]==1, colors=PadRight[colors, n, First[colors]]]; 
If[Length[colors]<n,  colors=PadRight[colors, n, Black]];
If[Length[colors]>n, colors = Take[colors, n]]; 

edome = Line/@(vdome[[#]]&/@(e[[eused]])); 

(* eg=MapThread[Graphics3D[{#1,#2}]&,{colors,edome}];*)
eg= Show[Graphics3D[Transpose[{colors,edome}]]]; 

edgecellpairs="EdgeCellPairs"/.{opt}/.{"EdgeCellPairs"-> {}}; 

If[Length[edgecellpairs]>0,
edgecellpairs = Select[edgecellpairs,MemberQ[eused,#[[2]]]&]
];
EdgeCellLine[cell_, edge_, style_, offset_:0.02]:= Module[{v1,v2, p1, p2,p1z,p2z,cen},
(* vertex numbers *)
{v1,v2}=e[[edge]]; 
(* vertex coordinates *)
p1=v[[v1]]; 
p2=v[[v2]];
cen = centroids[[cell]]; 
p1 =   p1 + (cen-p1)*offset;
p1z = ProjectPlaneToParaboloid[p1,a,h,k];
p2 = p2 + (cen-p2)*offset;
p2z = ProjectPlaneToParaboloid[p2,a,h,k];


Graphics3D[{Directive[style],
Line[{ p1z ,p2z}]}]
];


If[Length[edgecellpairs]>0,
gedges = Show[MapThread[EdgeCellLine,Transpose[edgecellpairs]]];
, 
gedges=Graphics3D[{}]; 
]; 

If[SameQ[boundary,False],
circle=Graphics3D[{}];, 
 
circle=(xmax*scale*{Cos[#],Sin[#]})&/@Range[0,2 Pi,2 Pi/100.];
circle = ProjectPlaneToParaboloid[#,a,h,h]&/@circle;
circle = {#[[1]],#[[2]],#[[3]]}&/@circle; 
 
circle = Graphics3D[{boundary, Line[circle]}]; 

]; 


(*Print[With[{gopt=MyFilterOptions[Graphics3D,opt]}, 
Show[{circle, cg,eg,gedges},   gopt]]]; *)

With[{gopt=MyFilterOptions[Graphics3D,opt]}, 
Return[Show[{ circle, cg,eg, gedges}, gopt, PlotRange-> plotrange]]
]
]



(* ::Input::Initialization:: *)
TissueQ[object_]:=TissueCheck[object, "Quiet"-> True]; 


(* ::Input::Initialization:: *)
TissueOrTorusQ[object_]:= Or[TissueQ[object], TorusQ[object]]


(* ::Input::Initialization:: *)
TissueCells[tissue_?TissueQ]:=argument[tissue][[3]]; 
TissueCells[torus_?TorusQ]:= TissueCells[TorusTissue[torus]]; 
TissueCells[tissue_?DTissueQ]:= argument[tissue][[3]]; 

TissueVertices[tissue_?TissueQ]:= argument[tissue][[1]]; 
TissueVertices[torus_?TorusQ]:= TissueVertices[TorusTissue[torus]]; 
TissueVertices[tissue_?DTissueQ]:= TissueVertices[DTissue2Tissue[tissue]]; 


TissueEdges[tissue_?TissueQ]:= argument[tissue][[2]]; 
TissueEdges[torus_?TorusQ]:= TissueEdges[TorusTissue[torus]]; 
TissueEdges[tissue_?DTissueQ]:= TissueEdges[DTissue2Tissue[tissue]]; 

NTissueCells[tissue_?TissueQ]:= Length[TissueCells[tissue]]; 
NTissueCells[torus_?TorusQ]:= NTissueCells[TorusTissue[torus]]; 
NTissueCells[tissue_?DTissueQ]:= NTissueCells[DTissue2Tissue[tissue]]; 

NTissueVertices[tissue_?TissueQ]:= Length[TissueVertices[tissue]];
NTissueVertices[torus_?TorusQ]:= NTissueVertices[TorusTissue[torus]]; 
NTissueVertices[tissue_?DTissueQ]:= NTissueVertices[DTissue2Tissue[tissue]]; 

NTissueEdges[tissue_?TissueQ]:= Length[TissueEdges[tissue]]; 
NTissueEdges[torus_?TorusQ]:= NTissueEdges[TorusTissue[torus]]; 
NTissueEdges[tissue_?DTissueQ]:= NTissueEdges[DTissue2Tissue[tissue]]; 



(* ::Input::Initialization:: *)
AdjacentVertices[g_Tissue,i_?IntegerQ]:= Module[{e,vb},
e=TissueEdges[g];
Complement[Union[Flatten[Select[e, MemberQ[#,i]&]]],{i}]
];
AdjacentVertices[x___]:= (Print["Expecting AdjacentVertices[Tisue, integer]"]; Abort[]); 


(* ::Input::Initialization:: *)
AdjacentBoundaryVertices[g_Tissue,i_?IntegerQ]:= Module[{e,vb,adj, bv},
e=TissueEdges[g];
bv =VerticesOnBoundary[g]; 
adj=Complement[Union[Flatten[Select[e, MemberQ[#,i]&]]],{i}];
Intersection[adj,bv]
];
AdjacentBoundaryVertices[x___]:= (Print["Expecting AdjacentBoundaryVertices[Tisue, integer]"]; Abort[]); 


(* ::Input::Initialization:: *)
CellOutwardVector[T_Tissue, cell_?IntegerQ, vertex_?IntegerQ]:= Module[{cvn, c, v, vec},
c=Centroid[T, cell]; 
cvn = CellVertexNumbers[T, cell];

AbortIf[Not[MemberQ[cvn,vertex]], "CellOutwardVector: Vertex "<>ToString[vertex]<>" is not part of Cell "<>ToString[cell]]; 

v=TissueVertices[T][[vertex]]; 

vec = Normalize[v-c]

]


(* ::Input::Initialization:: *)
OutwardVector[xyall_, xy_]:= Module[{c,vec},
c=Centroid[xyall];
Return[Normalize[xy-c]]
];


(* ::Input::Initialization:: *)
VertexOutwardVector[tis_Tissue, i_, mean_:False]:= Module[{bv,abv,v,P,edges,nvs,center,vc,cvn,whichcells},bv=VerticesOnBoundary[tis];
If[!MemberQ[bv,i],Return[{}]];
cvn=CellVertexNumbers[tis];
whichcells=First/@Position[cvn,i];
v=CellOutwardVector[tis,#,i]&/@whichcells;
If[mean,v=Mean[v]];
Return[v]
]; 

VertexOutwardVector[T_DTissue, x___] := VertexOutwardVector[DTissue2Tissue[T], x]; 

VertexOutwardVector[x___]:= (Print["Expecting VertexOutwardVector[tissue, integer]"]; Abort[]); 


(* ::Input::Initialization:: *)


VerticesOnDirectional[q_Tissue, {dx_,dy_}]:= 
Module[{cob,cvc,cvn,ISB,PB,vobq,i,v,vall,cellNumber,xy,xys,OK,dPrint,dbg=False,BV},dPrint[x___]:=If[dbg,Print[x]];
ISB[xys_,xy_]:=(OutwardVector[xys,xy].{dx,dy})>0;
PB[xys_,nums_]:=Pick[nums,ISB[xys,#]&/@xys];
vall=TissueVertices[q];
vobq=VerticesOnBoundary[q];
cvn=CellVertexNumbers[q];
cob=CellsOnBoundary[q];
cvc=CellVertexCoordinates[q];
BV={};
For[i=1,i<=Length[vobq],i++,v=vobq[[i]];
cellNumber=Intersection[cob,First/@Position[cvn,v]];
xys=cvc[[cellNumber]];
xy=vall[[v]];
OK=ISB[#,xy]&/@xys;
OK=And@@OK;
dPrint["vertex ",v," is ",cellNumber," xy = ",xy," xys = ",xys," OK = ",OK];
If[OK,AppendTo[BV,v]];];
Return[BV];
]; 

VerticesOnBottom[q_Tissue]:=VerticesOnDirectional[q, {0, -1.0}];
VerticesOnRight[q_Tissue]:=VerticesOnDirectional[q, {1.0, 0.0}]; VerticesOnTop[q_Tissue]:=VerticesOnDirectional[q, {0, 1.0}];
VerticesOnLeft[q_Tissue]:=VerticesOnDirectional[q, {-1.0, 0.0}]; 


VerticesOnTop[w_DTissue]:= VerticesOnTop[DTissue2Tissue[w]];
VerticesOnBottom[w_DTissue]:= VerticesOnBottom[DTissue2Tissue[w]];
VerticesOnLeft[w_DTissue]:= VerticesOnLeft[DTissue2Tissue[w]];
VerticesOnRight[w_DTissue]:= VerticesOnRight[DTissue2Tissue[w]];



(* ::Input::Initialization:: *)
EdgesOnLeft[w_Tissue]:=Module[{e,cb,vb,el,uel},e=TissueEdges[w];
cb=CellsOnBoundary[w];
vb=VerticesOnLeft[w];
el=Position[e,#]&/@vb;
el=Flatten[First/@Transpose/@el];(*edge numbers that touch LHS*)uel=Union[el];(*unique edge numbers*)(*select only edge numbers that have two vertices on the LHS*)Select[uel,Count[el,#]>1&]];

EdgesOnRight[w_Tissue]:=Module[{e,cb,vb,el,uel},e=TissueEdges[w];
cb=CellsOnBoundary[w];
vb=VerticesOnRight[w];
el=Position[e,#]&/@vb;
el=Flatten[First/@Transpose/@el];(*edge numbers that touch LHS*)uel=Union[el];(*unique edge numbers*)(*select only edge numbers that have two vertices on the LHS*)Select[uel,Count[el,#]>1&]];

EdgesOnTop[w_Tissue]:=Module[{e,cb,vb,el,uel},e=TissueEdges[w];
cb=CellsOnBoundary[w];
vb=VerticesOnTop[w];
el=Position[e,#]&/@vb;
el=Flatten[First/@Transpose/@el];(*edge numbers that touch LHS*)uel=Union[el];(*unique edge numbers*)(*select only edge numbers that have two vertices on the LHS*)Select[uel,Count[el,#]>1&]];

EdgesOnBottom[w_Tissue]:=Module[{e,cb,vb,el,uel},e=TissueEdges[w];
cb=CellsOnBoundary[w];
vb=VerticesOnBottom[w];
el=Position[e,#]&/@vb;
el=Flatten[First/@Transpose/@el];(*edge numbers that touch LHS*)uel=Union[el];(*unique edge numbers*)(*select only edge numbers that have two vertices on the LHS*)Select[uel,Count[el,#]>1&]];


EdgesOnTop[w_DTissue]:= EdgesOnTop[DTissue2Tissue[w]];
EdgesOnBottom[w_DTissue]:= EdgesOnLeft[DTissue2Tissue[w]];
EdgesOnLeft[w_DTissue]:= EdgesOnBottom[DTissue2Tissue[w]];
{
 {EdgesOnRight[w_DTissue]:= EdgesOnRight[DTissue2Tissue[w]];},
 {
  }
}


(* ::Input::Initialization:: *)
StaticToDynamicNumberRules[DT_DTissue]:= Module[{cn,nc,s2d},
cn=First/@TissueCells[DT]; 
nc = Range[Length[cn]]; 
s2d = MapThread[Rule,{nc,cn}]
]


(* ::Input::Initialization:: *)
CellsOnLeft[w_Tissue]:=Module[{cb,el,c,cl},cb=CellsOnBoundary[w];
el=EdgesOnLeft[w];
c=TissueCells[w];
cl=Union[First/@First/@(Position[c,#]&/@el)]];
CellsOnLeft[w_DTissue]:= CellsOnLeft[DTissue2Tissue[w]/.StaticToDynamicNumberRules[w]]; 

CellsOnRight[w_Tissue]:=Module[{cb,el,c,cl},cb=CellsOnBoundary[w];
el=EdgesOnRight[w];
c=TissueCells[w];
cl=Union[First/@First/@(Position[c,#]&/@el)]];
CellsOnRight[w_DTissue]:= CellsOnRight[DTissue2Tissue[w]/.StaticToDynamicNumberRules[w]]; 

CellsOnTop[w_Tissue]:=Module[{cb,el,c,cl},cb=CellsOnBoundary[w];
el=EdgesOnTop[w];
c=TissueCells[w];
cl=Union[First/@First/@(Position[c,#]&/@el)]];
CellsOnTop[w_DTissue]:= CellsOnTop[DTissue2Tissue[w]/.StaticToDynamicNumberRules[w]]; 

CellsOnBottom[w_Tissue]:=Module[{cb,el,c,cl},
cb=CellsOnBoundary[w];
el=EdgesOnBottom[w];
c=TissueCells[w];
cl=Union[First/@First/@(Position[c,#]&/@el)]];
CellsOnBottom[w_DTissue]:= CellsOnBottom[DTissue2Tissue[w]/.StaticToDynamicNumberRules[w]]; 



(* ::Input::Initialization:: *)
TissueCheck[Tissue[v_, e_, f_], opt___?OptionQ]:= Module[{ok, notok, num, ne, nv, nf, quiet, qPrint, passed, dangEdge,ok3},

quiet = "Quiet"/.{opt}/.{"Quiet"-> False}; 
qPrint[x___]:= If[!quiet, Print[x]]; 
passed = True; 

(* Check Vertices *)
If[ListQ[v], 
nv=Length[v]; 
qPrint[nv, " Vertices."]; 
If[nv<3, qPrint["TissueCheck: Error: There must be at least 3 vertices."]; 
passed=False; 
]; 
ok = numPairQ/@v;
ok3=numTripleQ/@v;

num=Range[nv]; 

(* MapThread[
If[!#1,qPrint["TissueCheck: Error: Vertex ", #2," = ", #3, " is not a pair of numbers."]]&, 
{ok, num, v}]; *)

ok = And@@ok; 
ok3=And@@ok3;
If[\[Not]Or[ok,ok3], 
passed=False;
qPrint["TissueCheck: Error: Vertices must all be length 2 or all length 3"]
]; 


,
qPrint["TissueCheck: Error: First argument of tissue must be a list of vertex coordinates."];
passed=False; 
]; 

(* Check Edges *) 

If[ListQ[e], 
ne=Length[e]; 
qPrint[ne, " Edges."]; 
If[ne<3, qPrint["TissueCheck: Error: There must be at least 3 edges."]; 
passed=False; 

]; 
ok = intPairQ/@e;
num=Range[ne]; 
MapThread[
If[!#1,qPrint["TissueCheck: Error: Edge ", #2," = ", #3, " is not a pair of integers."]]&, 
{ok, num, e}]; 
If[\[Not](And@@ok), passed=False]; 

Block[{vnumok},
vnumok[x_]:= x>0 \[And] x<= nv; 
vnumok[{i_, j_}]:= vnumok[i] \[And] vnumok[j]; 
ok = vnumok/@e; 

MapThread[
If[!#1,qPrint["TissueCheck: Error: Edge ", #2," = ", #3, " refers to a non-existent vertex."]]&, 
{ok, num, e}]; 
If[\[Not](And@@ok), passed=False]; 
];
,
qPrint["TissueCheck: Error: second argument of tissue must be a list of edges ({i,j} pairs)."];
passed=False; 

]; 

(* Check Faces *)

If[ListQ[f], 
nf=Length[f]; 
qPrint[nf, " Faces."];
If[nf<1, 
qPrint["TissueCheck: Error: there must be at leaat one face."]; 
passed=False; 

]; 
ok = intListQ/@f; 
num=Range[nf]; 
MapThread[
If[!#1,qPrint["TissueCheck: Error: Face ", #2," = ", #3, " is not a list of integers."]]&, 
{ok, num, f}]; 
If[\[Not](And@@ok), passed=False]; 

Block[{enumok},
enumok[x_]:= x>0 \[And] x<= ne; 
enumok[{i__}]:=And@@(enumok/@{i}); 
 
ok = enumok/@f; 

MapThread[
If[!#1,qPrint["TissueCheck: Error: Cell ", #2," = ", #3, " refers to a non-existent edge."]]&, 
{ok, num, f}]; 
If[\[Not](And@@ok), passed=False]; 
];
,
qPrint["TissueCheck: Error: Third argument of tissue must be a list of faces (cells in 2D), each face as list of edge numbers"];
passed=False; 

]; 
Return[passed]; 
];
TissueCheck[x_, opt___?OptionQ]:=Module[{quiet, qPrint},
quiet = "Quiet"/.{opt}/.{"Quiet"-> False}; 
qPrint[v___]:= If[!quiet, Print[v]];
qPrint["TissueCheck: Error: Expecting Tissue[vertices, edges, faces]. Input does not appear to be a Tissue[...] object. "];

 False]; 


(* ::Input::Initialization:: *)
DanglingEdges[tissue_?TissueQ]:= Complement[Range[NTissueEdges[tissue]],Union[TissueCells[tissue]//Flatten]];


(* ::Input::Initialization:: *)
DanglingVertices[tissue_?TissueQ]:= Complement[Range[NTissueVertices[tissue]], Union[Flatten[TissueEdges[tissue]]]]


(* ::Input::Initialization:: *)
UndangleEdge[tissue_?TissueQ, number_]:= Module[{v,e,c, n, q, edgen}, 
v=TissueVertices[tissue];
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
n=Length[e]; 
If[!MemberQ[DanglingEdges[tissue], number], 

(* If the edge is not Dangling use RemoveVertices *)

Return[MergeVertices[tissue, number]]


(* Old version - only allows removing dangling edges *)
(* 
Print["Error: UndangleEdge: edge ", number, " is not a dangling edge and cannot be removed."]; Return[tissue];
*)

]; 

(* if last edge, just make it go away *)

If[n==number, 
e=Most[e]; 
q=Tissue[v,e,c];
Return[q]; 
];

(* if not last edge, move edge n to old edge number place *)

edgen=Last[e]; 
e=ReplacePart[Most[e], number-> edgen]; 
c = c/.{n-> number}; 
q=Tissue[v,e,c];
Return[q]; 
];

UndangleEdge[x___]:= (Print["Error: Expecting UndangleEdge[tissue, number]"]; $Failed); 

RemoveEdge[x___]:= UndangleEdge[x]; 


(* ::Input::Initialization:: *)
RemoveEdges[T_?TissueQ, edges_?ListQ]:= Module[{ed,T1,ne},
T1=T;
ed=Sort[edges]; 
While[Length[ed]>0,
ne=Last[ed];
ed=Most[ed];
T1=RemoveEdge[T1,ne];
];
Return[T1];
];
RemoveEdges[x___]:= (Print["Error: Expecting RemoveEdge[tissue, list-of-edge-numbers]"]); 


(* ::Input::Initialization:: *)
UndangleEdges[tissue_?TissueQ]:= Module[{danglers, q}, 
danglers = DanglingEdges[tissue];
danglers = Reverse[Sort[danglers]]; 
q=tissue; 
While[Length[danglers]>0, 
q=UndangleEdge[q, First[danglers]]; 
danglers=Rest[danglers]; 
];
Return[q]; 
];
UndangleEdges[x___]:= (Print["Expecing UndangleEdges[tissue]"]; $Failed); 



(* ::Input::Initialization:: *)
UndangleVertex[tissue_?TissueQ, vNumber_?IntegerQ]:= Module[{dv, nv, ne, rule, i, e, c, v}, 

dv = DanglingVertices[tissue]; 
If[!MemberQ[dv, vNumber], Print["Error: UndangleVertex: Vertex: ", vNumber, " is not dangling and cannot be removed."]; Return[tissue]]; 

e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
v=TissueVertices[tissue]; 

nv = Length[v]; 

(* if its at the end, no need to renumber *)

If[vNumber==nv, v=Most[v]; Return[Tissue[v, e, c]]]; 

(* remove the vertex *)

v=Drop[v, {vNumber}]; 

ne = Length[e]; 

(* renumber all the vertex references for all the higher numberd vertices *)

For[i=vNumber, i<= nv, i++, 
rule = Rule[i, i-1]; 
e = e/.rule
]; 

Return[Tissue[v, e, c]]; 
];

UndangleVertex[x___]:= (Print["Expecting[UndangleVertex[tissue, vertexNumber]"]; $Failed); 

RemoveVertex[x___]:= UndangleVertex[x]; 


(* ::Input::Initialization:: *)
RemoveVertices[T_?TissueQ, vlist_?ListQ]:= Module[{vl,T1,vn},
T1=T;
vl=Sort[vlist]; 
While[Length[vl]>0,
vn=Last[vl];
vl=Most[vl];
T1=RemoveVertex[T1,vn];
];
Return[T1];
];
RemoveVertices[x___]:= (Print["Error: Expecting RemoveVertices[tissue, list-of-vertex-numbers]"]); 


(* ::Input::Initialization:: *)
UndangleVertices[tissue_?TissueQ]:= Module[{dv, q}, 
dv = DanglingVertices[tissue]; 
dv = Reverse[Sort[dv]]; 
q=tissue;
While[Length[dv]>0,
q=UndangleVertex[q, First[dv]]; 
dv = Rest[dv]; 
]; 
Return[q];
]; 
UndangleVertices[x___]:= (Print["Expecting UndangleVertices[tissue]"]; $Failed); 


(* ::Input::Initialization:: *)
EdgeVertices[{i_, j_}, vertices_]:={vertices[[i]], vertices[[j]]};

EdgeVertices[{edge__?intPairQ}, vertices_]:= EdgeVertices[#, vertices]&/@{edge};


EdgeVertices[tissue_?TissueQ]:=EdgeVertices[TissueEdges[tissue], TissueVertices[tissue]]; 
EdgeVertices[DT_?DTissueQ]:= EdgeVertices[DTissue2Tissue[DT]]; 
EdgeVertices[u_]:= (Print["Expecting EdgeVertices[tissue] or EdgeVertices[dtissue]"];Abort[];)


(* ::Input::Initialization:: *)
EdgeLengths[tissue_?TissueQ]:= distance@@#&/@EdgeVertices[tissue];  
EdgeLengths[DT_?DTissueQ]:= EdgeLengths[DTissue2Tissue[DT]]; 
EdgeLength[DT_?DTissueQ, i_?IntegerQ]:= EdgeLength[DTissue2Tissue[DT],i]; 
EdgeLength[tissue_?TissueQ, i_?IntegerQ]:= Module[{ne, el}, 
ne=NTissueEdges[tissue];
If[i>ne \[Or] i< 1, Print["Error: EdgeLength: edge ", i, " does not exist."]; Return[$Failed]]; 
 el = distance@@EdgeVertices[tissue][[i]];
Return[el]
];
EdgeLength[x___]:= (Print["Expecting EdgeLength[(d)tissue, edgeNumber]"]; Abort[]); 
EdgeLengths[x___]:= (Print["Expecting EdgeLengths[(d)tissue]"]; Abort[]); 
CellEdgeLengths[tissue_?TissueQ, cellNumber_?NumberQ]:=EdgeLength[tissue, #]&/@TissueCells[tissue] [[cellNumber]];
CellEdgeLengths[DT_?DTissueQ,cellNumber_?NumberQ]:= Module[{c,i,T},
i=Position[First/@TissueCells[DT], cellNumber]; 
While[ListQ[i], i=First[i]]; 
CellEdgeLengths[DTissue2Tissue[DT],i]
]
CellEdgeLengths[x___]:= (Print["Expecting CellEdgeLengths[tissue, cellNumber]"]; Abort[]);




(* ::Input::Initialization:: *)
SortCellsCounterClockwise[tis_Tissue]:=Module[{centroids, c,nc, e, s, v, clockwise, snew, i, vnext, enext},
centroids=Centroid[tis];
c=TissueCells[tis];
nc=Length[c]; 
e=TissueEdges[tis];
v=TissueVertices[tis]; 
s=SortCellEdges[c[[#]], e]&/@Range[nc];

clockwise[i_]:= Module[{v1,v2, \[Theta]1,\[Theta]2},
v1=v[[("Vertices"/.s[[i]])[[1]]]]-centroids[[i]];
v1=v1/Norm[v1];
v2=v[[("Vertices"/.s[[i]])[[2]]]]-centroids[[i]];
v2=v2/Norm[v2];

v1[[1]]v2[[2]]-v2[[1]]v1[[2]]<0
];
snew={}; 
For[i=1, i<= nc, i++,
If[clockwise[i],
vnext=RotateRight[Reverse["Vertices"/.s[[i]]],1];
enext =Reverse["Edges"/.s[[i]]];
AppendTo[snew, {"Edges"-> enext, "Vertices"-> vnext}]; 
,
AppendTo[snew, s[[i]]];
]; 
];
Return[snew]
];
SortCellsCounterClockwise[x_]:= (Print["Expecting SortCellsCounterClockwise[tissue]"]; Abort[]); 


(* ::Input::Initialization:: *)
SortCellEdges[edges_?intListQ,alledges_]:=Module[{dbg=False,dPrint,edgepairs,allVertices,EndPoints,ep1,ep2,i,pair,result,v,eresult,EdgeNumber,vresult,lastpoint},
dPrint[u___]:=If[dbg,Print["SCE: ",u]];
edgepairs=alledges[[edges]];
allVertices=Union[Flatten[edgepairs]];
EdgeNumber[{i_,j_}]:=Module[{p1,p2},
p1=Position[alledges,{i,j}];
p2=Position[alledges,{j,i}];
If[Length[p1]>0,
Return[p1[[1,1]]],
Return[p2[[1,1]]]]];
EndPoints=Pick[allVertices,Length[Position[edgepairs,#]]<2&/@allVertices];
dPrint["edgepairs: ",edgepairs];
dPrint["allVertices: ",allVertices];
dPrint["EndPoints: ",EndPoints];
If[Length[EndPoints]>2\[Or]Length[EndPoints]==1,Print[GraphPlot[Rule[#[[1]],#[[2]]]&/@edgepairs,VertexLabeling->True]]];
AbortIf[Length[EndPoints]>2,"SortCellEdges: Found To many End Points "<>ToString[InputForm[EndPoints]]<>" in list "<>ToString[InputForm[edgepairs]]<>" (There must be zero or two end points.)"];
AbortIf[Length[EndPoints]==1,"SortCellEdges: Found Precisely One End Point "<>ToString[InputForm[EndPoints]]<>" in list "<>ToString[InputForm[edgepairs]]<>" (There must be zero or two end points.)"];
If[Length[EndPoints]==2,{ep1,ep2}=EndPoints;
i=Position[edgepairs,ep1][[1,1]];
dPrint["ep1 ",ep1," is at ",i];
pair=edgepairs[[i]];
If[pair[[2]]==ep1,pair=Reverse[pair]];,i=1;
pair=edgepairs[[i]];];
result={pair};
AbortIf[Length[edgepairs]<i, "SortCellEdges: (Possible Program Error 1) Attempt to remove element "<>ToString[i]<>" from edgepairs of length "<>ToString[Length[edgepairs]]]; 
AbortIf[Not[IntegerQ[i]], "SortCellEdges: (Possible Program Error 2) Attempt to remove element "<>ToString[i]<>" from edgepairs of length "<>ToString[Length[edgepairs]]]; 
edgepairs=Delete[edgepairs,i];
dPrint["result=",result," edgepairs=",edgepairs];
While[Length[edgepairs]>0,
v=pair[[2]];
i=Position[edgepairs,v][[1,1]];
pair=edgepairs[[i]];
If[pair[[2]]==v,pair=Reverse[pair]];
dPrint["vertex ",v," is it ",i," pair = ",pair];
AbortIf[Length[edgepairs]<i, "SortCellEdges: (Possible Program Error 3) Attempt to remove element "<>ToString[i]<>" from edgepairs of length "<>ToString[Length[edgepairs]]];
AbortIf[Not[IntegerQ[i]], "SortCellEdges: (Possible Program Error 4) Attempt to remove element "<>ToString[i]<>" from edgepairs of length "<>ToString[Length[edgepairs]]<>" result = "<>ToString[result]<>" v="<>ToString[v]<>" edges="<> ToString[edges]<>" alledges[[edges]]="<>ToString[alledges[[edges]]]<>" alledges="<>ToString[InputForm[alledges]]]; 

edgepairs=Delete[edgepairs,i];
AppendTo[result,pair];
dPrint["result=",result," edgepairs=",edgepairs];];
eresult=EdgeNumber/@result;
vresult=First/@result;
lastpoint=Last[Last[result]];
If[!MemberQ[vresult,lastpoint],AppendTo[vresult,lastpoint]];
dPrint["eresult: ",eresult];
dPrint["vresult: ",vresult];

Return[{"Edges"->eresult,"Vertices"->vresult}];]
SortCellEdges[x___]:= (Print["Expecting SortCellEdges[cell, edges], where cell={e1,e2,...} and edges={{v11,v12}, {v21, v22}, ...}"]; Abort[]); 


(* ::Input::Initialization:: *)
(* SortCellEdges[cell_?intListQ, edges_]:= Module[{ep, num , sortedep, sortednums, edge, v2,p, index, vertices, dbg=False , firstpair, dPrint, lastver, setappend},
dPrint[u___]:= If[dbg ,Print["SortCellEdges: ", u]]; 
If[Length[cell]>0,
ep=edges[[#]]&/@cell;
ep = Sort/@ep;
edge=First[ep]; 
sortedep={edge};
index=1; 
sortednums={index};
num=Range[2, Length[cell]]; 

firstpair=True; (*allow non-cyclic cells, e.g., walls *)
setappend=True; 
While[Length[sortednums]<Length[cell],
dPrint["new pair *****"]; 
v2=edge[[2]]; 
p=Position[ep, v2];
p = Select[p, First[#]\[NotEqual] index&]; 
dPrint["p=", p];
setappend=True; 

If[Length[p]<1,
If[firstpair,
v2=edge[[1]];
p=Position[ep, v2];
p = Select[p, First[#]\[NotEqual] index&]; 
,
v2=sortedep[[1,1]];
dPrint["revised v2=",v2]; 
dPrint["ep=" ,ep]; 
p=Position[ep, v2];
dPrint["Revised p: ", p];
setappend=False;
]; 
If[Length[p]<1, 
Print[GraphPlot[Rule[#[[1]],#[[2]]]&/@ep,VertexLabeling\[Rule]True]]
]; 
AbortIf[Length[p]<1, 
"Error: SortCellEdges: Cell "<>ToString[InputForm[ cell]]<> " is unsortable. Edge Pairs: "<>ToString[InputForm[ep]]] 
(*Return[$Failed]*)
];  
firstpair=False; 
dPrint["p=", p];
p=First/@p;
dPrint["p=", p];
edge = ep[[p[[1]]]]; 
dPrint["edge=", edge]; 
While[MemberQ[sortedep,edge] \[Or] MemberQ[sortedep, Reverse[edge]], 
p=Rest[p];
dPrint["p=", p]; 
If[Length[p]<1, 
Print[GraphPlot[Rule[#[[1]],#[[2]]]&/@ep,VertexLabeling\[Rule]True]]
]; 
AbortIf[Length[p]<1, 
"Error: SortCellEdges: Cell "<>ToString[InputForm[ cell]]<> " is unsortable. Edge Pairs: "<>ToString[InputForm[ep]]] ;
 edge=ep[[p[[1]]]]; 
dPrint["edge=", edge]; 

];
If[edge[[1]]\[NotEqual] v2, 
edge=Reverse[edge];
]; 
If[setappend, AppendTo[sortedep, edge], PrependTo[sortedep,Reverse[edge]]]; 
dPrint["sortedep: ", sortedep]; 
AppendTo[sortednums, p[[1]]]; 
dPrint["sortednums: ", sortednums]; 
index = p[[1]]

(* Print[{sortedep, sortednums, v2, p, edge}]; *)
 
]; 
sortednums=cell[[sortednums]];
dPrint["sortednums: ", sortednums]; 

lastver = Last[Last/@sortedep]; 
sortedep = First/@sortedep; 
 If[!MemberQ[sortedep,lastver], AppendTo[sortedep, lastver]]; 
dPrint["sortedep: ", sortedep]; 

,
sortednums={};
sortedep={};
];
Return[{"Edges"\[Rule] sortednums, 
"Vertices"\[Rule] sortedep
}]; 
 
]; 
SortCellEdges[x___]:= (Print["Expecting SortCellEdges[cell, edges], where cell={e1,e2,...} and edges={{v11,v12}, {v21, v22}, ...}"]; Abort[]);  *)


(* ::Input::Initialization:: *)
CellVertexNumbers[cell_?intListQ, edges_]:= Module[{f},
f=SortCellEdges[cell, edges]; 
If[f===$Failed, 
Print["Error: CellVertexNumbers: Failure code from SortCellEdges."]; 
Return[$Failed]]; 
Return["Vertices"/.f]
]; 

CellVertexNumbers[{cell__?intListQ}, edges_]:= CellVertexNumbers[#,edges]&/@{cell};
CellVertexNumbers[tissue_?TissueQ, cellNumber_]:= CellVertexNumbers[TissueCells[tissue][[cellNumber]], TissueEdges[tissue]]; 
CellVertexNumbers[tissue_?TissueQ]:= CellVertexNumbers[tissue, #]&/@Range[NTissueCells[tissue]];

CellVertexNumbers[T_?DTissueQ,n_]:= Module[{C,CN,T1,C1,n1},
C=n/.TissueCells[T]; 
T1=DTissue2Tissue[T]; 
C1=TissueCells[T1];
n1=Position[C1,C]; 
While[ListQ[n1],
If[Length[n1]==1,n1=First[n1],Break[]]

]; 
If[ListQ[n1], Return[{}]];

CellVertexNumbers[T1,n1]
];
CellVertexNumbers[T_?DTissueQ]:= CellVertexNumbers[DTissue2Tissue[T]]


(* ::Input::Initialization:: *)
CellVertexCoordinates[cell_?intListQ, edges_, vertices_]:= Module[{v},
v=CellVertexNumbers[cell, edges]; 
If[v===$Failed, Print["Error: CellVertexCoordinates: Failure code returned from CellVertexNumbers."]; Return[$Failed]]; 

v=vertices[[v]]; 
Return[v]; 
];
CellVertexCoordinates[tiss_?TissueQ, n_]:= Module[{v},
If[n>NTissueCells[tiss] \[Or] n<1, Print["Error: CellVertexCoordinates: nonexistent cell number ", n, " requested."]; Return[$Failed]]; 
v=CellVertexCoordinates[
TissueCells[tiss][[n]],
TissueEdges[tiss],
TissueVertices[tiss]
];
If[v===$Failed, Print["Error: CellVertexCoordinates: Failure code returned from CellVertexNumbers for cell ",n]; Return[$Failed]]; 
Return[v]; 
];
CellVertexCoordinates[tiss_?TissueQ]:= Module[
{v,e, c, n, cvc},
n=NTissueCells[tiss] ; 
v=TissueVertices[tiss];
e=TissueEdges[tiss]; 
c=TissueCells[tiss]; 
cvc = CellVertexCoordinates[#, e, v]&/@c; 
Return[cvc]
];

CellVertexCoordinates[DT_?DTissueQ,i_?IntegerQ]:= Module[{T,c},
c=Position[First/@TissueCells[DT],i];
If[c=={}, c=0, While[ListQ[c], c=First[c]]]; 
CellVertexCoordinates[DTissue2Tissue[DT],c]
];

CellVertexCoordinates[DT_?DTissueQ]:= CellVertexCoordinates[DTissue2Tissue[DT]]; 

CellVertexCoordinates[x__]:= (Print["Expecting CellVertexCoordinates[(d)tissue, (number)]"];Abort[]);




(* ::Input::Initialization:: *)
EdgesOnBoundary[tissue_?TissueQ]:= Module[{ne, c,e,  keep, edgenums},
e=TissueEdges[tissue];
ne=Length[e]; 
c=TissueCells[tissue];
edgenums=Range[ne];
keep =(Length[#]==1)&/@(Cases[c,#, 2]&/@edgenums);
keep=Pick[edgenums, keep]; 
(* Print[keep]; 
keep="Edges"/.SortCellEdges[keep, e]; 
*)
Return[keep]; 
];
EdgesOnBoundary[DT_?DTissueQ]:= EdgesOnBoundary[DTissue2Tissue[DT]];


(* ::Input::Initialization:: *)
EdgesNotOnBoundary[tissue_?TissueQ]:=Complement[Range[NTissueEdges[tissue]], EdgesOnBoundary[tissue]];
EdgesNotOnBoundary[DT_?DTissueQ]:= EdgesNotOnBoundary[DTissue2Tissue[DT]];


(* ::Input::Initialization:: *)
VerticesOnBoundary[tissue_?TissueQ]:= Module[{be, e},
be=EdgesOnBoundary[tissue]; 
e=TissueEdges[tissue]; 
Return[
(* Union[Flatten[e[[be]]]]*)
"Vertices"/.SortCellEdges[be, e]
];
];
VerticesOnBoundary[DT_?DTissueQ]:= VerticesOnBoundary[DTissue2Tissue[DT]]; 


(* ::Input::Initialization:: *)
VerticesNotOnBoundary[tissue_?TissueQ]:= Complement[Range[NTissueVertices[tissue]], VerticesOnBoundary[tissue]]; 
VerticesNotOnBoundary[DT_?DTissueQ]:= VerticesNotOnBoundary[DTissue2Tissue[DT]];


(* ::Input::Initialization:: *)
CellsOnBoundary[tissue_?TissueQ]:= Module[{be, c, keep},
be=EdgesOnBoundary[tissue];
c=TissueCells[tissue];
keep = (Length[#]>0)&/@(Intersection[be, #]&/@c);
Return[Pick[Range[Length[c]], keep]]; 
]; 
CellsOnBoundary[DT_?DTissueQ]:= Module[{T,bc,cn, s2d,nc},
bc=CellsOnBoundary[DTissue2Tissue[DT]];
cn=First/@TissueCells[DT]; 
nc = Range[Length[cn]]; 
s2d = MapThread[Rule,{nc,cn}];
(bc/.s2d)
]; 
CellsOnBoudary[x___]:= (Print["Expecting CellsOnBoundary[tissue]"];Abort[]); 


(* ::Input::Initialization:: *)
InteriorCells[tissue_?TissueQ]:= Module[{nc,bc,ic},
bc=CellsOnBoundary[tissue];
nc=NTissueCells[tissue];
Return[Complement[Range[nc], bc]]
];
InteriorCells[DT_?DTissueQ]:= Module[{bc,cn},
bc=CellsOnBoundary[DT]; 
cn = First/@TissueCells[DT]; 
Complement[cn,bc]
]
InteriorCells[x___]:=(Print["Expecting InteriorCells[tissue]"];Abort[]);


(* ::Input::Initialization:: *)
DivideEdges[tissue_?TissueQ, edgeNumbers_?intListQ,
segments_?IntegerQ, randomness_:0]:= Module[
{edges2divide, next, new},

edges2divide=edgeNumbers;
new=tissue; 
While[Length[edges2divide]>0,
next=First[edges2divide]; 
edges2divide=Rest[edges2divide]; 
new = DivideEdge[new, next, segments, randomness];
]; 
Return[new]; 
];

DivideEdges[tissue_?TissueQ,segments_?IntegerQ, randomness_:0]:= Module[{n}, 
n=NTissueEdges[tissue]; 
Return[DivideEdges[tissue,  Range[n], segments, randomness]]]; 

DivideEdges[x___]:= (Print["Error: expecting DivideEdges[tissue, segments, random] or DivideEdges[tissue, {n1,n2, ...}, segments, random]"]; $Failed); 


(* ::Input::Initialization:: *)
DivideEdge[tissue_?TissueQ, edgeNumber_?IntegerQ,
parts_?IntegerQ, random_:0]:= Module[{r, e, ne,nv, i, j,v, c,  vi, vj, dbg=False, dPrint, vnew, newEdgeNumbers, newEdges, length, randoms, q},

dPrint[x___]:= If[dbg, Print[x]]; 

(* limit randomization to 25% *) 
r=Min[Max[0, random], .25]; 
If[r!= random, Print["Warning: DivideEdge: random must be in [0,.25]; value used:  ", r]]; 

(* check validity of input *)

e=TissueEdges[tissue]; 
ne = Length[e]; 
If[edgeNumber<1 \[Or] edgeNumber > ne, Print["Error: DivideEdge: nonexistent edge ", edgeNumber," requested. Must be between 1 and ", ne]; Return[tissue]]; 

If[parts<2, Return[tissue]]; 

(* input is all valid *)

{i, j} = e[[edgeNumber]];
v=TissueVertices[tissue]; 
nv=Length[v]; 
{vi,vj}={v[[i]], v[[j]]}; 

vnew = (vi + (1.0*#/parts)(vj-vi))&/@Range[1, parts-1]; 

(* and randomness *) 
length = distance[vi,vj]*(1.0/parts); 
randoms = length*Table[{RandomReal[{-r,r}], RandomReal[{-r,r}]}, {parts-1}];
vnew = vnew+randoms; 

v=Join[v, vnew];

newEdgeNumbers=Range[ne+1, ne+parts]; 
newEdges=Transpose[{
Flatten[{i, Range[nv+1, nv+parts-1]}],
Flatten[{Range[nv+1, nv+parts-1], j}]
}];
e=Join[e, newEdges]; 

c=Flatten/@(TissueCells[tissue]/.{edgeNumber-> newEdgeNumbers}) ;
c=("Edges"/.#)&/@(SortCellEdges[#, e]&/@c);

dPrint["{i,j}: ", {i,j}, "\n{vi,vj}:", {vi,vj}, 
"\nrandoms:", randoms,"\nvnew=", vnew, "\nv (revised):", v, "\nnewEdgeNumbers:", newEdgeNumbers,"\nnewEdges:", newEdges, "\ne (revised):", e, "\nc (revised):", c]; 

q=Tissue[v,e,c]; 

dPrint["Undangling old edge ", edgeNumber]; 
q=UndangleEdge[q, edgeNumber]; 

Print["Warning: Edge ", #, " is dangling and should be removed."]&/@DanglingEdges[q]; 

Return[q]; 
];



(* ::Input::Initialization:: *)
DivideEdge[tissue_?TissueQ, edgeNumber_?IntegerQ,  {x_?NumericQ, y_?NumericQ}]:= Module[{v,e,c,ne, v1, v2,e1, e2,  nv, q}, 
e=TissueEdges[tissue];
ne=Length[e]; 
If[edgeNumber>ne \[Or] edgeNumber<1, 
Print["Error: DivideEdge: requested edge ", edgeNumber," does not exist."]; 
Return[tissue];
];

(* add the new vertex *)

v=TissueVertices[tissue];
AppendTo[v, {x,y}]; 
nv = Length[v];

c=TissueCells[tissue]; 

(* add new edge at end, and replace old edge *)
(* (v1,v2) --> (v1, ne) + (ne, v2) *)
(* need to keep each edge sorted with v1 < v2 *)

{v1, v2} = e[[edgeNumber]];
e1={v1, nv};
e2={v2, nv}; 
e=ReplacePart[e, edgeNumber-> e1]; 
AppendTo[e, e2]; 

(* fix cells *)
c = c/.{edgeNumber-> Sequence@@{edgeNumber, ne+1}};

q=Tissue[v,e,c];
Return[q];
];


(* ::Input::Initialization:: *)
DivideEdge[x___]:= (Print["Error: Expecting DivideEdge[tissue, edge number, parts, random] or \nDivideEdge[tissue, edge number, {x,y}]\ninstead of \n",{x}]; $Failed); 


(* ::Input::Initialization:: *)
MergeEdges[tissue_?TissueQ, e1_?IntegerQ, e2_?IntegerQ, opt___?OptionQ]:= Module[{v,e,c, tnew, edge1, edge2,ne, vcommon, v1, v2, enew, cnew, cchanged, cnum, csorted, cunsorted, undangle, sharedwith},
v=TissueVertices[tissue]; 
e=TissueEdges[tissue];
ne = Length[e]; 
AbortIf[e1>ne \[Or] e1<1 \[Or]e2>ne \[Or]e2<1, "Error: MergeEdges: edge numbers must be between 1 and "<>ToString[ne]<> " requested values are "<>ToString[e1]<>","<>ToString[e2]
]; 

edge1=e[[e1]];
edge2=e[[e2]]; 
vcommon = Intersection[edge1,edge2]; 
AbortIf[Length[vcommon]<1, 
"Error: MergeEdges: edges "<>ToString[e1]<>" = "<>ToString[edge1]<> " and "<>ToString[e2]<> " = "<>ToString[edge2]<> " do not share a common vertex."
]; 

sharedwith=Complement[Flatten[First/@Position[e,#]&/@vcommon],{e1,e2}];

AbortIf[Length[sharedwith]>0, "The requested edges cannot be merged because they share their intersection with another edge."]; 


v1 = Complement[edge1, vcommon][[1]]; 
v2= Complement[edge2, vcommon][[1]]; 
vcommon = First[vcommon]; 

enew = Sort[{v1, v2}]; 
AppendTo[e, enew]; 
ne = ne+1; 

c=TissueCells[tissue]; 
cnew = c/.{e1-> ne, e2-> ne}; 

cchanged = Pick[Range[Length[c]],
MapThread[#1!= #2&,{c,cnew}]
];  
While[Length[cchanged]>0,
cnum = First[cchanged]; 
cchanged=Rest[cchanged];
cunsorted = Union[cnew[[cnum]]]; 
 
csorted = "Edges"/.SortCellEdges[cunsorted, e]; 
cnew = ReplacePart[cnew, cnum-> csorted]; 
]; 

tnew = Tissue[v,e,cnew]; 

undangle = "Undangle"/.{opt}/.{"Undangle"-> True}; 
If[undangle,
tnew = UndangleEdges[tnew]; 
tnew = UndangleVertices[tnew]; 
]; 
Return[tnew];
]; 
MergeEdges[x___]:= (Print["Error: Expecting MergeEdges[tissue, e1, e2]"]; $Failed); 


(* ::Input::Initialization:: *)
MergeVertices[tissue_Tissue, edge_Integer, opt___?OptionQ]:= Module[{v,e,c,ne, v1, v2, keep, chuck, enew, cnew,vnew,vkeep, tnew, edgeChanges},
c=TissueCells[tissue];
e=TissueEdges[tissue];
v=TissueVertices[tissue]; 
ne=Length[e]; 
If[edge>ne \[Or] edge <1, Print["Error: MergeVertices: Edge ", edge, " does not exist." ]; Return[tissue]]; 
{v1,v2}=e[[edge]];
keep=Min[v1,v2];
chuck=Max[v1,v2]; 
vkeep=0.5(v[[keep]]+v[[chuck]]); 
vnew = ReplacePart[v, keep-> vkeep]; 
enew = e/.{chuck-> keep};
cnew = c/.{edge-> {}};
cnew=Flatten/@cnew; 
tnew= Tissue[vnew, enew, cnew];
tnew = RemoveEdge[tnew, edge];
tnew=UndangleVertices[tnew];

If["Changes"/.{opt}/.{"Changes"-> False}, 
If[edge<ne, edgeChanges={ne-> edge}, edgeChanges={ne-> {}}]; 
AppendTo[edgeChanges, edge-> {}]; 
Return[{Union[edgeChanges], tnew}];
]; 
Return[tnew];
]; 
MergeVertices[tissue_Tissue, {v1_Integer, v2_Integer}, opt___?OptionQ]:= Module[{i},
e=Sort/@TissueEdges[tissue]; 
i=Position[e, Sort[{v1,v2}]];

If[Length[i]<1, Print["Error: MergeVertices: Edge ", {v1,v2}, " not found."]; 
If["Changes"/.{opt}/.{"Changes"-> False}, 
Return[{{}, tissue}], 
Return[tissue]]]; 
If[Length[i]>1, Print["Error: MergeVertices: Edge ", {v1, v2}, " found in multiple locations in tissue. Check tissue for errors."]; Abort[]]; 
i=First[Flatten[i]]; 
Print[i]; 
MergeVertices[tissue, i, opt]]; 
MergeVertices[x___]:= (Print["Expecting MergeVertices[tissue, {v1,v2}] or MergeVertices[tissue, edgeNumber.]"]; Abort[]); 


(* ::Input::Initialization:: *)
DivideCell[tiss_?TissueQ, j_?IntegerQ, {p1in_?NumericPointQ, p2in_?NumericPointQ}, opt___?OptionQ]:= Module[{dbg, dPrint, c,v,e, nv, ne, nc, cvc, intersections, ce1,ce2, e1,e2, v1, v2, enew, e1val, e2val, e1new, e2new,ne1, ne2,  ne1new, ne2new, cold, cnew, coldvn, cnewvn, Sorted, p1, p2, edgechanges, cj},
Sorted[{x_,y_}]:= x<=y; 
 
p1=p1in; p2=p2in;

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["DivideCell: ", x]]; 

dPrint["points: ", {p1, p2}]; 

c=TissueCells[tiss];
v=TissueVertices[tiss]; 
e=TissueEdges[tiss]; 

(* Sort pairs so that indices are {smaller, larger} 
   bug fix 2.1.a.20 *)
e=Sort/@e;
dPrint["Sorted: ", And@@(Sorted/@e)];
nc=Length[c];
nv=Length[v];
ne=Length[e]; 

dPrint["c[[j]]:", c[[j]]]; 

(* If c[[j]] is not sorted then Cell Vertex Coordinates might return the vertices in backwards order *)
cj="Edges"/.SortCellEdges[c[[j]], e];
dPrint["cj sorted:", cj]; 
c=ReplacePart[c, j-> cj]; 
dPrint["c[[j]]:", c[[j]]]; 


cvc = CellVertexCoordinates[tiss,j]; 
dPrint["cvc: ", cvc]; 

intersections = PolygonIntersection[{p1,p2}, cvc]; 
dPrint["intersections: ", intersections];

Block[{V,  iteration, theta, k, p2new},
iteration=1; 
p2new=p2; 
k=1; 
While[Length[intersections]>2, Print["Warning: DivideCell: Existing Vertex or non-convex cell."];
If[iteration++>5, Abort[]]; 
Print["Attempting Recovery, rotating line of division by ", k, " degrees"]; 
theta = (k*Pi/180.0); 
(* move each end point a little bit 
   perpendicular to line *)
V=p2-p1;
p2new = p1+RotationMatrix[theta].V;

intersections = PolygonIntersection[{p1,p2new}, cvc];
k=(k+1); 
]; 
p2=p2new;
];


If[Length[intersections]<2, 
Print["Unable to perform cell division."]; 
If["Changes"/.{opt}/.{"Changes"-> False}, Return[{$Failed,tiss}], Return[tiss]]]; 

{{ce1, v1}, {ce2, v2}}=intersections; 

(* add in the new vertices and determine their vertex numbers *)
(* first use v1,v2 as coordinates; then as vertex numbers *)
AppendTo[v, v1]; 
AppendTo[v, v2]; 
v1=nv+1;
v2=nv+2; 
dPrint["New Vertices are ",v1,",",v2]; 

(* add in the new edge for the dividing line *)
(* first use enew as an edge, then as an edge number *)

enew = {v1,v2}; 
AppendTo[e,Sort[enew]]; 
enew = ne+1; 
dPrint["Sorted: ", And@@(Sorted/@e)];

(* modify the old edges *)
(* ne1, ne2 are edges numbers of the two split edges *)
(* e1val, e2val are the vertex numbers (before splitting *)
ne1 = c[[j,ce1]];
ne2 = c[[j, ce2]]; 
e1val = e[[ne1]]; 
e2val = e[[ne2]]; 
dPrint["{ne1,ne2}:", {ne1, ne2}]; 
dPrint["(e1val, e2val}: ", {e1val, e2val}]; 

(* e1 becomes e1+e1new, e2 becomes e2+e2new *)
(* define the new edges and add them in *)

e1={e1val[[1]], v1}//Sort; 
e1new = {v1, e1val[[2]]}//Sort;
AppendTo[e, e1new]; 
ne1new = ne+2; 
dPrint["(edge ", ne1,") e1\[Rule]", e1, " e1new\[Rule]", e1new, " (edge ", ne1new,")"]; 


e2 = {e2val[[1]] ,v2}//Sort; 
e2new = {v2, e2val[[2]]}//Sort; 
AppendTo[e ,e2new]; 
ne2new = ne+3; 
dPrint["(edge ", ne2,") e2\[Rule]", e2, " e2new\[Rule]", e2new, " (edge ", ne2new, ")"]; 



(* distribute the edges in the daughter cells *)
(* make sure edges are sorted or this won't work! *)

cold =SortCellEdges[ c[[j]], e]; 

(* list of old cell as vertex numbers *)
coldvn = e[[c[[j]]]]; 
(* replace each split edge with new pair of daughter edges *)
cnewvn= coldvn/.{e1val-> Sequence[e1,e1new], e2val-> Sequence[e2, e2new]};

dPrint["cold: ", cold];
dPrint["coldvn: ", coldvn]; 
dPrint["cnewvn: ", cnewvn]; 

(* replace the original edges with their "first" half *)
e=ReplacePart[e, ne1-> e1]; 
e=ReplacePart[e, ne2-> e2]; 


Block[{vn, vxy, vec, vecs, angles, angle1, angle2, cell1, cell2, pe1, pe2}, 
(* determine which vertices go with which cell *)

vn=Union[Flatten[coldvn]];
vxy = v[[vn]];  
vec=p2-p1; 
vecs = (#-p1)&/@vxy; 
angles = Mod[ArcTan@@#&/@vecs, 2Pi]; 
angle1=Mod[ArcTan@@vec, 2Pi];
angle2=Mod[Pi+angle1, 2Pi]; 
{angle1,angle2}=Sort[{angle1,angle2}]; 
cell1=(angle1<= # \[And] #<= angle2)&/@angles;
cell2=Not/@cell1;  
cell1 = Pick[vn, cell1]; 
cell2=Pick[vn, cell2]; 

dPrint["vn:", vn];
dPrint["vxy:", vxy];
dPrint["vecs: ", vecs]; 
dPrint["angles: ", angles]; 
dPrint["angle1,2: ", {angle1, angle2}]; 
dPrint["cell1: ", cell1]; 
dPrint["cell2: ", cell2]; 


(* now figure which edges *)
(* position in the list of vertex pairs *)
cell1 = Union[Flatten[First/@Position[cnewvn, #]&/@cell1]];
cell2=  Union[Flatten[First/@Position[cnewvn, #]&/@cell2]];

cell1=Sort/@Append[cnewvn[[cell1]], {v1,v2}]; 
cell2= Sort/@Append[cnewvn[[cell2]], {v1,v2}];

dPrint["cell1: ", cell1]; 
dPrint["cell2: ", cell2]; 

cell1=Flatten[Position[e, #]&/@cell1];
cell2=Flatten[Position[e,#]&/@cell2]; 

dPrint["cell1 Flattened Positions: ", cell1]; 
dPrint["cell2 Flattened Positions: ", cell2]; 

cell1=SortCellEdges[cell1, e]; 
If[SameQ[cell1, $Failed], Print["Error Exit: DivideCell."]; Return[$Failed]]; 
cell1="Edges"/.cell1; 

cell2=SortCellEdges[cell2, e]; 
If[SameQ[cell2, $Failed],Print["Error Exit: DivideCell"];  Return[$Failed]]; 
cell2 = "Edges"/.cell2; 

dPrint["cell1: ", cell1]; 
dPrint["cell2: ", cell2]; 

(* put in the new cells *)

c=ReplacePart[c, j-> cell1]; 
AppendTo[c, cell2];

(* check to see if either edge is part of any other cell! *)

pe1=Complement[First/@Position[c, ne1], {j,nc+1}]; 
pe2=Complement[First/@Position[c, ne2], {j, nc+1}]; 
dPrint["pe1,pe2:", {pe1, pe2}]; 

If[Length[pe1]>0, 
pe1=First[pe1]; 
cell1 = c[[pe1]]/.{ne1-> Sequence[ne1, ne1new]}; 
cell1 ="Edges"/.SortCellEdges[cell1, e]; 
dPrint["bordering cell1: ", cell1]; 
c=ReplacePart[c, {pe1-> cell1}]; 
]; 

If[Length[pe2]>0,
pe2=First[pe2];  
cell2=  c[[pe2]]/.{ ne2-> Sequence[ne2, ne2new]}; 
cell2="Edges"/.SortCellEdges[cell2, e];
dPrint["bordering cell2: ", cell2]; 
c=ReplacePart[c, {pe2-> cell2}]; 

]; 


];

edgechanges={0-> enew, ne1-> ne1, ne1-> ne1new, ne2-> ne2, ne2-> ne2new};
dPrint["edgeChanges:", edgechanges]; 

If["Changes"/.{opt}/.{"Changes"-> False}, 
Return[{edgechanges, Tissue[v,e,c]}], 

Return[Tissue[v,e,c]]; 
]; 

]; 

DivideCell[x___]:= (Print["Error: Expecting DivideCell[tissue, cell-number, {point1,point2}]"]; $Failed); 


(* ::Input::Initialization:: *)
RemoveCell[tissue_?TissueQ, cellNumber_?IntegerQ]:= Module[{nc, c, v, e, q},
v=TissueVertices[tissue]; 
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
nc=Length[c]; 
If[cellNumber> nc \[Or] cellNumber < 1, Print["Error: RemoveCell: Cell ", cellNumber, " does not exist and cannot be removed."]; 
Return[tissue]]; 
c=Drop[c, {cellNumber}]; 
q = Tissue[v, e, c]; 
q=UndangleEdges[q]; 
q=UndangleVertices[q]; 
Return[q]; 
] ;


RemoveCell[tissue_?TissueQ, {cellNumber__?IntegerQ}]:= Module[{nc, c, v, e, q, keep, remove},
v=TissueVertices[tissue]; 
e=TissueEdges[tissue]; 
c=TissueCells[tissue]; 
nc=Length[c]; 
If[#> nc \[Or] # < 1, Print["Error: RemoveCell: Cell ", cellNumber, " does not exist and cannot be removed."]]&/@{cellNumber};

(* pick out which cells to remove *)

remove = Select[{cellNumber}, (#>0 \[And] #<= nc)&]; 
keep = Table[True, {nc}]; 
While[Length[remove]>0,
keep[[First[remove]]]=False;  
remove=Rest[remove];
];

c=Pick[c, keep]; 

q = Tissue[v, e, c]; 
q=UndangleEdges[q]; 
q=UndangleVertices[q]; 
Return[q]; 
] ;

RemoveCell[x___]:=(Print["Expecting RemoveCell[tissue, cellNumber]"]; $Failed); 


(* ::Input::Initialization:: *)
AddVertex[tissue_?TissueQ, {x_?NumericQ, y_?NumericQ}]:= Module[{v,e,c, q},
v=Append[TissueVertices[tissue], {x,y}];
e=TissueEdges[tissue];
c=TissueCells[tissue]; 
Return[Tissue[v,e,c]]; 
];
AddVertex[x___]:= (Print["Expecting AddVertex[Tissue, {number, number}]"]; Return[$Failed]); 


(* ::Input::Initialization:: *)
AddEdge[tissue_?TissueQ, {i_?IntegerQ, j_?IntegerQ}]:= Module[{v,e,c, nv, q, failed},
v=TissueVertices[tissue];
nv=Length[v]; 
failed=False; 
If[#<1 \[Or] #>nv, 
Print["Error: AddEdge: Vertex ", #, " does not exist."]; failed=True]&/@{i,j};
If[failed, Return[$Failed]]; 
e=Append[TissueEdges[tissue], {i,j}];
c=TissueCells[tissue]; 
q=Tissue[v,e,c];
Return[q]; 
];
AddEdge[x___]:= (Print["Expecting AddEdge[Tissue, {int, int}]"]; Return[$Failed]); 


(* ::Input::Initialization:: *)
AddCell[tissue_?TissueQ, {i_?IntegerQ, j_?IntegerQ, k__?IntegerQ}]:= Module[{v,e,c,ne, q, failed},
v=TissueVertices[tissue];
e=TissueEdges[tissue]; 
ne=Length[e]; 
c=TissueCells[tissue]; 
failed=False; 
If[#<1 \[Or] #>ne, 
Print["Error: AddCell: Edge ", #, " does not exist."]; failed=True]&/@{i,j, k};
If[failed, Return[$Failed]]; 
c=Append[c, {i,j,k}]; 
q=Tissue[v,e,c];
Return[q]; 

]; 


(* ::Input::Initialization:: *)
EntangledVertices[tissue_?TissueQ]:= Module[
{e,v, entangled, entanglements, unresolved, rv, nv, ne},
e=TissueEdges[tissue];
ne=Length[e]; 
v=TissueVertices[tissue]; 
nv=Length[v]; 
rv=Range[nv]; 

(* entanglement[e, v] returns True/Fals if v falls on edge *)

entangled[edgeNumber_, vertexNumber_]:= 
PointOnLineSegment[v[[e[[edgeNumber]]]], v[[vertexNumber]]];

(* entanglements[e] returns a list of the points that fall on edge e *)
entanglements[edgeNumber_]:=Pick[rv,entangled[edgeNumber, #]&/@rv];

(* unresolved[e] returns a list of vertices that fall on edge e but are not endpoints of e *)

unresolved[edgeNumber_]:= Complement[entanglements[edgeNumber], e[[edgeNumber]]]; 

unresolved/@Range[ne]
]


(* ::Input::Initialization:: *)
DisentangleVertices[tissue_?TissueQ]:= Module[{ ev, v, dbg=False, dPrint, e, ne, c, nc, entangled, rules, tnew},
dPrint[x___]:= If[dbg, Print[x]];  
v= TissueVertices[tissue]; 

e=TissueEdges[tissue];
e=Sort/@e; 
 
ne=Length[e]; 

c=TissueCells[tissue]; 
nc = Length[c]; 

ev=EntangledVertices[tissue];

entangled = (Length[#]>0)&/@ev; 
ev=Pick[ev, entangled]; 
entangled=Pick[Range[ne], entangled]; 

(* just fix the first one in each case; if there are multiple, come back and fix it on a recursive call *)

dPrint["ev: ", ev, " entangled: ", entangled];
MapThread[dPrint["edge ",#1, " is entangled by vertices ", #2]&, {entangled, ev}]; 

If[Length[ev]<1, 
dPrint["There are no entanglements remaining."]; 
Return[tissue]]; 

(* ... code to fix the first entanglements *)
Block[{edges, vertices, nextedge, nextvertex, nextvertices, p, q, new, new1, new2, pnew1, pnew2, ep, eq}, 
edges=entangled; 
vertices = ev; 
rules = {}; 

(* Loop through all problem edges *) 
While[Length[edges]>0,
nextedge = First[edges]; 
edges = Rest[edges]; 
nextvertices=First[vertices]; 
vertices=Rest[vertices];

(* Loop through all problem vertices on all problem edges *)

While[Length[nextvertices]>0,
nextvertex = First[nextvertices]; 
nextvertices=Rest[nextvertices];
{p, q} = e[[nextedge]];  
dPrint["Fixing edge ", nextedge," = ", {p, q},  " vertex ", nextvertex]; 
new =Sort/@( {nextvertex, #}&/@{p,q}); 
{new1, new2}=new; 
pnew1=Position[e,new1];
pnew2=Position[e, new2]; 

dPrint[".. new: ", new, " curently at positions ", pnew1, " and ", pnew2]; 

If[Length[pnew1]<1, 
e = Append[e, new1];
ep=Length[e]; ,
ep = pnew1[[1,1]]
]; 
If[Length[pnew2]<1, 
e = Append[e, new2];
eq=Length[e]; , 
eq  = pnew2[[1,1]];
]; 
AppendTo[rules, (nextedge-> {ep, eq})]; 
dPrint["rules: ", rules]; 

];  (*  End whlie Length[nextvertices] *)
True; 
];  (* End while Length[edges]>0*)
True; 
]; (* end Block *)

c= c/.rules; 
c= Flatten/@c; 

tnew = Tissue[v, e, c]; 
tnew = UndangleEdges[tnew]; 

Return[tnew]; 

]; 


(* ::Input::Initialization:: *)
SmootheCell[tissue_?TissueQ, cellNumber_?IntegerQ]:= 
SmootheCells[tissue, {cellNumber}]; 
SmootheCell[x___]:= (Print["Error: expecting SmootheCell[tissue, integer]"]; $Failed); 


(* ::Input::Initialization:: *)
SmootheCells[tissue_?TissueQ, {cellNumbers___?IntegerQ}, dbg_:False]:= Module[{c,v,e, nc, ne, bc,be,  cell,edges,dPrint, newEdge, newCell, vertices, sortedEdgeNumbers, cellNumber,newTissue, cn}, 
dPrint[x___]:= If[dbg, Print["SmoothCell: ", x]]; 

cn={cellNumbers}; 
If[Length[cn]==0, Return[tissue]]; 

newTissue=tissue; 

While[Length[cn]>0, 
cellNumber=First[cn];
cn=Rest[cn]; 

c=TissueCells[newTissue]; 
nc=Length[c];
e=TissueEdges[newTissue]; 
v=TissueVertices[newTissue]; 

AbortIf[Length[c]==0, "SmootheCells: no cells in tissue."]; 
AbortIf[Length[e]==0, "SmootheCells: no edges in tissue."];
AbortIf[Length[v]==0, "SmootheCells: no vertices in tissue."]; 

(* test for existing cell *)
AbortIf[cellNumber<1 \[Or] cellNumber>nc, 
"SmootheCells: attempt to remove cell "<>ToString[cellNumber]<>" failed in tissue with "<>ToString[nc]<>" cells (possible program error)."]; 

(* test for smoothable cell *)
bc = CellsOnBoundary[newTissue]; 

AbortIf[!MemberQ[bc, cellNumber], "SmootheCells: SmoothCell: Cell "<>ToString[cellNumber]<>" is not on the boundary."];

be=EdgesOnBoundary[newTissue]; 

(* first, cell gives the list of all edges in the cell *)

cell = c[[cellNumber]]; 
AbortIf[Length[cell]==0 , "SmootheCell: Cell "<>ToString[cellNumber]<>" ceased to exist (possible program error)."]; 
(* then cell gives the list of edge numbers in the cell on the boundary *)

cell = Intersection[cell, be]; 
AbortIf[Length[cell]==0 , "SmootheCell: Cell "<>ToString[cellNumber]<>"has no boundary edges."]; 

dPrint["edges on the boundary in cell ", cellNumber, ": ", cell]; 

(* now edges collects the vertices of the endpoints of these edges on the boundary *)

edges = e[[cell]]; 
dPrint["edge Vertex numbers in cell ", cellNumber, ": ", edges];

(* the following block picks up every vertex that is not shared by more than one edge *)

Block[{verticesInCellOnBoundary, keepers, uniqueVertices}, 
verticesInCellOnBoundary=Flatten[edges]; 
uniqueVertices=Union[verticesInCellOnBoundary];  
keepers = (Length[Position[verticesInCellOnBoundary, #]]<2)&/@uniqueVertices; 
newEdge = Pick[uniqueVertices, keepers]; 
newEdge=Sort[newEdge]; 
dPrint["vertices on new Edge: ", newEdge]; 
]; 

(* add the new edge *)
AbortIf[Length[newEdge]>2,"SmootheCell: Attempt to smoothe boundary on a cell that may have multiple disconnected boundary segments. Cell="<>ToString[cellNumber]<>" edges = "<>ToString[edges]<>" The algorithm has not been implemented to cover this case. It may have occured as a result of random number generation by Cellzilla. If this is the case then re-run the program. "];

e=Append[e, newEdge]; 
ne=Length[e]; 

newCell = Append[Complement[c[[cellNumber]], cell], ne]; 
vertices = e[[newCell]]; 


dPrint["Edges in revised cell ", cellNumber,":", newCell]; 
dPrint["Vertices in revised cell ", cellNumber, ":", vertices]; 

sortedEdgeNumbers="Edges"/.SortCellEdges[Range[Length[newCell]], vertices]; 
sortedEdgeNumbers=newCell[[sortedEdgeNumbers]]; 


dPrint["Sorted Edge numbers in revised cell ", cellNumber, ":", sortedEdgeNumbers]; 

(* modify the cell *)
c=ReplacePart[c, cellNumber-> sortedEdgeNumbers]; 


newTissue=Tissue[v,e,c]; 
];

newTissue=UndangleEdges[newTissue]; 
newTissue=UndangleVertices[newTissue]; (* added 2.1.\[Alpha].20 *)

Return[newTissue]; 
];

SmootheCells[tissue_?TissueQ]:= SmootheCells[tissue, CellsOnBoundary[tissue]]; 

SmootheCells[x___]:= (Print["Error: expecting SmootheCells[tissue, {integer, integer, ...}]"]; $Failed); 


(* ::Input::Initialization:: *)
ConnectionList[tissue_?TissueQ, opt___?OptionQ]:= Module[{c, clist, n, i, cell1, connections, cellnums, ut},
c=TissueCells[tissue];
clist={}; 
n=Length[c]; 
cellnums = Range[n]; 
For[i=1, i<= n, i++,
cell1=c[[i]]; 
connections=(Length[Intersection[cell1,#]]>0)&/@c;
connections=Pick[cellnums, connections]; 
connections=Complement[connections, {i}]; 
connections = {i,#}&/@connections; 
clist = Join[clist, connections]; 
]; 
clist=Sort[clist]; 
ut="UpperTriangular"/.{opt}/.{"UpperTriangular"-> False}; 
If[ut, clist = Select[clist, (#[[2]]>#[[1]])&]]; 
Return[clist]; 
]; 

ConnectionMatrix[tissue_?TissueQ, opt___?OptionQ]:= 
SparseArray[(#-> 1)&/@ConnectionList[tissue, opt]]; 
(*
Module[{clist, n, mat, i, p, q},
clist=ConnectionList[tissue,opt];
 n=NTissueCells[tissue]; 
mat=ConstantArray[0, {n,n}]; 
While[Length[clist]>0,
{p,q}=First[clist]; 
clist=Rest[clist]; 
mat[[p,q]]=1
]; 
Return[SparseArray[mat]]; 
];
*)


(* ::Input::Initialization:: *)
ConnectionList[torus_?TorusQ, opt___?OptionQ]:= Module[{c, clist, tissue, rules, incell, r, ut},
tissue = TorusTissue[torus]; 
c=TissueCells[tissue];
(* basic connection list *)
clist = ConnectionList[tissue, opt]; 

(* include also toroidal connections *)
rules = TorusRules[torus];

InCell[Rule[a_,b_]]:= {Position[c,a][[1,1]], Position[c,b][[1,1]]};
r=InCell/@rules; 
r=Sort[Join[r, Reverse/@r]];

clist = Join[clist, r];
clist = Sort[clist]; 

ut="UpperTriangular"/.{opt}/.{"UpperTriangular"-> False}; 
If[ut, clist = Select[clist, (#[[2]]>#[[1]])&]]; 


Return[clist]; 
]; 


ConnectionMatrix[torus_?TorusQ, opt___?OptionQ]:= 
SparseArray[(#-> 1)&/@ConnectionList[torus, opt]]; 
(*
Module[{clist, n, mat, i, p, q},
clist=ConnectionList[torus,opt];
 n=NTissueCells[TorusTissue[torus]]; 
mat=ConstantArray[0, {n,n}]; 
While[Length[clist]>0,
{p,q}=First[clist]; 
clist=Rest[clist]; 
mat[[p,q]]=1
]; 
Return[SparseArray[mat]]; 
];
*)


(* ::Input::Initialization:: *)
ConnectionList[x___]:= (Print["Error: Expecting ConnectionList[tissue]."]; $Failed); ConnectionMatrix[x___]:= (Print["Error: Expecting ConnectionMatrix[tissue]."]; $Failed); 


(* ::Input::Initialization:: *)
InLineVertices[tissue_?TissueQ, opt___?OptionQ]:= Module[{dbg, dPrint,v,e, nv,vn, VerticesInEdge, vie, candidates, removable, inline, vertices, ok},

dbg="Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["InLineVertices: ", x]]; 

vertices = "Vertices"/.{opt}/."Vertices"-> "All"; 

v=TissueVertices[tissue];
e=TissueEdges[tissue]; 
nv=Length[v]; 
vn=Range[nv];

If[Not[vertices=== "All"],
ok = ListQ[vertices] \[And] And@@(IntegerQ/@vertices);
If[ok, ok = ok \[And]And@@( (((#>= 0)\[And](#<= nv))&/@vertices))]; 
If[!ok, Print["Error: InLineVertices: Invalid \"Vertices\"=", vertices]; Return[$Failed]]; 
vn=vertices;
]; 

(* find vertices that topologically connect precisely two edges *)

VerticesInEdge[vertexNumber_]:= First/@Position[e,vertexNumber];
vie = VerticesInEdge/@vn;
vie = Transpose[{vn,vie}]; 
candidates=Select[vie, (Length[#[[2]]]==2)&];
dPrint["candidates: ", candidates];

removable[vnum_, {e1_,e2_}]:= Module[{v1,v2, edge1, edge2, onSeg },
edge1=e[[e1]];
edge2=e[[e2]]; 

v1=Complement[edge1, {vnum}][[1]]; 
v2=Complement[edge2, {vnum}][[1]]; 

onSeg = PointOnLineSegment[{v[[v1]], v[[v2]]}, v[[vnum]]];

dPrint["{v, v1, v2, onSeg}:", {vnum, v1,v2, onSeg}]; 
Return[onSeg]; 
];

inline=removable@@#&/@candidates;
(*candidates=First/@candidates;*)  
inline = Pick[candidates, inline]; 
Return[inline]; 
];
InLineVertices[x___]:=(Print["Error: Expecting InLineVertices[tissue]."];Return[$Failed];)


(* ::Input::Initialization:: *)
VertexNeighbors[tis_Tissue, n_]:=
Complement[Flatten[Select[TissueEdges[tis],MemberQ[#,n]&]],{n}];
VertexNeighbors[tis_Tissue]:= Module[{n},
n=NTissueVertices[tis];
VertexNeighbors[tis,#]&/@Range[n]
]; 
VertexNeighbors[x___]:= (Print["Expecting VertexNeighbors[tissue, integer]"]; Abort[]); 


(* ::Input::Initialization:: *)
CellNeighbors[tis_?TissueQ, p_?IntegerQ]:= Module[{rv, n}, 
n=NTissueCells[tis]; 
If[p>n \[Or] p<1, 
Print["Error: CellNeighbors: Requested Cell Number ", p, " does not exist. "];
Return[$Failed]; 
];
rv=Complement[Union[Flatten[Select[ConnectionList[tis], MemberQ[#, p]&]]], {p}];
Return[rv]
]; 
CellNeighbors[tis_?TorusQ, p_?IntegerQ]:= Module[{rv, n}, 
n=NTissueCells[TorusTissue[tis]]; 
If[p>n \[Or] p<1, 
Print["Error: CellNeighbors: Requested Cell Number ", p, " does not exist. "];
Return[$Failed]; 
];
rv=Complement[Union[Flatten[Select[ConnectionList[tis], MemberQ[#, p]&]]], {p}];
Return[rv]
]; 
CellNeighbors[tis_?TissueOrTorusQ]:= Module[{n, clist, nbrs},
n=NTissueCells[tis]; 
clist = ConnectionList[tis];
nbrs[p_]:= 
Complement[Union[Flatten[Select[clist, MemberQ[#, p]&]]], {p}];

Return[nbrs/@Range[n] ]
];
CellNeighbors[x___]:= (Print["Expecting CellNeigbors[tissue, n] or CellNeighbors[Torus, n]"]; Return[$Failed]); 


(* ::Input::Initialization:: *)
EdgeBetween[Q_?TissueQ, p_?IntegerQ, q_?IntegerQ]:= Module[{
c,nc,
edgeNumber}, 
c=TissueCells[Q]; 
nc=Length[c]; 
If[p>nc \[Or] q>nc \[Or] p<1 \[Or] q<1, 
Print["Error: EdgeBetween: invalid connection: ", {p,q}," there are only ", nc," cells."];
Return[$Failed]; 
];

edgeNumber = Intersection[c[[p]], c[[q]]]; 
If[Length[edgeNumber]>0, 
edgeNumber=edgeNumber[[1]]; 
Return[edgeNumber]]; 

Return[{}]; 
];
EdgeBetween[Q_?TorusQ, p_?IntegerQ, q_?IntegerQ]:= Module[{c, nc, edgeNumber, pos, InCell, trules, toroidalconnections, icc}, 
c=TissueCells[TorusTissue[Q]]; 
nc=Length[c]; 
If[p>nc \[Or] q>nc \[Or] p<1 \[Or] q<1, 
Print["Error: EdgeBetween: invalid connection: ", {p,q}," there are only ", nc," cells."];
Return[$Failed]; 
];

edgeNumber = Intersection[c[[p]], c[[q]]]; 
If[Length[edgeNumber]>0, edgeNumber=edgeNumber[[1]]; Return[edgeNumber]]; 

InCell[{a_,b_}]:= {Position[c,a][[1,1]], Position[c,b][[1,1]]};
trules=TorusRules[Q]; 
trules = List@@#&/@trules;
toroidalconnections=Sort[Join[trules, Reverse/@trules]];
icc=InCell/@toroidalconnections;

pos=Position[icc, {p,q}];
If[Length[pos]<1, Return[{}]]; 
pos = pos[[1,1]];

Return[Min[toroidalconnections[[pos]]]]
]
EdgeBetween[x___]:= (Print["Expecting EdgeBetween[tissue, i, j]"]; $Failed); 

EdgesBetween[Q_?TissueQ]:= Module[{
c, edge,  clist, edges}, 
c=TissueCells[Q]; 
clist = ConnectionList[Q]; 

edge[{p_, q_}]:= Module[{e},
e = Intersection[c[[p]], c[[q]]]; 
If[Length[e]>0, Return[First[e]]]; 
Return[0];  
];
edges = edge/@clist;
edges = MapThread[Rule, {clist, edges}]; 
If[Length[edges]>0, 
edges = SparseArray[edges]]; 
Return[edges]
];
EdgesBetween[Q_?TorusQ]:= Module[{c, clist,   edge, edges}, 
c=TissueCells[TorusTissue[Q]]; 
clist=ConnectionList[Q]; 

edge[{p_, q_}]:= Module[{edgeNumber, InCell, trules, toroidalconnections, pos, icc}, 
edgeNumber = Intersection[c[[p]], c[[q]]]; 
If[Length[edgeNumber]>0, edgeNumber=edgeNumber[[1]]; Return[edgeNumber]]; 
InCell[{a_,b_}]:= {Position[c,a][[1,1]], Position[c,b][[1,1]]};
trules=TorusRules[Q]; 
trules = List@@#&/@trules;
toroidalconnections=Sort[Join[trules, Reverse/@trules]];
icc=InCell/@toroidalconnections;

pos=Position[icc, {p,q}];
If[Length[pos]<1, Return[{}]]; 
pos = pos[[1,1]];

Return[Min[toroidalconnections[[pos]]]]
]; 


edges = edge/@clist;
edges = MapThread[Rule, {clist, edges}]; 
edges = SparseArray[edges]; 
Return[edges]

]



(* ::Input::Initialization:: *)
RemoveShortEdges[tis_Tissue, threshold_:0.01]:=Module[{dbg=False, dPrint, el, mean, tooshort, g, ne},
dPrint[x___]:= If[dbg, Print["RemoveShortEdges: ", x]]; 
g=tis; 

el = EdgeLengths[g]; 
mean = Mean[el]; 
ne=NTissueEdges[g]; 

tooshort = Pick[Range[ne], (#<threshold*mean)&/@el]; 
While[Length[tooshort]>0,
dPrint[tooshort]; 

g=MergeVertices[g, First[tooshort]]; 
el = EdgeLengths[g]; 
mean = Mean[el]; 
ne=NTissueEdges[g]; 
tooshort = Pick[Range[ne], (#<threshold*mean)&/@el]; 

];

Return[g];

];
RemoveShortEdges[x___]:= (Print["Expecting RemoveShortEdges[tissue, threshold]"]; Abort[]); 


(* ::Input::Initialization:: *)
CellEdgePairs[tissue_?TissueQ]:= Module[{ c, ntq},
ntq=Range[NTissueCells[tissue]];
c=TissueCells[tissue]; 
Join@@Transpose/@({Table[#,{Length[c[[#]]]}],c[[#]]}&/@ntq)
]


(* ::Input::Initialization:: *)
EdgesUsed[tissue_?TissueQ]:= Module[{e},
c=TissueCells[tissue];
e=Union[Flatten[c]]
];
EdgesUsed[DT_?DTissueQ]:= EdgesUsed[DTissue2Tissue[DT]]; 
VerticesUsed[tissue_?ISTissue]:= Module[{e,eu},
e=TissueEdges[tissue];
eu=EdgesUsed[tissue];
Union[Flatten[e[[eu]]]]
];


(* ::Input::Initialization:: *)
IntersectingEdges[T_?ISTissue, num_]:= Module[{notused,e,ne,edge},
e = TissueEdges[T]; 
ne=Length[e];
notused=Complement[Range[ne], EdgesUsed[T]]; 
edge=e[[num]];
Complement[
Pick[Range[ne],Map[Intersects[edge,#]&,e]],
notused,
{num}
]
]


(* ::Input::Initialization:: *)
BelowLine[pt_,pt1_,pt2_]:=Module[{m,y},m=(pt2[[2]]-pt1[[2]])/(pt2[[1]]-pt1[[1]]);
y=pt1[[2]]+m*(pt[[1]]-pt1[[1]]);
Return[pt[[2]]<y]];
AboveLine[x___]=Not[BelowLine[x]];

CellsAboveLine[T_?TissueQ, p1_, p2_]:= Module[{c, cells,n},
c=Centeroid[T]; 
cells=AboveLine[#,p1, p2]&/@c;
n=Length[c]; 
Pick[Range[n],cells]
];
CellsBelowLine[T_?TissueQ, p1_, p2_]:= Module[{c, cells,n},
c=Centeroid[T]; 
cells=BelowLine[#,p1,p2]&/@c;
n=Length[c]; 
Pick[Range[n],cells]
];
CellsAboveLine[x___]:= (Print["Expecting CellsAboveLine[Tissue, point1, point2]"]; Abort[]); 
CellsBelowLine[x___]:= (Print["Expecting CellsBelowLine[Tissue, point1, point2]"]; Abort[]); 
GetTissueAboveLine[T_?TissueQ, p1_, p2_]:= Module[{c,v,e,cn},
{v,e,c}=T/.{Tissue-> List}; 
cn=CellsAboveLine[T, p1,p2]; 
Tissue[v,e,c[[cn]]]
];
GetTissueAboveLine[x___]:= (Print["Expecting GetTissueAboveLine[Tissue, point1, point2]"]; Abort[]); 

GetTissueBelowLine[T_?TissueQ, p1_, p2_]:= Module[{c,v,e, cn},
{v,e,c}=T/.{Tissue-> List}; 
cn=CellsBelowLine[T, p1,p2]; 
Tissue[v,e,c[[cn]]]
];
GetTissueBelowLine[x___]:= (Print["Expecting GetTissueBelowLine[Tissue, point1, point2]"]; Abort[]); 




(* ::Input::Initialization:: *)
CellsInsidePolygon[T_?TissueQ,{vertices__?PointQ}]:= Module[{polygon, centers, inside,n},
polygon={vertices};
centers = Centeroid[T]; 
n=Length[centers]; 
(* if dim=3 do z-projection only *)
If[Length[centers[[1]]]>2, centers = Most/@centers]; 
inside=Inside[polygon, #]&/@centers;
Pick[Range[n], inside]
];

CellsInsidePolygon[x___]:= (Print["Expecting CellsInsidePolygon[tissue, {v1,v2,...}]"]; Abort[]); 

GetTissueInsidePolygon[T_?TissueQ, {vertices__?PointQ}]:= Module[{polygon, cip, v,e,c, c1}, 
polygon={vertices};
cip = CellsInsidePolygon[T, polygon]; 
{v,e,c}=T/.{Tissue-> List}; 
Tissue[v,e,c[[cip]]]
]; 

GetTissueInsidePolygon[x___]:= (Print["Expecting GetTissueInsidePolygon[Tissue, {v1,v2,..}]"]; Abort[]); 


(* ::Input::Initialization:: *)
Tissue2FlatTissue[T_?TissueQ]:= Module[{v,cvn},
v=TissueVertices[T];
cvn=CellVertexNumbers[T];
FlatTissue[v,cvn]
];
Tissue2FlatTissue[x___]:=( Print["Expecting[Tissue2FlatTissue[Tissue]]"]; Abort[]);


(* ::Input::Initialization:: *)
CVN2Edges[cvn_]:=Module[{makepairs,CellEdgePairs,edges,EdgePairToEdgeNumber,CellEdgePair2CellEdgeNumber,c},makepairs[{ijk__}]:=Sort/@Partition[{ijk},2,1,1];
CellEdgePairs=makepairs/@cvn;
edges=Union[Join@@CellEdgePairs];
EdgePairToEdgeNumber[{i_,j_}]:=Position[edges,{i,j}][[1,1]];
CellEdgePair2CellEdgeNumber[ceplist_]:=EdgePairToEdgeNumber/@ceplist;
c=CellEdgePair2CellEdgeNumber/@CellEdgePairs;
{edges, c}
]


(* ::Input::Initialization:: *)
FlatTissue2Tissue[F_FlatTissue]:=Module[{v,e,c, cvn},
{v,cvn}=F/.{FlatTissue-> List}; 
{e,c}=CVN2Edges[cvn]; 
Tissue[v,e,c]
]


(* ::Input::Initialization:: *)
TranslateTissue[T_Tissue,vector_?ListQ]:=Module[{v,e,c,dim, DX,DY,DZ,vnew},
{v,e,c}=T/.{Tissue-> List};
dim = Length[v[[1]]]; 
If[Length[vector]>0, DX=vector[[1]], DX=0];
If[Length[vector]>1, DY=vector[[2]], DY=0];
If[Length[vector]>2, DZ=vector[[3]], DZ=0];
Switch[dim,
2,vnew = ({DX,DY}+#)&/@v,
3, vnew = ({DX,DY,DZ}+#)&/@v,
_, Print["TranslateTissue: Invalid dimension = ", dim]; Abort[]; 
];
Tissue[vnew,e,c]
];
TranslateTissue[x___]:=(Print["Expecting TranslateTissue[Tissue, vector]"]; Abort[]);


(* ::Input::Initialization:: *)
TranslateToOrigin[T_?TissueQ]:= Module[{v,C},
v=TissueVertices[T]; 
C=Mean[v];
TranslateTissue[T,-C]
];
TranslateToOrigin[x___]:=(Print["Expecting TranslateToOrigin[Tissue]"]; Abort[])



(* ::Input::Initialization:: *)
RotateTissue[T_Tissue, degrees_]:= Module[{v,e,c,dim, radians, R, vnew},
{v,e,c}=T/.{Tissue-> List};
dim = Length[v[[1]]]; 
radians = degrees * Pi/180.0;
Switch[dim, 
2, R=RotationMatrix[radians],
3, R=RotationMatrix[radians, {0,0,1}],
_,Print["RotateTissue: Invalid dimension = ", dim]; Abort[];
];
vnew = Map[R.#&, v];
Tissue[vnew, e,c]
];
RotateTissue[x___]:=(Print["Expecting RotateTissue[Tissue, AngleInDegrees]"]; Abort[])


(* ::Input::Initialization:: *)
ReflectTissue[T_Tissue, "y"]:= Module[{v,e,c, dim, mult},
{v,e,c}=T/.{Tissue-> List};
dim=Length[v[[1]]]; 
Switch[dim, 
2, mult={-1,1}, 
3, mult={-1,1,1},
_, Print["ReflectTissue: invalid dimension ", dim]; 
Abort[]
]; 
v = mult*#&/@v;
Tissue[v,e,c]
];
ReflectTissue[T_Tissue, "x"]:= Module[{v,e,c, dim, mult},
{v,e,c}=T/.{Tissue-> List};
dim=Length[v[[1]]]; 
Switch[dim, 
2, mult={1,-1}, 
3, mult={1,-1,1},
_, Print["ReflectTissue: invalid dimension ", dim]; 
Abort[]
]; 
v = mult*#&/@v;
Tissue[v,e,c]
];
ReflectTissue[x___]:= (Print["Expecting ReflectTissue[Tissue, axis] where axis is \"x\" or \"y\""]; Abort[]); 


(* ::Input::Initialization:: *)
BoundaryCell[T_?TissueQ]:= Module[{v,e,c,be,sce, coords},
{v,e,c}=T/.{Tissue-> List}; 
be=EdgesOnBoundary[T];
sce = SortCellEdges[be,e];
coords = v[["Vertices"/.sce]];
Return[
Prepend[sce, "Coordinates"-> coords]
]
];
BoundaryCell[x___]:= (Print["Expecting BoundaryCell[Tissue]"]; Abort[]); 


(* ::Input::Initialization:: *)
NeighborQ[T_?TissueQ, {n1_, n2_}]:= Module[{cl},
cl=ConnectionList[T];
cl=Select[cl, MemberQ[#,n1]&];
Or@@(MemberQ[#,n2]&/@cl)
]


(* ::Input::Initialization:: *)
MergeCells[T_?TissueQ,n_?ListQ]:= Module[{v,e,c,bl,T1,ncells, nlist},
{v,e,c}=T/.{Tissue-> List}; 
T1=Tissue[v,e,c[[n]]];
bl="Edges"/.BoundaryCell[T1]; 
ncells=Length[c]; 
nlist=List/@n; 
AbortIf[ncells<#,"MergeCells: Possible Program Error: Attempt to delete cell "<>ToString[#]<>" from tissue with total of "<>ToString[ncells]<>" cells"]&/@nlist;
Tissue[v,e,Append[Delete[c,nlist], bl]]
]


(* ::Input::Initialization:: *)
SharedWall[T_?TissueQ, p_Integer, q_Integer]:= Module[{v,e,c,nc, cell1, cell2, common, edge,pairs, hasBV,VoB,VoE, Vall, cvnp,cvnq, overlap,overlaplist,done,i, edges, vertices},
{v,e,c}=T/.{Tissue-> List};
nc = Length[c];
AbortIf[(p>nc) \[Or] (q > nc) \[Or](p<0) \[Or] (q<0), "SharedWall: Invalid cell number."]; 
cell1 = c[[p]];
cell2 = c[[q]]; 
common={};
While[Length[cell1]>0,
edge = First[cell1];
cell1=Rest[cell1]; 
If[MemberQ[cell2,edge], common=Append[common,edge]]; 
];
pairs = e[[common]];

(* overlap returns true if all exists intersection *)
overlap[l1_,l2_]:=  Length[Intersection[l1,l2]]>0; 
(* overlaplist returns true if l={l1,l2,l3,...} and there is an overlap
between every pair of adjacent sublists (l1,l2), (l2,l3),... *)
overlaplist[l_]:=And@@(overlap@@#&/@Partition[l,2,1]);

done=False;i=0;
While[Not[done],
If[overlaplist[pairs],
Break[],
pairs = RotateRight[pairs,1];

];
i=i+1;
If[i>Length[pairs],Print["Error: SharedWall:unable to sort segments"];  Break[]]; 
]; 

edges = Position[e,#][[1,1]]&/@pairs;

vertices={}; 
Block[{firstpair,secondpair,pairlist,v1,v2}, 
pairlist=pairs;
firstpair=pairlist[[1]];
{v1,v2}=firstpair;
If[Length[pairlist]>1,
secondpair=pairlist[[2]];
If[MemberQ[secondpair,v1],vertices={v2,v1},vertices={v1,v2}];
pairlist=Rest[pairlist];
While[Length[pairlist]>0,firstpair=pairlist[[1]];pairlist=Rest[pairlist];
{v1,v2}=firstpair;
If[MemberQ[vertices,v1],AppendTo[vertices,v2],AppendTo[vertices,v1]];
];
,
vertices=firstpair
];


];
 

{"Edges"-> edges, "Vertices"-> vertices, "Coordinates"-> v[[vertices]]}

];
SharedWall[x___]:= (Print["Expecting SharedWall[Tissue, cellnumber1, cellnumber2]"]; Abort[]); 


(* ::Input::Initialization:: *)
L1Cells[T_Tissue, opt___?OptionQ]:= Module[{bottom, bc, centroids, OK, L1, RMIN, allcenters, BOTTOM, CBOT, xCBOT, xr, xl},
bottom="Bottom"/.{opt}/.{"Bottom"-> Automatic};
RMIN = "MinimumRadius"/.{opt}/.{"MinimumRadius"-> 0}; 
If[ToString[bottom]== "Automatic", bottom = 0 (*Sqrt[Mean[areafunction[T]]]*)]; 
bc=CellsOnBoundary[T]; 
allcenters=centroids=Centroid[T];
If[bottom>-Infinity,
BOTTOM=CellsOnBottom[T];
CBOT=centroids[[BOTTOM]]; 
xCBOT=First/@CBOT; 
(* join left & right bottom corners *)
xr=BOTTOM[[Ordering[xCBOT,-1]]][[1]];
xl=BOTTOM[[Ordering[xCBOT,1]]][[1]]; 
L1= Join[Complement[bc, BOTTOM] , {xl,xr}]; 
(* 
centroids = centroids[[#]]&/@bc; 
OK = (#[[2]]>bottom)&/@centroids;
Pick[bc, OK]*)
,
L1=bc
];

(* weed out a central "hole" - only works if the hole is in the center *)
If[RMIN>0, 
allcenters=Norm/@allcenters; 
allcenters = allcenters[[#]]&/@L1; 
OK = (#>RMIN)&/@allcenters; 
L1=Pick[L1, OK]; 
]; 

Return[L1];
];

L1Cells[DT_DTissue, opt___?OptionQ]:= Module[{T, cells,rules},
T=DTissue2Tissue[DT]; 
cells=L1Cells[T,opt];
rules = StaticToDynamicNumberRules[DT]; 
cells/.rules
];

L1Cells[x___]:= AbortIf[True, "Error: Expecting L1Cells[Tissue] or L1Cells[DTissue]"]; 


(* ::Input::Initialization:: *)
L2Cells[T_Tissue, opt___?OptionQ]:= Module[{L1,L1CellEdges, bc, c, L2, e, v, LRest,n, cellnumber, celledges,ISL2,dbg=False, dPrint},
dPrint[u___]:= If[dbg, Print["L2Cells: ", u]]; 
L1=L1Cells[T,opt]; 
(* bc=CellsOnBoundary[T]; *)
{v,e,c}=T/.{Tissue-> List}; 
n=Length[c]; 
LRest=Range[n];
(* LRest=Complement[LRest,bc]; *)
LRest=Complement[LRest, L1];  
L2={};
L1CellEdges=c[[L1]]; 
dPrint["L1: ", L1]; 
dPrint["L1CellEdges: ", L1CellEdges]; 
dPrint["LRest: ", LRest]; 
While[Length[LRest]>0,

cellnumber=First[LRest]; 
LRest=Rest[LRest];
celledges=c[[cellnumber]];
ISL2=Or@@( Length[Intersection[celledges, #]]>0&/@L1CellEdges); 
dPrint["Checking cell ", cellnumber, " ISL2=", ISL2]; 

If [ ISL2, AppendTo[L2, cellnumber]];
];
L2
];

L2Cells[DT_DTissue, opt___?OptionQ]:= Module[{T, cells,rules},
T=DTissue2Tissue[DT]; 
cells=L2Cells[T,opt];
rules = StaticToDynamicNumberRules[DT]; 
cells/.rules
];

L2Cells[x___]:= AbortIf[True, "Error: Expecting L2Cells[Tissue] or L1Cells[DTissue]"]; 


(* ::Input::Initialization:: *)
Polygonalize[T_,threshold_: .5]:=Module[{c,v,e,cvn,nv,p,p3,RepeatedVertices,vp,n,r,PolyCell,newcells,F,Tnew,BC,IC,AIC,ABC,toosmall, dbg=False, dPrint, degen},
dPrint[u___]:= If[dbg, Print["Polygonzlize:", u]]; 
{v,e,c}=T/.{Tissue->List};
dPrint["extracting Cell Vertex Numbers (may take a while) ... "];
cvn=CellVertexNumbers[T];
nv=Length[v];
dPrint[nv," vertices found in original tissue."];
(*find all the vertices in at least 3 cells*)p=Table[{j,Position[cvn,j]},{j,1,nv}];
p3=Select[p,Length[#[[2]]]>2&];
(*numbers of the Repeated Vertices*)RepeatedVertices=First/@p3;
n=Length[RepeatedVertices];
dPrint[n," corner vertices found."];
(*vertex conversion rules*)
dPrint["Determining conversion rules ..."];
r=MapThread[Rule,{RepeatedVertices,Range[n]}];
(*vertex coordinates of the repeated vertices*)dPrint["Extracting new vertex coordinates ..."];
vp=v[[RepeatedVertices]];
(*Cell as least of vertices*)PolyCell[cellVertexNumbers_]:=(Select[cellVertexNumbers,MemberQ[RepeatedVertices,#]&])/.r;
dPrint["Determining Polygonal cell vertices in new coordinates."];

newcells=PolyCell/@cvn;
dPrint["Generating Flat Tissue."];
F=FlatTissue[vp,newcells];
dPrint["Converting to Tissue."];
Tnew=FlatTissue2Tissue[F];
BC=CellsOnBoundary[Tnew];
IC=Complement[Range[Length[newcells]],BC];
AIC=Mean[areafunction[Tnew,IC]];
dPrint["Deleting cells smaller than ",threshold*AIC];
ABC=areafunction[Tnew,BC];
toosmall=Pick[BC,(#<threshold*AIC)&/@ABC];
{v,e,c}=Tnew/.{Tissue->List};
c=Delete[c,List/@toosmall];

dPrint["Removing degenerate cells"]; 
c=Select[c, Length[#]>2&]; 

Tnew=Tissue[v,e,c]

]


(* ::Input::Initialization:: *)
DelaunayEdges[{vertices__?numPairQ}]:= Module[{dt,xy, pairup, edges, edgeCoords},
xy={vertices}; 

(* 
pairup[{v1_, {vlist__}}]:= {v1,#}&/@{vlist}; 
dt= DelaunayTriangulation[xy];
edges = Union[Sort/@Join@@(pairup/@dt)];
*)
edges=DelaunayPairs[xy]; 

edgeCoords [{i_, j_}]:= {xy[[i]], xy[[j]]}; 
edges = edgeCoords/@edges
];
DelaunayEdges[x___]:= (Print["Expecting DelaunayEdges[{{x,y},{x,y},...}]"]; $Failed); 


(* ::Input::Initialization:: *)
DelaunayPairs[{vertices__?numPairQ}]:= Module[{dt,xy, pairup, pairs},
xy={vertices}; 
pairup[{v1_, {vlist__}}]:= {v1,#}&/@{vlist}; 

dt= DelaunayTriangulation[xy];

pairs = Union[Sort/@Join@@(pairup/@dt)];
Return[pairs];
];
DelaunayPairs[x___]:= (Print["Expecting \!\(\*
StyleBox[\"DelaunayPairs\",\nFontWeight->\"Plain\"]\)[{{x,y},{x,y},...}]"]; $Failed); 


(* ::Input::Initialization:: *)
DelaunayMean[{vertices__?numPairQ}]:= Module[{xy,  edges,  dmean},
edges = DelaunayEdges[{vertices}]; 
If[SameQ[edges, $Failed], Return[$Failed]]; 
dmean = Mean[Norm/@(Subtract@@#&/@edges)];
Return[dmean]; 
];
DelaunayMean[x___]:= (Print["Expecting DelaunayMean[{{x,y},{x,y},...}]"]; $Failed); 


(* ::Input::Initialization:: *)
ConvexHullVertices[points_]:= Module[{ch},
ch=ConvexHull[points];
ch=points[[ch]]
]


(* ::Input::Initialization:: *)
GenerateBoundaryLayer[pointsInput_, opt___?OptionQ]:= Module[{chull, diameter, dbg, dPrint, points},
dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["GenerateBoundaryLayer: ", x]]; 

chull=ConvexHullVertices[pointsInput];
chull = Append[chull, First[chull]]; 

diameter = DelaunayMean[pointsInput]; 
dPrint["diameter: ", diameter]; 

(* block extracted from mPower 1.0 *)
Block[{hull, hullminus, hullplus,  pminus, pplus, p, vplus, vminus, pnew, v, endpoints,p1, p2, additionalpoints, d, n, rn, rpt, rpts}, 

hullminus=Most[chull];
hull=Rest[chull];
hullplus=Append[Drop[chull,2],chull[[2]]];

(*generate points directly out from convex hull*)
points={};
While[Length[hullminus]>0,
pminus=First[hullminus];
hullminus=Rest[hullminus];
pplus=First[hullplus];
hullplus=Rest[hullplus];
p=First[hull];
hull=Rest[hull];
vplus=(p-pminus)/Norm[p-pminus]; 
vminus = (p-pplus)/Norm[p-pplus]; 
v=(vplus+vminus)/Norm[vplus+vminus]; 
pnew=p+diameter*v;
points=Append[points,pnew];
]; (* end of While Length hullminus *)
dPrint["points: ", points]; 


endpoints=Append[points,First[points]];
p2=First[endpoints];
endpoints=Rest[endpoints];
additionalpoints={};

While[Length[endpoints]>0,
p1=p2;
p2=First[endpoints];
endpoints=Rest[endpoints];
d=distance[p1,p2];
If[d>diameter,
v=(p1-p2)/Norm[p1-p2]; 
n=Round[d/diameter+1];
pnew=Range[n-1]*(d/n);

pnew=(p2+v*#)&/@pnew;

(* add in a minute randomization *)
rn:= 0.01*RandomReal[{-diameter, diameter}]; 
rpt:= {rn, rn}; 
rpts = Table[rpt, {Length[pnew]}]; 
pnew = pnew + rpts; 

additionalpoints=Join[additionalpoints,pnew];
]; (* end If d> diameter*)
]; (* end While Length endpoints *)
points = Join[points, additionalpoints]; 
dPrint["points: ", points]; 
]; (* end of block from mPower 1.0 *)

(* sort points, since its convex *)
Block[{cen, angles, vecs}, 
cen = Centroid[points]; 
vecs =(#-cen)&/@points;
angles = ArcTan@@#&/@vecs; 
points = Transpose[{angles, points}]; 
points = Sort[points]; 
points = Transpose[points][[2]]; 

]; 
Return[points];
]


(* ::Input::Initialization:: *)
BoundedCellVoronoi[{centers__?numPairQ}, opt___?OptionQ]:= Module[{bl, xy, pts, boundary, bv, n,dPrint,dbg, v,c, vall, tiss},
dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg , Print["BoundedCellVoronoi: ", x]]; 
xy={centers}; 
n=Length[xy]; 
bl = GenerateBoundaryLayer[xy]; 
pts = Join[xy, bl]; 
boundary=bl[[ConvexHull[bl]]];
bv = BoundedDiagram[boundary, pts];
{v, c}=bv; 
c=Last/@Take[c, n];
dPrint["c: ", c]; 
vall = Union[Flatten[c]]; 
dPrint["vall: ", vall];
vall=v[[vall]]; 
dPrint["vall (2):", vall]; 
c=v[[#]]&/@c;
dPrint["c (2): ", c]; 
tiss=CellsByVertexToTissue[vall,c]; 
tiss
];
BoundedCellVoronoi[x___]:= (Print["Expecting BoundedCellVoronoi[{point, point, ...}]"]; $Failed); 


(* ::Input::Initialization:: *)
PrunedDelaunayPairs[{points__?numPairQ}, opt___?OptionQ]:= Module[
{dt, cl, w, udt},
dt = DelaunayPairs[{points}]; 
w=BoundedCellVoronoi[{points}]; 
cl = ConnectionList[w]; 
udt = Intersection[cl, dt]
];
PrunedDelaunayEdges[{points__?numPairQ}, opt___?OptionQ]:= Module[
{dt, xy, edgeCoords, edges},
xy={points}; 
 dt= PrunedDelaunayPairs[xy];
edgeCoords [{i_, j_}]:= {xy[[i]], xy[[j]]}; 
edges = edgeCoords/@dt;
Return[edges]; 
];


(* ::Input::Initialization:: *)
RandomizeTemplate[q_?TissueQ, rand_:0]:=Module[
{qq, e, v, nv,c, el, r, rn, lengths, directions, offsets},
If[rand>0,
c=TissueCells[q]; 
v=TissueVertices[q];
nv=Length[v]; 
e=TissueEdges[q];
el=Mean[EdgeLengths[q]]; 
r=rand;
If[rand>.25, 
r=.25; 
Print["Warning: RandomizeTemplate: randomization truncated to 25%."]]; 
r=r*el;
lengths = Table[RandomReal[{0,r}], {nv}]; 
directions={Cos[#], Sin[#]}&/@Table[RandomReal[{0,2Pi}], {nv}]; 
offsets = lengths*directions; 
v=v+offsets;
qq=Tissue[v,e,c];
,
qq=q]; 
Return[qq]]; 


(* ::Input::Initialization:: *)
TemplateHoneycombCover[xmax_, ymax_]:= Module[{oddxcenters, evenxcenters, centers, y, even, thesecenters, unithex,hexat, v, vcells, vertexNumber, CellsByVertexNumber, cellbyvertex, cellsByEdgePair, edges, cellsByEdgeNumber, edgeNumber},

unithex={Cos[#],Sin[#]}&/@Most[Range[0,2 Pi,Pi/3]];
hexat[{xc_, yc_}]:= {xc,yc}+#&/@unithex; 

(* calculate centers of hexagons *)

oddxcenters = Range[0, xmax, 3];
evenxcenters=Range[3/2, xmax, 3]; 
y=-Sqrt[3]/4;
even=False; 
centers={}; 
While[y<= ymax+Sqrt[3]/4,
If[even, 
thesecenters=evenxcenters,
thesecenters=oddxcenters]; thesecenters = {#,y}&/@thesecenters; 
even=Not[even]; 
y=y+Sqrt[3]/2;
centers = Join[centers, thesecenters]; 
]; 

(* define v as the unique vertices *)

vcells=hexat/@centers;
v=Union[Flatten[vcells,1]];

(* determine cells by vertex numbers *)

Return[CellsByVertexToTissue[v, vcells]]; 
]


(* ::Input::Initialization:: *)
TemplateRectangular[nx_, ny_]:= Module[{dbg, dPrint, x,y, v, i, j, bl, br, tr, tl, cvc, cells, tiss},
dPrint[x___]:= If[dbg, Print["TemplateRectangular: ", x]]; 

v=Flatten[Table[{i,j},  {j, 0, ny}, {i, 0, nx}], 1];
dPrint["v: ", v]; 
i=1; cells={}; 
For[y=0, y< ny,y++, 
For [x=0, x< nx,x++, 
bl=1+ y*(nx+1)+x; 
br=bl + 1; 
tr = br+nx+1; 
tl = tr-1; 
cvc = v[[{bl,br, tr, tl}]]; 
dPrint["cell: {x,y}=",i,":", {x,y}, ", bottom:", bl, ",", br, " top: ", tr, ",", tl];
i++;
AppendTo[cells, cvc]; 
]
]; 
tiss=CellsByVertexToTissue[v, cells];
Return[tiss]; 
];
TemplateRectangular[{x0_,xmax_, dx_}, {y0_, ymax_, dy_}]:= Module[{nx, ny, tiss, X, Y, V, v, c, e},
(* generate the tissue on [0, nx+1] \[Times] [0,ny+1] *)

nx = (xmax-x0)/dx;
ny=(ymax-y0)/dy;
tiss=TemplateRectangular[nx, ny];

(* transform to [x0, xmax] \[Times] [y0, ymax] *)

X[x_]:= x0 + x*(xmax-x0)/nx; 
Y[y_]:= y0 + y * (ymax-y0)/ny;
V[{x_, y_}]:= {X[x], Y[y]}; 
v=TissueVertices[tiss]; 
e=TissueEdges[tiss]; 
c=TissueCells[tiss]; 
v=V/@v;
tiss=Tissue[v,e,c]; 
Return[tiss]; 
];
TemplateRectangular[x___]:= (Print["Expecting TemplateRectangular[nx,ny] or TemplateRectangular[{xmin,xmax,dx}, {ymin,ymax,dy}]"]; Abort[]);


(* ::Input::Initialization:: *)
TemplateRectangularCover[xmax_, ymax_, \[CapitalDelta]x_, \[CapitalDelta]y_, offset_:(1/2), dbg_:False]:= Module[
{n, oddxcenters, evenxcenters, centers, y, even, data, corners, rectangleAt, rline, v, vcells, q, outsiders, dPrint},

dPrint[x___]:= If[dbg, Print["TemplateRectangularCover: ", x]]; 
t1=TimeUsed[]; 

corners = {{-\[CapitalDelta]x/2, \[CapitalDelta]y/2}, {\[CapitalDelta]x/2, \[CapitalDelta]y/2}, {\[CapitalDelta]x/2, -\[CapitalDelta]y/2}, {-\[CapitalDelta]x/2, -\[CapitalDelta]y/2}}; 
rectangleAt[{xc_, yc_}]:=( {xc, yc}+#)&/@corners; 

(* determine centers of rectangles *)

n=xmax/\[CapitalDelta]x;
oddxcenters=Range[-\[CapitalDelta]x, xmax+\[CapitalDelta]x/2, \[CapitalDelta]x];
If[Length[oddxcenters]<n, 
AppendTo[oddxcenters, \[CapitalDelta]x]]; 
 evenxcenters =( \[CapitalDelta]x*offset)+#&/@oddxcenters; 
centers={}; 
y=0; 
even=False; 
While[y<=ymax+\[CapitalDelta]y, 
If[even, data = evenxcenters, data = oddxcenters]; 
data = {#, y}&/@data; 
AppendTo[centers, data]; 
y = y+ \[CapitalDelta]y; 
even=Not[even]
]; 
dPrint["centers: ", TimeUsed[]-t1]; 
t2=TimeUsed[]; 

(** NOTE THERE WILL BE SOME VERTICES THAT ARE IN SOME CELLS THAT ARE NOT ON CORNERS!!! **)
(** NEED TO FIX THIS!!! **)

(* determine corners of rectangles *)
rline[x_]:= rectangleAt/@x; 
v=Map[rline, centers];
(* list of cells as vertex coordinates *)
vcells = Join@@v;
(* list of unique vertices *)
v=Union[Join@@vcells];

(* ... continue as with hexagons  ... *) 
(* determine cells by vertex numbers *)
dPrint["v: ", TimeUsed[]-t2]; 

t3=TimeUsed[]; 
q=CellsByVertexToTissue[v, vcells];
dPrint["q: ", TimeUsed[]-t3]; 
t4=TimeUsed[]; 

(* remove any cells that manage to lie completely outside the desired cover *)

outsiders = OutsideBox[CellVertexCoordinates[q, #], {{0, 0}, {xmax, 0}, {xmax, ymax}, {0, ymax}}]&/@Range[NTissueCells[q]]; 
outsiders = Pick[Range[NTissueCells[q]], outsiders]; 
dPrint["Finding Outsiders: ", TimeUsed[]-t4]; 
dPrint["There are " ,Length[outsiders], " outsiders."]; 
 t5=TimeUsed[]; 

If[Length[outsiders]>0, 
q=RemoveCell[q, outsiders]]; 

(* Fix vertices that were skipped because of edge offset *)
dPrint["Removing Outsiders: ", TimeUsed[]-t5]; 

dPrint["There are ", Length[EntangledVertices[q]], " entanglements."]; 
t6=TimeUsed[]; 
q= DisentangleVertices[q];
dPrint["Disentangling: ", TimeUsed[]-t6]; 
dPrint["Total time: ", TimeUsed[]-t1]; 
 
Return[q]; 
]


(* ::Input::Initialization:: *)
CellsByVertexToTissue[v_, vcells_]:= Module[
{vertexNumber, cellbyvertex, CellsByVertexNumber, cellsByEdgePair, edges, edgeNumber, cellsByEdgeNumber}, 
vertexNumber[{xc_, yc_}]:= Position[v, {xc, yc}][[1, 1]]; 
cellbyvertex[{xy__?numPairQ}]:= vertexNumber/@{xy}; 
CellsByVertexNumber=cellbyvertex/@vcells; 

(* determine cells by edge number*)

cellsByEdgePair=Map[Partition[#,2,1,1]&, CellsByVertexNumber]; 

edges = Join@@cellsByEdgePair; 
edges = Sort/@edges;
edges = Union[edges]; 

cellsByEdgePair = Map[Sort/@#&, cellsByEdgePair];
edgeNumber[{i_, j_}]:= Position[edges, {i,j}][[1,1]]; 
cellsByEdgeNumber=Map[edgeNumber/@#&, cellsByEdgePair];

(*
{"v"\[Rule] v, "vcells"\[Rule] vcells, "cells"\[Rule] CellsByVertexNumber, "edges"\[Rule] edges, "cellsByEdgePair"\[Rule]cellsByEdgePair, 
"cellsByEdgeNumber"\[Rule] cellsByEdgeNumber};
*)

Tissue[v, edges, cellsByEdgeNumber]
];
 


(* ::Input::Initialization:: *)
CellVerticesToTissue[vcells_]:= CellsByVertexToTissue[Union[Join@@vcells], vcells]; 



(* ::Input::Initialization:: *)
TemplateCircularHoneycomb[layers_, area_]:= Module[{q, mult,hexarea=(3.0 Sqrt[3])/2, v, e, c},
q=TemplateCircularHoneycombCover[layers]; 
mult = 1.0* Sqrt[area/hexarea];
v=mult*TissueVertices[q];
e=TissueEdges[q];
c=TissueCells[q];
Tissue[v,e,c]
]


(* ::Input::Initialization:: *)
TemplateCircularHoneycombCover[radius_, mode_:-1]:= Module[{oddxcenters, evenxcenters, centers, y, even, thesecenters, unithex,hexat, v, vcells, vertexNumber, CellsByVertexNumber, cellbyvertex, cellsByEdgePair, edges, cellsByEdgeNumber, edgeNumber, r, topcenters, bottomcenters, tissue, semicircle, allthesecenters},

If[IntegerQ[mode], 
semicircle = (mode>= 0);
, 
Print["Error: TemplateCircularHoneycombCover: expecting an integer > for mode (-1: circle; or # rows to add to bottom)"];
semicircle=False; 
]; 

unithex={Cos[#],Sin[#]}&/@Most[Range[0,2 Pi,Pi/3]];
hexat[{xc_, yc_}]:= {xc,yc}+#&/@unithex; 

(* calculate centers of hexagons *)

evenxcenters = Range[0, radius+3/2, 3]; 
evenxcenters = Join[evenxcenters, -evenxcenters]//Union;
oddxcenters = Range[3/2, radius +  3/2, 3]; 
oddxcenters = Join[oddxcenters, -oddxcenters]//Union; 

y=0; 
even=True; 
centers={}; 
i=0; 
While[y<=radius+Sqrt[3]/2,
If[even, 
thesecenters=evenxcenters,
thesecenters=oddxcenters]; 
allthesecenters=thesecenters; 

thesecenters = Select[thesecenters, (#^2 < (radius+1)^2 - y^2)&]; 
topcenters = {#,y}&/@thesecenters; 

(* if a circle, odd the bottom half *)

If[i>0 ,
If[ !semicircle, 
bottomcenters={#,-y}&/@thesecenters; ,

(* if a semicircle, don't add bottom half of circle *)
(* but do add a flat line if requested *)
(* # of lines = mode *)

If[i<=mode, 
bottomcenters = {#, -y}&/@allthesecenters; ,
 bottomcenters={}
]; 
];
, 
bottomcenters={} 
]; 


even=Not[even]; 
y=y+Sqrt[3]/2;
i=i+1; 
centers = Join[centers, topcenters, bottomcenters]; 
]; 

(* define v as the unique vertices *)

vcells=hexat/@centers;
v=Union[Flatten[vcells,1]];

(* determine cells by vertex numbers *)
tissue = CellsByVertexToTissue[v, vcells];


Return[tissue]; 
]


(* ::Input::Initialization:: *)
TemplateRing[n_, R_, A_]:= Module[{r, Amax, v,c,e},
Amax = Pi*R^2/n; 
If[A >Amax, Print["Error: incompatible input {n,R,A}=", {n,R,A}, "\nTo fit this many cells the area must be at most ", Amax];
Abort[]; 
];  
r=Sqrt[R^2 - n*A/(Pi)];

v = Join[
Table[{r*Cos[(k*2.0*Pi/n)], r*Sin[k*2.0*Pi/n]}, {k,0,n-1}],
Table[{R*Cos[(k*2.0*Pi/n)], R*Sin[k*2.0*Pi/n]}, {k,0,n-1}]
];
e=Join[Partition[Range[1,n],2,1,1],
Partition[Range[n+1, n+n], 2, 1, 1],
Table[{k,k+n}, {k, 1, n}]];
c= Append[Table[{k, 2n+1+k, n+k, 2n+k},{k, 1,n-1}],
{n, 2n+1, 2n, 3n}
];
(* Tissue[v,e,c] *)
Return[Tissue[v,e,c]]
]


(* ::Input::Initialization:: *)
TemplateRandom[npoints_?IntegerQ, {xy__?numPairQ}, opt___?OptionQ]:= Module[{rx, ry, xmax, ymax, xmin, ymin, i, points,point, itotal, bvd, trace=True, tPrint,  v, val, cells, e, c, cellEdges, boundary, q},

trace = "Debug"/.{opt}/.{"Debug"-> False}; 

tPrint[x___]:= If[trace, Print["TemplateRandom: ", x]]; 

boundary={xy}; 

(* generate random centers *)

xmin = Min[First/@boundary]; 
xmax = Max[First/@boundary]; 
ymin=Min[Last/@boundary]; 
ymax = Max[Last/@boundary];
rx:= RandomReal[{xmin, xmax}]; 
ry:= RandomReal[{ymin, ymax}]; 

i=itotal=0; 
points={}; 
While[i<npoints \[And] itotal<10^5,
itotal++; 
point = {rx, ry}; 
If[Inside[boundary, point], 
i++; 
AppendTo[points, point]; 
]; 
]; 
tPrint[i, " points generated ", 100.0*i/itotal,"% success rate."];

(* tPrint["boundary: ", boundary]; 
tPrint["points: ", points]; *)
(* generate Bounded Voronoi *)

tPrint["Generating Bounded Voronoi .. "]; 
bvd = BoundedDiagram[boundary, points];

{v, val} = bvd; 

tPrint[Length[v], " vertices"]; 
tPrint[Length[val], " cells"]; 

(* list of cells as vertex numbers *)

cells =Last/@ val;

(* list of cells edges as vertex pair numbers *)

cellEdges = Partition[#, 2, 1, 1]&/@cells; 
 cellEdges = Map[Sort/@#&, cellEdges]; 


e = Union[Join@@cellEdges];

Block[{edgeNumber, edgeNumbers}, 
edgeNumber[{i_, j_}]:= Position[e, {i,j}][[1, 1]]; 
edgeNumbers[{ijpair__}]:= edgeNumber/@{ijpair}; 
c=edgeNumbers/@cellEdges; 

]; 

q=Tissue[v, e, c]; 
Return[q]; 

];
TemplateRandom[x___]:= (Print["Error: expecting TemplateRandom[numPoints, convex_bounds_as_list_of_points"]; $Failed); 


(* ::Input::Initialization:: *)
TemplateRandomSquareGrid[npoints_?IntegerQ, {xmin_, ymin_}, {xmax_, ymax_}, limit_:0.8, offset_:0.5]:= Module[{rx, ry, i,j,  points,point, itotal, bvd, trace=False, tPrint,  v, val, cells, e, c, cellEdges, boundary, q, ngrids, \[CapitalDelta]x, \[CapitalDelta]y, x1, x2, y1, y2, limitation, off},

AbortIf[xmin>= xmax, "Error: TemplateRandomSquareGrid: xmin = "<>ToString[xmin]" \[GreaterEqual] xmax = "<>ToString[xmax]]; 
AbortIf[ymin>= ymax, "Error: TemplateRandomSquareGrid: ymin = "<>ToString[ymin]" \[GreaterEqual] ymax = "<>ToString[ymax]];

tPrint[x___]:= If[trace, Print["TemplateRandomSquareGrid: ", x]]; 

boundary={{xmin, ymin}, {xmax, ymin}, {xmax, ymax}, {xmin, ymax}}; 

(* generate random centers *)

rx:= RandomReal[{xmin, xmax}]; 
ry:= RandomReal[{ymin, ymax}]; 

ngrids = Round[Sqrt[1.0*npoints]];
If[ngrids^2 < npoints, ngrids = ngrids + 1]; 


\[CapitalDelta]x=(xmax-xmin)*1.0/ngrids; 
\[CapitalDelta]y=(ymax-ymin)*1.0/ngrids; 

limitation = Min[Max[limit, 0.0], .8]; 

off = Max[Min[offset, .9], -.9]; 

points={}; 
For[i=1, i<= ngrids, i++, 
x1 = xmin + (i-1/2 -limitation/2)*\[CapitalDelta]x;
x2 = xmin + (i-1/2 + limitation/2)*\[CapitalDelta]x; 

For[j=1, j<= ngrids, j++, 
y1 = ymin + (j-1/2 -limitation/2)*\[CapitalDelta]y;
y2 = ymin + (j-1/2 + limitation/2)*\[CapitalDelta]y; 

Block[{X1,X2}, 
If[EvenQ[j], 
X1=x1+off*\[CapitalDelta]x; 
X2=x2+off*\[CapitalDelta]x;,
X1=x1;
X2=x2;
]; 

Block[{px, py}, 
{px, py} = {RandomReal[{X1,X2}], RandomReal[{y1, y2}]}; 
If[px>xmax, px = px -(xmax-xmin)]; 

point={px, py}; 
]; 

]; 
(* keep all points on odd rods; keep only first n-1 points on even rows because*)
If[i<ngrids \[Or] (i==ngrids \[And] OddQ[j]),
AppendTo[points, point]
]; 

]
]; 
$POINTS=points; 

(* tPrint["boundary: ", boundary]; 
tPrint["points: ", points]; *)
(* generate Bounded Voronoi *)
tPrint["points: ", points]; 
tPrint["boundary: ", boundary]; 

tPrint["Generating Bounded Voronoi .. "]; 

Block[{failed, err}, 
failed=False; 
err:= (Print["TemplateRandomSquareGrid: Error evaluating Bounded Voronoi, xmin=", xmin, " xmax = ", xmax, " ymin = ", ymin, " ymax = ", ymax];
failed= True;); 
(* Try to catch the error: BoundedDiagram::nobd: Bounded diagram failed *)

bvd =Check[ BoundedDiagram[boundary, points], err]; 
If[failed, Return[$Failed]]; 
]; 


{v, val} = bvd; 

tPrint[Length[v], " vertices"]; 
tPrint[Length[val], " cells"]; 

(* list of cells as vertex numbers *)

cells =Last/@ val;

(* list of cells edges as vertex pair numbers *)

cellEdges = Partition[#, 2, 1, 1]&/@cells; 
 cellEdges = Map[Sort/@#&, cellEdges]; 


e = Union[Join@@cellEdges];

Block[{edgeNumber, edgeNumbers}, 
edgeNumber[{i_, j_}]:= Position[e, {i,j}][[1, 1]]; 
edgeNumbers[{ijpair__}]:= edgeNumber/@{ijpair}; 
c=edgeNumbers/@cellEdges; 

]; 

q=Tissue[v, e, c]; 
Return[q]; 

];
TemplateRandomSquareGrid[x___]:= (Print["Error: expecting TemplateRandomSquareGrid[numPoints, {xmin, xmax}, {ymin, ymax}]"]; $Failed); 


(* ::Input::Initialization:: *)
RandomSquareGridCenters[ {xmin_, ymin_}, {xmax_, ymax_}, nx_, ny_, limit_:0.4, offset_:0.5]:= Module[{rx, ry, i,j,  points,point, itotal, bvd, trace=True, tPrint,  v, val, cells, e, c, cellEdges, boundary, q, ngrids,  x1, x2, y1, y2, limitation, off, \[CapitalDelta]x, \[CapitalDelta]y},

tPrint[x___]:= If[trace, Print["TemplateRandomSquareGrid: ", x]]; 

boundary={{xmin, ymin}, {xmax, ymin}, {xmax, ymax}, {xmin, ymax}}; 

(* generate random centers *)

rx:= RandomReal[{xmin, xmax}]; 
ry:= RandomReal[{ymin, ymax}]; 
 

\[CapitalDelta]x=(xmax-xmin)*1.0/ nx; 
\[CapitalDelta]y=(ymax-ymin)*1.0/ny; 

limitation = Min[Max[limit, 0.0], .4]; 

off = Max[Min[offset, .9], -.9]; 

points={}; 
For[i=1, i<= nx, i++, 
x1 = xmin+(i-1+limitation)*\[CapitalDelta]x;
x2 =  x1+(1-limitation)*\[CapitalDelta]x; 

For[j=1, j<= ny, j++, 
y1=ymin + (j-1 +limitation)*\[CapitalDelta]y; 
y2= y1+(1-limitation) \[CapitalDelta]y; 

Block[{X1,X2}, 
If[EvenQ[j], 
X1=x1+off*\[CapitalDelta]x; 
X2=x2+off*\[CapitalDelta]x;,
X1=x1;
X2=x2;
]; 

Block[{px, py}, 
{px, py} = {RandomReal[{X1,X2}], RandomReal[{y1, y2}]}; 
If[px>xmax, px = px -(xmax-xmin)]; 

point={px, py}; 
]; 

]; 
AppendTo[points, point]; 

]
]; 
Return[points];

];



(* ::Input::Initialization:: *)
VoronoiToTissue[points_, boundary_, trace_:False]:= Module[{bvd, v, val, tPrint, cells, cellEdges, e, c, q},

tPrint[x___]:= If[trace, Print["VoronoiToTissue: ", x]]; 

bvd = BoundedDiagram[boundary, points];

{v, val} = bvd; 

tPrint[Length[v], " vertices"]; 
tPrint[Length[val], " cells"]; 

(* list of cells as vertex numbers *)

cells =Last/@ val;

(* list of cells edges as vertex pair numbers *)

cellEdges = Partition[#, 2, 1, 1]&/@cells; 
 cellEdges = Map[Sort/@#&, cellEdges]; 


e = Union[Join@@cellEdges];

Block[{edgeNumber, edgeNumbers}, 
edgeNumber[{i_, j_}]:= Position[e, {i,j}][[1, 1]]; 
edgeNumbers[{ijpair__}]:= edgeNumber/@{ijpair}; 
c=edgeNumbers/@cellEdges; 

]; 

q=Tissue[v, e, c]; 
Return[q]; 

 ];
VoronoiToTissue[x___]:= (Print["Error: Expecting VoronoiToTissue[points, boundary]"]; $Failed); 


(* ::Input::Initialization:: *)
TemplateRandomCircularGrid[npoints_?IntegerQ, radius_?NumericQ]:= Module[{n, dbg=False, dPrint, layers,layer,  point, points, cellsInLayer, \[Delta]\[Theta], \[Theta]0, \[Theta]centers, thetas, offset, r, \[Delta]r, rvals, pointsInLayer, q},
dPrint[x___]:= If[dbg, Print["TemplateRandomCircularGrid: ", x]]; 
(* find smallest square integer that is larger or equal to npoints *) 

If[npoints<1, Print["Error: TemplateRandomCircularGrid: Must have at least 1 point."]; Return[$Failed]]; 

(* determine number of layers and layer thickness *)

layers=Sqrt[npoints*1.0]//Round;
If[layers^2<npoints, layers++];
n=layers^2;
\[Delta]r=radius/layers; 

dPrint["n: ", n]; 

dPrint["layers: ", layers]; 
dPrint["\[Delta]r: ", \[Delta]r]; 

(* determine centers in each layer *)

points={{0,0}}; 
cellsInLayer=1; 
offset = 0.1; 
\[Theta]0=0; 
For[layer=2, layer<= layers, layer++,
cellsInLayer=cellsInLayer+2; 
\[Delta]\[Theta]=360.0/cellsInLayer; 
\[Theta]0=RandomReal[{0, 180.0}]; 
dPrint["layer: ", layer, " has ", cellsInLayer, " cells with ", \[Delta]\[Theta], " deg. spacing."]; 

\[Theta]centers=Mod[(\[Theta]0+\[Delta]\[Theta]*#), 360.0]&/@Range[cellsInLayer]; 
thetas = Mod[RandomReal[{#-offset*\[Delta]\[Theta], #+offset*\[Delta]\[Theta]}], 360.0]&/@\[Theta]centers;
thetas = (\[Pi]/180.)*thetas; 
dPrint["thetas: ", thetas]; 

r=(layer-0.5)*\[Delta]r;
rvals = Table[RandomReal[{r-offset*\[Delta]r, r+offset*\[Delta]r}], {cellsInLayer}]; 

dPrint["rvals: ", rvals]; 

pointsInLayer = Transpose[{rvals, thetas}]; 
pointsInLayer = ( (#[[1]])*{Cos[#[[2]]], Sin[#[[2]]]})&/@pointsInLayer; 

dPrint["pointsInLayer: ", pointsInLayer]; 
points = Join[points, pointsInLayer]; 
]; 

(* using the convex hull here makes the outmost layer only half the required thickness *)

dPrint[ListPlot[points, AspectRatio-> 1]]; 
Block[{ch}, 
ch=ConvexHull[points]; 
ch = points[[ch]]; 
q= VoronoiToTissue[points, ch, dbg]; 
]; 

(* now move all the edges vertices out to the requisite boundary *)

Block[{v,c,e, vb, vbxy, pushout, replacements},
v= TissueVertices[q]; 
e=TissueEdges[q];
c=TissueCells[q];

vb = VerticesOnBoundary[q]; 
vbxy= v[[vb]]; 

pushout[{x_,y_}]:= Module[{theta, new}, 
theta = ArcTan[x,y];
new=radius*{Cos[theta], Sin[theta]}; 
Return[new]; 
];
vbxy = pushout/@vbxy; 

replacements=MapThread[Rule, {vb, vbxy}]; 
v=ReplacePart[v, replacements]; 

q=Tissue[v,e,c]; 

]; 
 

Return[q]; 



]; 

TemplateRandomCircularGrid[x___]:= (Print["Error: Expecting TemplateRandomCircularGrid[numPoints, radius]"]; $Failed); 



(* ::Input::Initialization:: *)
TemplateRandomSemicircularGrid[nrcpoints_?IntegerQ, radius_?NumericQ, nbot_?IntegerQ]:= Module[{n, dbg=False, dPrint, layers,layer,  point, points, cellsInLayer, \[Delta]\[Theta], \[Theta]0, \[Theta]centers, thetas, offset, r, \[Delta]r, rvals, pointsInLayer, q, npoints, toplayer, bottom, nbottom},
dPrint[x___]:= If[dbg, Print["TemplateRandomCircularGrid: ", x]]; 
(* find smallest square integer that is larger or equal to npoints *) 

npoints =nrcpoints; 
If[npoints<1, Print["Error: TemplateRandomCircularGrid: Must have at least 1 point."]; Return[$Failed]]; 

(* determine number of layers and layer thickness *)

layers=Sqrt[npoints*1.0]//Round;
If[layers^2<npoints, layers++];
n=layers^2;
\[Delta]r=radius/layers; 

dPrint["n: ", n]; 

dPrint["layers: ", layers]; 
dPrint["\[Delta]r: ", \[Delta]r]; 

(* determine centers in each layer *)

points={{0,0}}; 
cellsInLayer=1; 
offset = 0.1; 
\[Theta]0=0; 
For[layer=2, layer<= layers, layer++,
cellsInLayer=cellsInLayer+2; 
\[Delta]\[Theta]=180.0/cellsInLayer; 
\[Theta]0=RandomReal[{0, 180.0}]; 
dPrint["layer: ", layer, " has ", cellsInLayer, " cells with ", \[Delta]\[Theta], " deg. spacing."]; 

\[Theta]centers=Mod[(\[Theta]0+\[Delta]\[Theta]*#), 180.0]&/@Range[cellsInLayer]; 
thetas = Mod[RandomReal[{#-offset*\[Delta]\[Theta], #+offset*\[Delta]\[Theta]}], 360.0]&/@\[Theta]centers;
thetas = (\[Pi]/180.)*thetas; 
dPrint["thetas: ", thetas]; 

r=(layer-0.5)*\[Delta]r;
If[layer==layers, r = r+\[Delta]r/2]; 

rvals = Table[RandomReal[{r-offset*\[Delta]r, r+offset*\[Delta]r}], {cellsInLayer}]; 

dPrint["rvals: ", rvals]; 

pointsInLayer = Transpose[{rvals, thetas}]; 
pointsInLayer = ( (#[[1]])*{Cos[#[[2]]], Sin[#[[2]]]})&/@pointsInLayer; 

dPrint["pointsInLayer: ", pointsInLayer]; 
points = Join[points, pointsInLayer]; 
]; 

(* using the convex hull here makes the outmost layer only half the required thickness *)

nbottom=nbot; 
If[nbottom<1, Print["Error: TemplateRandomSemicircularGrid must have at least 1 bottom row. Input value reset to 1. "]; nbottom=1]; 
bottom= RandomSquareGridCenters[{-radius, -(nbottom+.5)*\[Delta]r*Pi/2}, {radius, -0.5*\[Delta]r}, 2*(layers-1), nbottom]; 
Global`$BOTTOM=bottom; 

points = Join[points, bottom]; 


dPrint[ListPlot[points, AspectRatio-> 1]]; 
Block[{ch}, 
ch=ConvexHull[points]; 
ch = points[[ch]]; 
q= VoronoiToTissue[points, ch, dbg]; 
]; 

dPrint["post-voronoi tissue: ", ShowTissue[q, ImageSize-> 200]]; 


(* now move all the edges vertices  in the top layer out to the requisite boundary *)

Block[{v,c,e, vb, vbxy, pushout, replacements, toplayerv},
v= TissueVertices[q]; 
e=TissueEdges[q];
c=TissueCells[q];

(* all vertices on boundary *)
vb = VerticesOnBoundary[q];  

(* got coordinates *)

dPrint["vb:", vb]; 
vbxy= v[[vb]]; 

(* modify the coordinates *) 

pushout[{x_,y_}]:= Module[{theta, new, oldr, newr}, 
If[x==y==0, Return[{x,y}]]; 
If[y>0, 
oldr = Norm[{x,y}]; 
newr=oldr + \[Delta]r/2; 
theta = ArcTan[x,y];
new=newr*{Cos[theta], Sin[theta]};,

new={x,y}; 
If[y<-(nbottom-.5)*\[Delta]r*Pi/2, new = new + {0,-\[Delta]r/2}]; 
If[x>radius -\[Delta]r, new = new + {\[Delta]r/2, 0}]; 
If[x<-radius+\[Delta]r, new = new + {-\[Delta]r/2, 0}]; 

];  
Return[new]; 
];
 vbxy = pushout/@vbxy;  

replacements=MapThread[Rule, {vb, vbxy}]; 
v=ReplacePart[v, replacements]; 

q=Tissue[v,e,c]; 

]; 
 

Return[q]; 



]; 

TemplateRandomCircularGrid[x___]:= (Print["Error: Expecting TemplateRandomCircularGrid[numPoints, radius, bottom]"]; $Failed); 



(* ::Input::Initialization:: *)
TemplatePolygon[sides_Integer, StartAngle_:0, aspect_:1, rnd_:-1, rot_:0]:= Module[{v, nv, e, c}, 
v=regularPolygon[sides, StartAngle, aspect, rnd, rot]; 
nv=Length[v];
e=Partition[Range[nv], 2,1,1];
c={Range[nv]}; 
Return[Tissue[v,e,c]]
];


(* ::Input::Initialization:: *)
TemplateRandomOvalish[n_, {a_, b_}, dbg_:False]:= Module[
{rx,ry,point,points,i,OK, ch, q, dPrint},
dPrint[x___]:= If[dbg, Print["TemplateRandomOvalish: ", x]]; 
rx:=RandomReal[{-a, a}];
ry:=RandomReal[{-b, b}];
OK[{x_,y_}]:=(x/a)^2+(y/b)^2<1;
points={};
i=0;
While[i<n,
point={rx,ry}; 
dPrint[{i, point, OK[point]}]; 

If[OK[point],
points=Append[points,point];
i++];

];
dPrint[points];
ch=ComputationalGeometry`ConvexHull[points];
dPrint[ch]; 
ch = points[[ch]]; 
q=VoronoiToTissue[points, ch];

(* project points out to ellipse  *)

Block[{vb,v, costheta, sintheta, vnext,vnew, inext, e, c}, 
vb = VerticesOnBoundary[q]; 
v=TissueVertices[q]; 

project[{x_, y_}]:= Module[{r, R, c, s, xnew, ynew}, 
r = Sqrt[x^2 + y^2]; 
c = x/r; 
s = y/r; 
R = 1/((c/a)^2 + (s/b)^2);
R=Sqrt[R]; 
xnew = R*x/r;
ynew = R * y /r; 
Return[{xnew, ynew}]; 
]; 

While[Length[vb]>0, 
inext = First[vb]; 
vb= Rest[vb]; 
vnext = v[[inext]]; 
vnew = project[vnext];
v = ReplacePart[v, inext -> vnew];
]; 
e = TissueEdges[q]; 
c = TissueCells[q]; 

q = Tissue[v,e,c]
]; 


Return[q];
]


(* ::Input::Initialization:: *)
TemplateParabolic[height_,nRows_, rnd_:0]:=Module[{W,H,delta,i,g,gnext,parab,NMdist,pts,k=0,x,y,off,t,q,q1,n,n1,bv,v,e,c,ymin,xbv,vnew,vbvnew,vbv,bottomlayer,dPrint,rng,mxrnd,RemoveExtraBottomVertices, gcurves, dummyCells},
dPrint[u___]:=If[debug,Print["Meristem Template: ",u]];


(*Equation of parabola of width W,Height H*)

parab[W_,H_,x_]:=H*(1-(2 x/W)^2);

(*Newton Method Solver for x-coordinate of distance t as measured from center along parabola*)(*assumes convergence in 3 iterations*)NMdist[t_,Width_]:=Module[{f,gn,x0,j,xnext},f[x_]:= 1/8 (4 x Sqrt[1+(16 x^2)/Width^2]+Width*ArcSinh[(4 x)/Width])-t; 
gn[x_]:=x-f[x]/f'[x];
x0=t;
For[j=0,j<=2,j++,x0=gn[x0];];
x0];
(*delta is the approximate cell diameter*)
delta=1.0*height/nRows;
dPrint["delta=",delta];

mxrnd = Max[0,Min[rnd, 0.25]]; 
rng:= RandomReal[mxrnd*{-delta, delta}]; 
rng:= RandomVariate[NormalDistribution[0,mxrnd*delta]]; 


(*generate parabolas spaced by delta*)

g={};
pts={};
For[i=1,i<=nRows,i++,H=i*delta;
W=2 H;
gnext=Plot[parab[W,H,x],{x,-H,H}];
g=Append[g,gnext];
x=0;
k=0;
(*generate evenly spaced points along each parabola*)
While[x<W,off=If[EvenQ[i],0,0.5];
t=1.0*k*delta+off*delta;
x=NMdist[t,W];
y=parab[W,H,x];
k++;
If[y>0,pts=Append[pts,{x+rng,y+rng}];
If[OddQ[i]\[Or](x>0),pts=Append[pts,{-x,y}]];];];];dPrint[gcurves= Show[g,Graphics[{PointSize[.02],Point[pts]}],PlotRange->All,ImageSize->300,AspectRatio-> .5]];
(*add a layer of dummy cells on the bottom of the meristem*)pts=Union[pts];
n=Length[pts];
dummyCells=Table[{x,-delta*.5+RandomReal[{-delta/10,delta/10}]},{x,-H,H,delta}];
dPrint["dummyCells for Voronoi Bounding: ", Show[gcurves, Graphics[{Red, Point[dummyCells]}]]];
pts=Join[pts,dummyCells];
n1=Length[pts];
dPrint[{n,n1}];
(*generate Voronoi of points*)q=BoundedCellVoronoi[pts];
dPrint["bounded: ",ShowTissue[q,"CellNumbers"->True,ImageSize->300]];
(*smoothe out the bumpi-ness from the Voronoi*)q=SmootheCells[q];
dPrint["smoothed: ",ShowTissue[q,"CellNumbers"->True,ImageSize->300]];
(*remove the dummy layer on the bottom-Voronoi might have changed indices*)bottomlayer=Pick[Range[NTissueCells[q]],(#[[2]]<0)&/@Centroid[q]];
q=RemoveCell[q,bottomlayer];
dPrint["pruned: ",ShowTissue[q,"CellNumbers"->True,ImageSize->300,Frame->True]];
(*Project vertices on bottom to a straight line*)(*bv=VerticesOnBottom[q];*){v,e,c}=q/.{Tissue->List};
bv=Pick[Range[NTissueVertices[q]],(#[[2]]<delta*0.5)&/@v];

ymin=Mean[Last/@v[[bv]]];
vbv=v[[bv]];
xbv=First/@vbv;
vbvnew={#,ymin}&/@xbv;
vnew=ReplacePart[v,MapThread[Rule,{bv,vbvnew}]];
q=Tissue[vnew,e,c];

dPrint["projected: ",ShowTissue[q,"CellNumbers"->True,"VertexNumbers"-> True,ImageSize->300,Frame->True]];
(* smoothe bottom layer, but not the corners *)
Block[{cvn,flags,bc, xcoords, leftmost, rightmost, endcells},
(* pick boundar cells bc that include the boundary vertices bv determined above *)
cvn=CellVertexNumbers[q];
flags=Length[Intersection[bv,#]]>0&/@cvn;
bc=Pick[Range[NTissueCells[q]],flags];
(* determine left & right most cells based on x-coordinate of centroid *)
xcoords=First/@Centroid[q,bc];
leftmost=Ordering[xcoords][[1]];
leftmost = bc[[leftmost]]; 
rightmost=Ordering[xcoords][[-1]];
rightmost=bc[[rightmost]];
endcells={leftmost,rightmost};
(* exclude left & right-most cells from smoothing *)
bc=Complement[bc,endcells];
(* exclude cells with only a single vertex on boundary from smoothing *)
bc=Select[bc,MemberQ[CellsOnBoundary[q],#]&];
q1=SmootheCells[q,bc];


(* Now check for extra vertices in bottom corrner cells. There is unlikely to be more than one per cell *)

(* leftmost cell *)


RemoveExtraBottomVertices[CellIndex_]:= Module[{int,xvals,left,right,extraVertices,edges,edgepairs},
int=Intersection[cvn[[CellIndex]],bv];
xvals=First/@v[[int]];
left=int[[Ordering[xvals,1]]];right=int[[Ordering[xvals,-1]]];extraVertices=Complement[int,Flatten[{left,right}]];
edges=Position[e,#]&/@extraVertices;
edgepairs=First/@Transpose/@edges;

While[Length[edgepairs]>0,
edges=First[edgepairs]; edgepairs=Rest[edgepairs]; 
q=q1;
dPrint["Merging edges ", {edges}]; 
q1=MergeEdges[q, Sequence@@edges]; 
];
]; 

RemoveExtraBottomVertices[leftmost];
RemoveExtraBottomVertices[rightmost]; 
];
dPrint["projected/smoothed bottom: ",ShowTissue[q1,"CellNumbers"->True,"VertexNumbers"-> True, ImageSize->300,Frame->True]];

q=q1; 

q1=SmootheL1L2Interface[q,delta,height];
dPrint["L1/L2 Interface smoothed out: ", ShowTissue[q1,"CellNumbers"->True,ImageSize-> 300]]; 

(* squish bottom cells down to average *)
Block[{averageArea, areas, cvc, cvcy, takeys, bot,abot, atotbot, overallwidth, xmax, xmin, ysquish}, 
q=q1; 
takeys[vertexlist_]:= Transpose[vertexlist][[2]]; 
areas = areafunction[q]; 
averageArea=areas//Mean;
dPrint["averageArea: ", averageArea]; 
{v,e,c}=q/.{Tissue->List};
xmax = Max[First/@v]; 
xmin = Min[First/@v];
overallwidth=xmax-xmin;
dPrint["overallwidth: ", 6overallwidth]; 
cvc = CellVertexCoordinates[q];
cvcy = Min/@takeys/@cvc;
dPrint["cvcy: ", cvcy]; 
bot=(#<0.5*delta)&/@cvcy;
bot=Pick[Range[Length[c]], bot];
dPrint["bot: ", bot]; 
abot = areas[[bot]]//Mean;
dPrint["abot: ", abot]; 
atotbot=Plus@@areas[[bot]];
dPrint["atotbot: ", atotbot]; 
ysquish = Max[0.0, (atotbot-Length[bot]*averageArea)/overallwidth];
dPrint["ysquish: ", ysquish]; 

(* squish cells *)
bv=Pick[Range[Length[v]],(#[[2]]<delta*0.5)&/@v];
vbv=v[[bv]];
xbv=First/@vbv;
vbvnew={#,ymin+ysquish}&/@xbv;
vnew=ReplacePart[v,MapThread[Rule,{bv,vbvnew}]];
q1=Tissue[vnew,e,c];

]; 

Return[q1]];


(* ::Input::Initialization:: *)
CheckEdges[T_, msg_:""]:= Module[{v,e,c,lengths},
{v,e,c}=T/.{Tissue-> List};
lengths=Length/@e;
lengths=Union[lengths];
AbortIf[lengths!= {2},msg<>"Possible Program Error: Invalid List of edge pairs: "<>ToString[InputForm[e]]<>" : "]
]


(* ::Input::Initialization:: *)
TemplateParabolic[height_, width_, mu_, sigma_, opt___?OptionQ]:=Module[{W,H,delta,i,g,gnext,parab,NMdist,pts,k=0,x,y,off,t,q,q1,n,n1,bv,v,e,c,ymin,xbv,vnew,vbvnew,vbv,bottomlayer,dPrint, gcurves, nextpoint, nRows, told, dummyCells, doEdgeChecks=False, DoEdgeCheck, debug, Points, PPoints},

debug="Debug"/.{opt}/.{"Debug"-> False}; 
Points="Points"/.{opt}/.{"Points"-> {}}; 
PPoints="PrintPoints"/.{opt}/.{"PrintPoints"-> False}; 

DoEdgeCheck[T_,u_]:=If[doEdgeChecks, CheckEdges[T,u]]; 


dPrint[u___]:=If[debug,Print["Meristem Template: ",u]];


(*Equation of parabola of width W,Height H*)

parab[W_,H_,x_]:=H*(1-(2 x/W)^2);

(*Newton Method Solver for x-coordinate of distance t as measured from center along parabola*)(*assumes convergence in 3 iterations*)NMdist[t_,W_,H_]:=Module[{f,gn,x0,j,xnext},f[x_]:= 1/(16H) (8H x Sqrt[1+(64H^2 x^2)/W^4]+W^2*ArcSinh[(8H x)/W^2])-t; 

gn[x_]:=x-f[x]/f'[x];
x0=t;
For[j=0,j<=2,j++,x0=gn[x0];];
x0];

delta = mu; 

dPrint["mu=",mu, " average cell diameter."];
dPrint["sigma=",sigma, " cell diameter std. dev."]; 


(*generate parabolas spaced by delta*)

g={};
If[Length[Points]>0, 
pts=Points, 
pts={};
nRows = height/mu; 
For[i=0,
i<nRows,
i++,
H=height-i*delta;
W=2 H;
W=width - 2(i)*delta; 
(* dPrint["i=", i, " W=", W," H=", H]; *)
gnext=Plot[parab[W,H,x],{x,-W/2,W/2}];
g=Append[g,gnext];
x=0;
k=0;
(*generate evenly spaced points along each parabola*)
told=-W-2*delta; 
While[x<W,off=If[EvenQ[i],0,0.5];
t=told+RandomVariate[NormalDistribution[mu,sigma]];
told=t; 

x=NMdist[t,W,H];
y=parab[W,H,x];
k++;
nextpoint={x,y};

If[y>0,
(* dPrint["t: ", t, "nextpoint: ", nextpoint]; *)
pts=Append[pts,nextpoint];
(* If[OddQ[i]\[Or](x>0),dPrint["rightpoint: ", rightpoint]; pts=Append[pts,leftpoint]]; *)
];
];
];



dPrint[gcurves= Show[g,Graphics[{PointSize[.02],Point[pts]}],PlotRange->{{-width/2-delta/2, width/2+delta/2}, {-delta/2, height+delta/2}},ImageSize->300,AspectRatio-> height/width]];
(*add a layer of dummy cells on the bottom of the meristem*)


pts=Union[pts];
n=Length[pts];
dummyCells=Table[{x,-delta*.5+RandomReal[{-delta/10,delta/10}]},{x,-H,H,delta}];
dPrint["dummyCells for Voronoi Bounding: ", Show[Graphics[Point[dummyCells]]]]; 
pts=Join[pts,dummyCells];
n1=Length[pts];
dPrint[{n,n1}];
(*generate Voronoi of points*)
If[PPoints, Print["Points: ",pts]]; 
]; 

q=BoundedCellVoronoi[pts];
dPrint["bounded: ",ShowTissue[q,"CellNumbers"->True,ImageSize->300]];
DoEdgeCheck[q, "Voronoi: "];


(* smoothe voronoi layer, but not the corners *)

Block[{leftmost, rightmost, bc}, 
{leftmost, rightmost,bc}= BottomCellsExcludingCorners[q,delta];
dPrint["leftmost: ", leftmost, " rightmost: ", rightmost, " bc: ", bc]; 
q=SmootheCells[q,bc];
DoEdgeCheck[q, "SmootheCells (after Voronoi): "];

]; 

dPrint["smoothed: ",ShowTissue[q,"CellNumbers"->True,ImageSize->300]];

q=SmootheL1OuterEdge[q,delta,height, width];
DoEdgeCheck[q, "SmootheL1OuterEdge: "];

dPrint["L1 Outer smoothed: ",ShowTissue[q,"CellNumbers"->True,ImageSize->300]];

(*remove the dummy layer on the bottom-Voronoi might have changed indices*)bottomlayer=Pick[Range[NTissueCells[q]],(#[[2]]<-delta/4.)&/@Centroid[q]];
 q=RemoveCell[q,bottomlayer]; 
DoEdgeCheck[q, "Remove Cells on Bottom Layer: "];

dPrint["pruned: ",ShowTissue[q,"CellNumbers"->True,ImageSize->300,Frame->True]];

(* smoothe bottom layer, but not the corners *)

Block[{bc, leftmost, rightmost},
{leftmost, rightmost,bc}= BottomCellsExcludingCorners[q, delta];
dPrint["leftmost: ", leftmost, " rightmost: ", rightmost, " bc: ", bc]; 
q1=SmootheCells[q,bc];
q=q1;
DoEdgeCheck[q, "SmoothCells (bottom bottom): "];


dPrint["Smoothed (bottom excl. corners: ", ShowTissue[q]]; 

(* Now check for extra vertices in bottom corrner cells. There is unlikely to be more than one per cell *)
dPrint["Before fixing left: ", ShowTissue[q, "EdgeNumbers"-> True, "VertexNumbers"-> True, ImageSize-> 800, Frame-> True, AxesOrigin-> {0,0}, Axes-> True]]; 

dPrint["leftmost: ", leftmost, " rightmost: ", rightmost]; 

q1=RemoveExtraBottomVertices[q,  leftmost];
q=q1;
DoEdgeCheck[q, "Remove extra bottom vertices (left): "];


dPrint["Before fixing Right: ", ShowTissue[q, "EdgeNumbers"-> True, "VertexNumbers"-> True, ImageSize-> 800, Frame-> True, AxesOrigin-> {0,0}, Axes-> True]]; 


q1=RemoveExtraBottomVertices[q, rightmost]; 
q=q1; 
DoEdgeCheck[q, "Remove extra bottom vertices (right): "];

];


dPrint["smoothed bottom: ",ShowTissue[q,"CellNumbers"->True,"VertexNumbers"-> True, ImageSize->300,Frame->True, Axis-> True, AxesOrigin-> {0,0}, ImageSize-> 300]];

dPrint["PROJECTING BOTTOM VERTICES "]; 
dPrint["q: ", Short[q,5]]; 

(*Project vertices on bottom to a straight line*)(*bv=VerticesOnBottom[q];*){v,e,c}=q/.{Tissue->List};

bv = VerticesOnBottom[q]; 
(* dPrint["BV Assigned (faster algorithm): ", bv, Show[ShowTissue[q], Graphics[{Red, PointSize[.01], Point[v[[bv]]]}], ImageSize\[Rule] 300]];*)


ymin=Min[Last/@v[[bv]]];
vbv=v[[bv]];
xbv=First/@vbv;
vbvnew={#,ymin}&/@xbv;
vnew=ReplacePart[v,MapThread[Rule,{bv,vbvnew}]];
q=Tissue[vnew,e,c];

dPrint["projected: ",ShowTissue[q,"CellNumbers"->True,"VertexNumbers"-> True,ImageSize->500,Frame->True]];




q1=SmootheL1L2Interface[q,delta,height, width];
q= q1; 
dPrint["L1/L2 Interface smoothed out: ", ShowTissue[q1,"CellNumbers"->True,ImageSize-> 500]]; 

q1=SmootheL2L3Interface[q,delta,height, width];

dPrint["L2/L3 Interface smoothed out: ", ShowTissue[q1,"CellNumbers"->True,ImageSize-> 500]]; 

q= q1; 

DoEdgeCheck[q, "Smoothe L1/L2 interface: "];



q1 = DivideNSigmas[q, 1.0]; 
dPrint["Cells with area larger than mu + 1 sigma divided by Errera's Rule: ", ShowTissue[q1,"CellNumbers"->True,ImageSize-> 500]]; 
q=q1;

DoEdgeCheck[q, "Divide large cells: "];


q1=FlattenTopWalls[q1]; 
dPrint["Extra Vertices on Outer Wall Removed From Cells: ", ShowTissue[q1,"CellNumbers"->True,ImageSize-> 500]]; 

DoEdgeCheck[q1, "Flatten top walls: "];


Return[q1]
];


(* ::Input::Initialization:: *)
RemoveExtraBottomVertices[q_,  CellIndex_]:= Module[{xvals,left,right,extraVertices,edges,edgepairs, qnew, qnew1,e,en, cv, cvb, edgeOnBottom, enb, dPrint, dbg=False,v,c,bv, cvn},
dPrint[u___]:=If[dbg, Print["RemoveExtraBottomVertices (",CellIndex,"):", u]]; 
{v,e,c}=q/.{Tissue->List};
cvn = CellVertexNumbers[q]; 

(*bv=Pick[Range[NTissueVertices[q]],(#[[2]]<0)&/@v];*)

bv = VerticesOnBottom[q];


dPrint["fixing Cell: ", CellIndex]; 
dPrint["Bottom Vertices: ", bv]; 
cv = cvn[[CellIndex]]; 
cvb = Intersection[cv, bv]; 
dPrint["cell vertices: ", cv, " on bottom: ", cvb]; 
en=TissueCells[q][[CellIndex]];
dPrint["cell edges: ", en];
edgeOnBottom[k_]:=And[
MemberQ[bv, e[[k,1]]], 
MemberQ[bv, e[[k, 2]]]
]; 
enb = Select[en, edgeOnBottom[#]&]; 
dPrint["edges On Bottom: ", enb]; 


xvals=First/@v[[cvb]];
dPrint["xvals: ", xvals]; 
left=cvb[[Ordering[xvals,1]]];
dPrint["left: ", left]; 
right=cvb[[Ordering[xvals,-1]]];
dPrint["right: ", right]; 
extraVertices=Complement[cvb,Flatten[{left,right}]];
dPrint["extraVertices: ", extraVertices]; 
edges=Position[e,#]&/@extraVertices;
dPrint["edges: ", edges]; 
edgepairs=First/@Transpose/@edges;
dPrint["edgepairs: ", edgepairs]; 

qnew1=q; 
While[Length[edgepairs]>0,
edges=First[edgepairs]; edgepairs=Rest[edgepairs]; 
qnew=qnew1;
dPrint["Merging edges ", {edges}]; 
edges = Select[edges, MemberQ[en, #]&];
dPrint["Merging edges (2)", {edges}]; 
qnew1=MergeEdges[qnew, Sequence@@edges]; 
];
dPrint["RETURNING: ", ShowTissue[qnew1]]; 
qnew1
]


(* ::Input::Initialization:: *)
BottomCellsExcludingCorners[q_, delta_]:= Module[{flags,bc,xcoords,leftmost,rightmost,endcells,v,e,c,bv,cvn},
cvn=CellVertexNumbers[q];
{v,e,c}=q/.{Tissue->List};

(* bv=Pick[Range[NTissueVertices[q]],(#[[2]]<delta*0.5)&/@v]; *)

bv=VerticesOnBottom[q];

flags=Length[Intersection[bv,#]]>0&/@cvn;
bc=Pick[Range[NTissueCells[q]],flags];
AbortIf[Length[bc]<1, "BottomCellsExcludingCorners: No bottom vertices: delta = "<>ToString[InputForm[delta]]]; 
(* determine left & right most cells based on x-coordinate of centroid *)
xcoords=First/@Centroid[q,bc];
leftmost=Ordering[xcoords][[1]];
leftmost = bc[[leftmost]]; 
rightmost=Ordering[xcoords][[-1]];
rightmost=bc[[rightmost]];
endcells={leftmost,rightmost};
(* exclude left & right-most cells from smoothing *)
bc=Complement[bc,endcells];
(* exclude cells with only a single vertex on boundary from smoothing *)
{leftmost, rightmost, Select[bc,MemberQ[CellsOnBoundary[q],#]&]}
]


(* ::Input::Initialization:: *)
SmootheL1OuterEdge[q_,delta_,height_, width_:-1, dbg_:False]:=Module[{v,e,c,W,f,g,H,newvxy,X,Y,vmap,vnew,Tnew,dPrint, vtop},
dPrint[u___]:=If[dbg,Print["SmootheL1OuterEdge: ",u]];
H=height+0.5delta;
If[width>0, W=width+2*delta, W=2 H];
f[x_]:=H*(1-(2 x/W)^2);
g[{x_,y_},X]:=(x-X)^2+(y-f[X])^2;
{v,e,c}=q/.{Tissue->List};

(* vtop=Complement[Union[VerticesOnTop[q], VerticesOnLeft[q], VerticesOnRight[q]], VerticesOnBottom[q]];*)

(* The following could give a false positive top cell: *)
(* Since VerticesOnBottom uses outward normal, if a true bottom *)
(* vertex fails the bottom test, e.g., it is shared by two cells *)
(* and is below the centroid of one but not the other then it will *)
(* not be marked as bottom, and hence will not excluded *)
(* as a bottom cell*)
(* This is the reason for the select *)

vtop=Complement[VerticesOnBoundary[q], VerticesOnBottom[q]];
vtop = Select[vtop, v[[#]][[2]]>0.5/delta&]; 

dPrint["vtop Vertices: ", vtop];
dPrint["vtop Vertex Coordinates: ", v[[vtop]]];
newvxy=FindMinimum[g[#,X],{X,#[[1]]}, AccuracyGoal-> 3, PrecisionGoal-> 3]&/@v[[vtop]];
newvxy=Last/@newvxy;
newvxy={X,f[X]}/.#&/@newvxy;
vmap=MapThread[Rule[#1,#2]&,{vtop,newvxy}];
dPrint["mapping: ", vmap];
vnew=ReplacePart[v,vmap];
Tnew=Tissue[vnew,e,c];
dPrint[Show[ShowTissue[q,"CellNumbers"->True,Frame->True,"VertexNumbers"->True,"EdgeNumbers"->True],Plot[f[x],{x,-W/2,W/2}],Graphics[{PointSize[.02],Pink,Point[v[[vtop]]]}],Graphics[{PointSize[.02],Green,Point[newvxy]}], ImageSize-> 500]];
Return[Tnew];]


(* ::Input::Initialization:: *)
SmootheL1L2Interface[q_,delta_,height_, width_:-1]:=Module[{v,e,c,L1L2vertices,W,f,g,H,newvxy,X,Y,vmap,vnew,Tnew,dbg=False,dPrint},


dPrint[u___]:=If[dbg,Print["SmootheL1L2Interface: ",u]];
H=height-0.5 delta;
If[width>0, W=width, W=2 H];
f[x_]:=H*(1-(2 x/W)^2);
g[{x_,y_},X]:=(x-X)^2+(y-f[X])^2;
{v,e,c}=q/.{Tissue->List};

L1L2vertices=FindL1L2Vertices[q,delta]; 
dPrint["L1/L2 Vertices: ", L1L2vertices];
dPrint["L1/L2 Vertex Coordinates: ", v[[L1L2vertices]]];
newvxy=FindMinimum[g[#,X],{X,#[[1]]}, AccuracyGoal-> 3, PrecisionGoal-> 3]&/@v[[L1L2vertices]];
newvxy=Last/@newvxy;
newvxy={X,f[X]}/.#&/@newvxy;
vmap=MapThread[Rule[#1,#2]&,{L1L2vertices,newvxy}];
dPrint["mapping: ", vmap];
vnew=ReplacePart[v,vmap];
Tnew=Tissue[vnew,e,c];
dPrint[Show[ShowTissue[q,"CellNumbers"->True,Frame->True,"VertexNumbers"->True,"EdgeNumbers"->True],Plot[f[x],{x,-W/2,W/2}],Graphics[{PointSize[.02],Pink,Point[v[[L1L2vertices]]]}],Graphics[{PointSize[.02],Green,Point[newvxy]}], ImageSize-> 500]];
Return[Tnew];]


(* ::Input::Initialization:: *)
SmootheL2L3Interface[q_,delta_,height_, width_:-1]:=Module[{v,e,c,L1L2vertices,W,f,g,H,newvxy,X,Y,vmap,vnew,Tnew,dbg=False,dPrint},


dPrint[u___]:=If[dbg,Print["SmootheL2L3Interface: ",u]];
H=height-1.5 delta;
If[width>0, W=width-3.0*delta, W=2 H];
f[x_]:=H*(1-(2 x/W)^2);
g[{x_,y_},X]:=(x-X)^2+(y-f[X])^2;
{v,e,c}=q/.{Tissue->List};

L1L2vertices=FindL2L3Vertices[q,delta]; 
dPrint["L2/L3 Vertices: ", L1L2vertices];
dPrint["L2/L3 Vertex Coordinates: ", v[[L1L2vertices]]];
newvxy=FindMinimum[g[#,X],{X,#[[1]]}, AccuracyGoal-> 3, PrecisionGoal-> 3]&/@v[[L1L2vertices]];
newvxy=Last/@newvxy;
newvxy={X,f[X]}/.#&/@newvxy;
vmap=MapThread[Rule[#1,#2]&,{L1L2vertices,newvxy}];
dPrint["mapping: ", vmap];
vnew=ReplacePart[v,vmap];
Tnew=Tissue[vnew,e,c];
dPrint[Show[ShowTissue[q,"CellNumbers"->True,Frame->True,"VertexNumbers"->True,"EdgeNumbers"->True],Plot[f[x],{x,-W/2,W/2}],Graphics[{PointSize[.02],Pink,Point[v[[L1L2vertices]]]}],Graphics[{PointSize[.02],Green,Point[newvxy]}], ImageSize-> 500]];
Return[Tnew];]


(* ::Input::Initialization:: *)
FlattenTopWalls[q_Tissue]:=Module[{v,e,c,L1,centroids,dbg=False,dPrint,leftmost,rightmost,boundaryCellNumber,eob,eobi,sortedCellEdges,sortedBoundaryVertices,ep1,ep2,newEdge,enew,cnew,ne,oldcell,oldcellpositions,mappings,newcell, T,bottommost},
dPrint[x___]:=If[dbg,Print["FlattenTopWalls:",x]];
{v,e,c}=q/.{Tissue->List};
L1=L1Cells[q];
centroids=Centroid[q][[L1]];

(* find two bottomost centroids rather than leftmost and rightmost as these will really be the end of the arc *)

bottommost=L1[[Ordering[Last/@centroids,2]]]; 


(* rightmost=L1[[Ordering[centroids,-1][[1]]]];
leftmost=L1[[Ordering[centroids,1][[1]]]];*)
{leftmost,rightmost}=bottommost;
If[Centroid[q,leftmost][[1]]>Centroid[q,rightmost][[1]], Block[{temp}, temp=leftmost; leftmost=rightmost; rightmost=temp;]];

dPrint["leftmost, rightmost: ", {leftmost,rightmost}];
L1=Complement[L1,{leftmost,rightmost}];
dPrint["L1 {excluding end cells): ",L1];
eob=EdgesOnBoundary[q];
ne=Length[e];
cnew=c;
enew=e;
While[Length[L1]>0,boundaryCellNumber=First[L1];
L1=Rest[L1];
eobi=Intersection[c[[boundaryCellNumber]],eob];
sortedCellEdges=SortCellEdges[eobi,e];
sortedBoundaryVertices="Vertices"/.sortedCellEdges;
ep1=First[sortedBoundaryVertices];
ep2=Last[sortedBoundaryVertices];
newEdge={ep1,ep2};
dPrint["Cell ",boundaryCellNumber," has boundary edges ",eobi," vertices: ",sortedBoundaryVertices," newEdge: ",newEdge];
enew=Append[enew,newEdge];
ne=ne+1;
oldcell=c[[boundaryCellNumber]];
oldcellpositions=Position[oldcell,#][[1,1]]&/@eobi;
mappings=PadRight[{ne},Length[oldcellpositions],Null];
mappings=MapThread[#1->#2&,{oldcellpositions,mappings}];
newcell=Flatten[ReplacePart[oldcell,mappings]/.{Null->{}}];
dPrint["oldcell: ",oldcell," positions: ",oldcellpositions," mappings: ",mappings," newcell: ",newcell];
cnew=ReplacePart[cnew,boundaryCellNumber->newcell];
];
T=Tissue[v,enew,cnew];

(* Remove Unused Edges From the Tissue Data Structure *)

T=UndangleEdges[T];

(* Remove Unused Verices *)

T=UndangleVertices[T]
]


(* ::Input::Initialization:: *)
FindL2L3Vertices[q_, delta_]:=Module[{v,e,c,nc,vob,cvn,l1cells,l2cells,l1vn,l2vn,l2l3,dbg=False, dPrint},
dPrint[u___]:= If[dbg, Print["FindL2L3Vertices: ", u]]; 
{v,e,c}=q/.{Tissue->List};
cvn=CellVertexNumbers[q];
nc=Length[c];
(*all boundary vertices*)
vob=VerticesOnBoundary[q];
l1cells=L1Cells[q];
dPrint["l1cells=", l1cells];
l1vn=Union@@CellVertexNumbers[q,l1cells];
dPrint["l1vn=", l1vn]; 
l2cells=L2Cells[q];
dPrint["l2cells=", l2cells]; 
l2vn=Union@@CellVertexNumbers[q, l2cells];
dPrint["l2vn: ", l2vn]; 
l2l3 =Complement[ Complement[l2vn,l1vn],vob]
];
FindL2L3Vertices[x___]:= "Huh?"


(* ::Input::Initialization:: *)
FindL1L2Vertices[q_,delta_]:= Module[{L1L2vertices,l1cells,l1vertices,bv,cvn,vob,nc,v,c,e},
{v,e,c}=q/.{Tissue->List};
cvn=CellVertexNumbers[q];
nc=Length[c];
(*bottom vertices*)
bv=Pick[Range[NTissueVertices[q]],(#[[2]]<delta*0.5)&/@v];
(*all boundary vertices*)
vob=VerticesOnBoundary[q];
(*L1 outer surface vertices*)
l1vertices=Select[vob,v[[#]][[2]]>delta/2&];
l1cells=Pick[Range[nc],Length[Intersection[l1vertices,#]]>0&/@cvn];
L1L2vertices=Complement[Complement[Union[Join@@cvn[[l1cells]]],l1vertices],bv];
Return[L1L2vertices];
]


(* ::Input::Initialization:: *)
FindL1L2Edges[q_,delta_]:= Module[{L1L2V,v,e,c,ne, mostofthem, others,vnums,onbot},

(* onbot is true if one vertex has y<delta/2 and the other has y > delta/2 *)
onbot[{i_,j_}]:=(v[[i,2]]-delta*.5)*(v[[j,2]]-delta*.5)<0;

L1L2V=FindL1L2Vertices[q,delta];
{v,e,c}=q/.{Tissue-> List};
ne=Length[e];
(* This picks out the edges that don't touch the bottom *)
mostofthem=Pick[Range[ne],Length[Intersection[L1L2V,#]]==2&/@e];

(* also figure out edges that connect with bottom edge *)
others=Pick[Range[ne],Length[Intersection[L1L2V,#]]==1&/@e];
vnums=e[[others]];
others = Pick[others,onbot/@vnums];

(* return all of them *)

Join[mostofthem, others]
]


(* ::Input::Initialization:: *)
Rectangularize[tis_?TissueQ, opt___?OptionQ]:= Module[{v,e,c, bv, corners, method, debug, dPrint, xmin,ymin, xmax, ymax, projections, i, xy, tnew, meanarea, quiet, verbose, Sorted, tissue}, 
Sorted[{x_,y_}]:= x<= y; 

(* force all cells to be "sorted" *)

v=TissueVertices[tis]; 
c=TissueCells[tis]; 
e=TissueEdges[tis]; 
c=("Edges"/.SortCellEdges[#, e])&/@c; 
tissue=Tissue[v,e,c]; 

quiet = "Quiet"/.{opt}/.Options[Rectangularize]; 
verbose[x___]:= If[!quiet, Print[x]]; 

verbose["Projecting vertices .."]; 

v=TissueVertices[tissue]; 
bv=VerticesOnBoundary[tissue];
meanarea = Mean[areafunction[tissue]]; 

(* identify options *)

debug="Debug"/.{opt}/.Options[Rectangularize];
dPrint[x___]:= If[debug, Print["Rectangularize: ", x]]; 
corners = "Corners"/.{opt}/.Options[Rectangularize]; 
method = "Method"/.{opt}/.Options[Rectangularize]; 
dPrint["{boundary,method}:", {corners, method}];

(* figure out where the new corners are *)

corners=GetCorners[tissue, corners]; 

If[SameQ[corners, $Failed], Return[$Failed]]; 
{{xmin,ymin}, {xmax,ymax}}=corners;

(* find out where the projected points are and project them *)

projections=ProjectVerticesToBoundary[tissue, method, corners, debug];
If[SameQ[projections, $Failed], Return[$Failed]]; 
While[Length[bv]>0,
xy=First[projections]; projections=Rest[projections]; 
i=First[bv]; bv=Rest[bv]; 
v=ReplacePart[v, i-> xy]; 
]; 
c=TissueCells[tissue]; 
e=Sort/@TissueEdges[tissue]; 
dPrint["Sorted: ", And@@(Sorted/@e)];

tnew=Tissue[v,e,c];
dPrint[ShowTissue[tnew, ImageSize-> 175]]; 
dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];

(* Print[And@@(Sorted/@TissueEdges[tnew])]; *)


(* the corners were not included in the above projection *)
 verbose["Adding corners .."]; 

tnew = AddCorners[tnew, corners]; 
If[SameQ[tnew, $Failed], Return[$Failed]]; 
dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];
dPrint[ShowTissue[tnew, "Vertices"-> Red, ImageSize-> 175]]; 

(* remove the inline vertices *)
verbose["Merging edges .."]; 
(* ilv = InLineVertices[tnew]; 
dPrint["ilv: ", ilv]; *)
dPrint["Removing inline vertices .."]; 
tnew=RemoveInLineVertices[tnew]; 
dPrint[ShowTissue[tnew, ImageSize-> 175, "Vertices"-> True]]; 
dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];

(* fix the masses: extended cells will be too big *)
verbose["Regularizing mass .."]; 
tnew =  RegularizeMass[tnew, meanarea, opt]; 
If[SameQ[tnew, $Failed], Print["Error Exit: Rectangularize"]; Return[$Failed]]; 

dPrint["Sorted: ", And@@(Sorted/@TissueEdges[tnew])];

Return[tnew];
]; 
Rectangularize[x___]:= (Print["Error: Expecting Rectangularize[tissue, options]"]; $Failed);


(* ::Input::Initialization:: *)
RegularizeMass[tissue_?TissueQ, area_, opt___?OptionQ]:= Module[{dbg=False, dPrint, bc, bcarea, bcareas, sigma, ic,icareas,icarea,  icsigma,  c, nc,  tosplit, cvc, axes, tnew, j, vector, Splittables, nvstart, vfinal,nvfinal,  rand, dist, bv, v2randomize}, 

dbg="Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["RegularizeMass: ", x]]; 
c=TissueCells[tissue]; 

(* save this for later *)
nvstart=NTissueVertices[tissue]; 
dist = Sqrt[Mean[areafunction[tissue]]]; 

nc = Length[c]; 

dPrint["area: ", area]; 
bc = CellsOnBoundary[tissue]; 
ic = Complement[Range[nc], bc]; 
If[Length[ic]<2 \[Or] Length[bc]<2, 
Print["Warning: RegularizeMass: interior cells: ", Length[ic], " Exterior cells: ", Length[bc], " There must be at least 2 in each set. No regularization performed."]; 
Return[tissue];
];

bcareas = areafunction[tissue, bc]; 
bcarea=Mean[bcareas]; 
sigma=StandardDeviation[bcareas]; 

icareas = areafunction[tissue, ic]; 
icarea = Mean[icareas];
icsigma = StandardDeviation[icareas]; 

dPrint["bcarea: ", bcarea, " sigma: ", sigma]; 
dPrint["icarea: " ,icarea, " sigma: ", icsigma]; 

(* onesigs = (#>icarea+icsigma)&/@bcareas; 
twosigs = (#>icarea+2*icsigma)&/@bcareas; 
tosplit = (#> 2*(icarea - 2*icsigma))&/@bcareas; 
tosplit = MapThread[And, {tosplit, onesigs}]; 
*)

Splittable[cellArea_]:=(cellArea>icarea+icsigma) \[And](cellArea> 2*(icarea - 2*icsigma)); 
tosplit = Splittable/@bcareas; 

(* onesigs=Pick[bc,onesigs];
twosigs=Pick[bc, twosigs]; *)
tosplit=Pick[bc, tosplit]; 

(* dPrint["Boundary cells > mean + 1 sigma: ", onesigs]; 
dPrint["Boundary cells > mean + 2 sigma: ", twosigs]; *)
dPrint["Boundary cells mass/2 > mean - 2sigma: ", tosplit]; 

(* cvc=CellVertexCoordinates[tissue][[tosplit]]; 
dPrint["cvc: ", cvc]; 
axes = PrimaryAxes/@cvc; *)

(* get Primary axis Vector of each cell *)
axes  = PrimaryAxesVectors[tissue, tosplit]; 
axes = ({-1,1}*Reverse[#])&/@axes; 
dPrint["axes: ", Short[axes, 10]]; 
axes = Last/@axes;
dPrint["axes: ", Short[axes, 10]]; 

tnew = tissue; 

While[Length[tosplit]>0,
j=First[tosplit]; 
vector = First[axes]; 

tosplit=Rest[tosplit];
axes = Rest[axes]; 
dPrint["dividing cell ", j, " along ", vector , " .."]; 
tnew = DivideCell[tnew, j, vector, "Debug"-> dbg]; 

If[SameQ[tnew, $Failed], 
Print["Error Exit: RegularizeMass"]; Return[$Failed]]; 

If[TissueQ[tnew], dPrint[ShowTissue[tnew,"CellNumbers"-> True, ImageSize-> 200]]]; 

(* check daughter cell masses *)

Block[{daughters, areas, more2split, it, newaxes},
daughters = {j,  NTissueCells[tnew]}; 
areas = areafunction[tnew, daughters]; 
more2split = Pick[daughters, Splittable/@areas]; 
it=1;
If[Length[more2split]>0 ,
dPrint["more2split: ", more2split]; 
newaxes  = PrimaryAxesVectors[tnew, more2split]; 
newaxes =Last/@( ({-1,1}*Reverse[#])&/@newaxes);
dPrint["newaxes", newaxes];

tosplit = Join[tosplit, more2split];  
axes = Join[axes, newaxes]; 

]; 
]; 

]; 
(* Now randomize new internal vertices *)

vfinal = TissueVertices[tnew]; 
nvfinal=Length[vfinal];
bv=VerticesOnBoundary[tnew]; 
v2randomize=Complement[Range[nvstart+1, nvfinal], bv]; 

rand = "Randomness"/.{opt}/.Options[Rectangularize];
dPrint["v2randomize: ", v2randomize]; 
dPrint["rand = ", rand]; 

Block[{vnext , ev, e, maxrand, vold, vnew},
e=TissueEdges[tnew]; 
c=TissueCells[tnew]; 
While[Length[v2randomize]>0, 
vnext = First[v2randomize]; v2randomize=Rest[v2randomize]; 
(* edge numbers that contain vnext *)
ev =First/@ Position[e, vnext];
(* edge vertex pairs *)
ev = e[[ev]]; 
(* edge lengths *)
ev = vfinal[[#]]&/@ev; 
ev = distance@@#&/@ev; 
(* min length *)
dist = Min[ev]; 
maxrand = rand * dist; 

dPrint["vnext: ", vnext, " ev: ", ev, " maxrand: ", maxrand];  

vold = vfinal[[vnext]]; 
vnew = vold + {RandomReal[{-maxrand, maxrand}], RandomReal[{-maxrand, maxrand}]}; 
dPrint["vold: ", vold, " vnew: ", vnew]; 
vfinal=ReplacePart[vfinal, vnext -> vnew]; 
]; 
tnew = Tissue[vfinal, e, c]; 
];


Return[tnew]; 
]; 


(* ::Input::Initialization:: *)
(* this form is less elegant and less efficient *)
RemoveInLineVertices[tissue_?TissueQ]:= Module[{tnew,  vnum, e1, e2, ilv,  dPrint, i,imax = 1000,  dbg=False},
dPrint[x___]:=If[dbg, Print["RemoveInLineVertices: ", x]]; 
 
i=1; 
tnew = tissue; 
ilv = InLineVertices[tnew]; 
dPrint[Length[ilv], " vertices to remove."]; 
While[Length[ilv]>0,
{vnum, {e1, e2}}= First[ilv]; 
dPrint["vnum = ", vnum, " {e1, e2}: ", {e1, e2}]; 
tnew = MergeEdges[tnew, e1, e2, "Undangle"-> False]; 
tnew = UndangleEdges[tnew]; 
tnew=UndangleVertices[tnew]; 
If[dbg, Print[ShowTissue[tnew, Frame-> False,  "CellNumbers"-> True,"VertexNumbers"-> True,"EdgeNumbers"-> True,  "Vertices"-> {PointSize[.05], LightBlue}, ImageSize-> 250]]]; 

ilv = InLineVertices[tnew]; 
i++; 
If[i>imax, 
Print["Warning: RemoveInLineVertices: exceeded imax. Infinite loop suspected."];
Return[tnew]]; 
]; 

tnew = UndangleEdges[tnew]; 
tnew=UndangleVertices[tnew]; 

Return[tnew]; 
];

(* This form does not work if there are multiple ilv's in a single edge *)
RemoveInLineVertices[tissue_?TissueQ, ilv_]:= Module[{tnew, v, e, c, toRemove, vnum, e1, e2}, 
v=TissueVertices[tissue];
e=TissueEdges[tissue];
c=TissueCells[tissue]; 

toRemove=ilv;
tnew=tissue;
While[Length[toRemove]>0,
{vnum, {e1, e2}}= First[toRemove]; 
toRemove=Rest[toRemove]; 
tnew = MergeEdges[tnew, e1, e2, "Undangle"-> False]; 
]; 
tnew = UndangleEdges[tnew]; 
tnew=UndangleVertices[tnew]; 

Return[tnew]; 
];


(* ::Input::Initialization:: *)
AddCorners[tissue_?TissueQ,{{xmin_,ymin_},{xmax_,ymax_}}]:=Module[{vec,bv,bvxy,debug=False,dPrint,eps,onBottom,onTop,onLeft,onRight,OnBottom,OnTop,OnLeft,OnRight, cvn, TopRight, TopLeft, BottomRight, BottomLeft, cob, bl, br, tl, tr, q, v, e, c, needbl, needbr, needtl, needtr},eps=(0.001)*Sqrt[Mean[areafunction[tissue]]];dPrint[x___]:=If[debug,Print["AddCorners: ",x]];v=TissueVertices[tissue];
e=TissueEdges[tissue];
c=TissueCells[tissue];

bv=VerticesOnBoundary[tissue];
bvxy=v[[bv]];

(* functions to determine if point is on particular edge *)

OnBottom[{x_,y_}]:=y<=ymin+eps;
OnTop[{x_,y_}]:=y>=ymax-eps;
OnLeft[{x_,y_}]:=x<=xmin+eps;
OnRight[{x_,y_}]:=x>=xmax-eps;

(* classify the points on the boundary *)
onBottom=Pick[bv,OnBottom/@bvxy];
onTop=Pick[bv,OnTop/@bvxy];
onLeft=Pick[bv,OnLeft/@bvxy];
onRight=Pick[bv,OnRight/@bvxy];

dPrint["onBottom:",onBottom];
dPrint["onTop: ",onTop];
dPrint["onLeft:" , onLeft]; 
dPrint["onRight:", onRight]; 

(* identify the edge on each "corner" that has one point on one tissue-edge and one point on another tissue-edge *)

cob = EdgesOnBoundary[tissue];
cvn = e[[cob]]; 

BottomLeft[evn_]:= Length[Intersection[evn, onBottom]]>0 \[And]
Length[Intersection[evn, onLeft]]>0;

BottomRight[evn_]:= Length[Intersection[evn, onBottom]]>0 \[And]
Length[Intersection[evn, onRight]]>0;

TopRight[evn_]:= Length[Intersection[evn, onTop]]>0 \[And]
Length[Intersection[evn, onRight]]>0;

TopLeft[evn_]:= Length[Intersection[evn, onTop]]>0 \[And]
Length[Intersection[evn, onLeft]]>0;

bl=Pick[cob, BottomLeft/@cvn];
br = Pick[cob, BottomRight/@cvn]; 
tl=Pick[cob, TopLeft/@cvn]; 
tr = Pick[cob, TopRight/@cvn]; 

dPrint["{bl,br, tl, tr}:", {bl, br, tl, tr}]; 

Block[{flag},
(* if length = 1, need a corner; if length=2 corner is already there; if length >2 or <1, error *)

{needbl, needbr, needtl, needtr}=(Length[#]==1)&/@{bl, br, tl, tr}; 

flag=False; 
MapThread[If[Length[#1]>2, Print["Error: AddCorners: Incorrect number of ", #2," edges = ", Length[#1], "; should be either one or two."];flag=True;]&, {{bl,br, tl, tr}, {"Bottom-Left","Bottom-Right", "Top-Left", "Top-Right"} }];
If[flag, 
Print[ShowTissue[tissue,"CellNumbers"-> True, "VertexNumbers"-> True, "EdgeNumbers"-> True,  ImageSize-> 250, PlotLabel-> "Tissue at Error"]]; 
Return[$Failed]]; 
]; 

dPrint["{need bl br tl tr}:", {needbl, needbr, needtl, needtr}]; 

{bl, br, tl, tr}=First/@(PadRight[# ,1, $Failed]&/@{bl,br,tl, tr}); 
dPrint["{bl,br, tl, tr}:", {bl, br, tl, tr}]; 

q=tissue;
 If[needbl, q=DivideEdge[q, bl, {xmin,ymin}]]; 
 If[needbr, q=DivideEdge[q, br, {xmax, ymin}]]; 
 If[needtl, q=DivideEdge[q, tl, {xmin, ymax}]]; 
 If[needtr, q=DivideEdge[q, tr, {xmax, ymax}]]; 

Return[q];
]; 

AddCorners[x___]:=(Print["Error: AddCorners."];$Failed);


(* ::Input::Initialization:: *)
ProjectVerticesToBoundary[tissue_,"Perpendicular",  {{xmin_,ymin_}, {xmax_, ymax_}}, debug_]:= 
Module[{v,bv, bvxy,  dPrint, top, bottom, left, right, topi,bottomi, lefti, righti, perps, minDist, projections},
dPrint[x___]:= If[debug, Print["ProjectVerticesToBoundary: ", x]]; 

v=TissueVertices[tissue];
bv=VerticesOnBoundary[tissue];
If[debug,  Global`$BV=bv]; 
bvxy=v[[bv]];
If[debug, Global`$BVXY1=bvxy];

bottom={{xmin,ymin}, {xmax,ymin}}; 
top={{xmin,ymax}, {xmax, ymax}}; 
left={{xmin,ymin}, {xmin, ymax}}; 
right={{xmax, ymin}, {xmax, ymax}}; 

bottomi=DropPerpendicular[#, bottom]&/@bvxy;
topi=DropPerpendicular[#,top]&/@bvxy;
lefti=DropPerpendicular[#,left]&/@bvxy;
righti=DropPerpendicular[#, right]&/@bvxy;
perps={bottomi, topi, lefti, righti}; 
perps=Transpose[perps]; 
If[debug,Global`$PERPS=perps]; 

dPrint["bvxy: ",Short[ bvxy, 5]];
(* dPrint["int points: ", perps];  *)

minDist[pt_?NumericPointQ, {pts__?NumericPointQ}]:= Module[{distances, projection}, 
distances = 1.0*distance[pt,#]&/@{pts};
distances=Transpose[{distances, {pts}}];
projection=distances=Sort[distances][[1,2]];
Return[projection]; 
];

projections = MapThread[minDist, {bvxy, perps}];
dPrint["projections: ",Short[ projections, 5]];
If[debug, Global`$Projections=projections]; 

Return[projections];
];
ProjectVerticesToBoundary[tissue_,method_,  {{xmin_,ymin_}, {xmax_, ymax_}}, debug_]:= (Print["Error: ProjectVerticesToBoundary: Unkown Method: ", method]; Return[$Failed]); 


(* ::Input::Initialization:: *)
GetCorners[tissue_?TissueQ, "Automatic"]:= Module[{v,  xmin, ymin, xmax, ymax},
v=TissueVertices[tissue]; 

xmin = Min[First/@v]; 
xmax = Max[First/@v];
ymin = Min[Last/@v]; 
ymax = Max[Last/@v]; 

{{xmin,ymin}, {xmax,ymax}}
]; 
GetCorners[tissue_?TissueQ, {{xmin_, ymin_}, {xmax_, ymax_}}]:= Module[{axmin,aymin,axmax,aymax},
{{axmin,aymin}, {axmax, aymax}}= GetCorners[tissue, "Automatic"]; 
If[xmin> axmin \[Or] xmax < axmax \[Or] ymin > aymin \[Or] ymax < aymax,
Print["Error: GetCorners: specified corners must be exterior to tissue. Input values will be ignored."];
Return[{{axmin, aymin}, {axmax, aymax}}]
];
Return[{{xmin,ymin}, {xmax, ymax}}]
]; 
GetCorners[tissue_?TissueQ, x___]:= (Print["Error: GetCorners: Corners type not implemented: ", x, " Expecting \"Automatic\" or {{xmin,ymin}, {xmax,ymax}}"]; $Failed); 
GetCorners[x___]:= (Print["Error: Expecting corners[tissue, corners]"]; $Failed); 



(* ::Input::Initialization:: *)
ToTorus[tissue_?TissueQ, opt___?OptionQ]:= Module[{tnew,v,e,c, debug,inputtolerance, tolerance, dPrint,xs, ys,  bottom, top, left, right, tv, bv, lv, rv, vertexNumbers, nv, el, er, et, eb, eob, whichedges, corners, newvr, newvl, newvt, newvb, nnewvl, nnewvr, nnewvt, nnewvb, nnewvlj, nnewvrj, nnewvtj, nnewvbj, VertexOnEdge, VerticesOnWhichEdge, VertexEdgePairs, EdgeMatches},
debug = "Debug"/.{opt}/.Options[ToTorus]; 
inputtolerance="Tolerance"/.{opt}/.Options[ToTorus]; 
dPrint[x___]:= If[debug, Print["ToTorus: ", x]]; 

v=TissueVertices[tissue]; 
c=TissueCells[tissue];
e=TissueEdges[tissue];
eob = EdgesOnBoundary[tissue]; 
 
nv = Length[v]; 
vertexNumbers=Range[nv]; 

tolerance = inputtolerance * Sqrt[Mean[areafunction[tissue]]]; 

dPrint["Tolerance:", tolerance]; 

(* determine the edges *)

{xs, ys}= Transpose[v]; 
bottom = Min[ys]; top = Max[ys]; 
left = Min[xs]; right = Max[ys]; 

(* determine the vertices on the edges *)

tv =Pick[vertexNumbers, (Abs[#-top]<tolerance)&/@ys]; 
bv =Pick[vertexNumbers, (Abs[#-bottom]<tolerance)&/@ys]; 
lv= Pick[vertexNumbers,(Abs[#-left]<tolerance)&/@xs];
rv =Pick[vertexNumbers,(Abs[#-right]<tolerance)&/@xs]; 

(* determine the edge numbers of the edges *)

whichedges[ver_]:=  Select[eob, MemberQ[ver, First[e[[#]]]] \[And] MemberQ[ver, Last[e[[#]]]]&];

et =whichedges[tv]; 
eb = whichedges[bv]; 
el= whichedges[lv]; 
er = whichedges[rv]; 

(* now remove the corners - this must be done AFTER the edges are identified *)

corners=Join[Intersection[tv,lv], Intersection[tv,rv], Intersection[bv,lv], Intersection[bv,rv]]; 
dPrint["corners: ", corners]; 
tv=Complement[tv, corners]; 
bv=Complement[bv, corners]; 
lv=Complement[lv, corners]; 
rv=Complement[rv, corners]; 

dPrint["top:    ", tv, ", edges: ", et];
dPrint["bottom: ", bv,  ", edges: ", eb]; 
dPrint["left:   ", lv, ", Edges: ", el]; 
dPrint["right:  ",rv, ", Edges: ", er];

(* add new vertices *)

newvt={v[[#, 1]], top}&/@bv;
nnewvt = Length[newvt]; 
nnewvtj=Range[nv+1, nv + nnewvt]; 
nv = nv+nnewvt;

newvb={v[[#, 1]], bottom}&/@tv; 
nnewvb = Length[newvb]; 
nnewvbj=Range[nv+1, nv+nnewvb]; 
nv = nv + nnewvb; 

newvl={left, v[[#, 2]]}&/@rv;
nnewvl = Length[newvl]; 
nnewvlj=Range[nv+1, nv+nnewvl]; 
nv = nv+nnewvl; 

newvr={right, v[[#, 2]]}&/@lv; 
nnewvr = Length[newvr]; 
nnewvrj = Range[nv+1, nv+nnewvr]; 
nv = nv+nnewvr; 

dPrint["new top v indices:    ", nnewvtj]; 
dPrint["new bottom v indices: ", nnewvbj]; 
dPrint["new left v indices:   " , nnewvlj]; 
dPrint["nnew right v indices:  ", nnewvrj];
dPrint["new nv: ", nv]; 
v=Join[v, newvt, newvb, newvl, newvr]; 

(* figure out which outer edge each new vertex lies on *)

VertexOnEdge[vnum_, enum_]:= 
PointOnLineSegment[v[[e[[enum]]]],v[[vnum]]];

VerticesOnWhichEdge[vnums_, enums_]:= Module[{vonedge, nver, vertex, k,savebug, dbg=False, edges},
savebug=debug; 
debug=dbg; 
nver =Length[vnums]; 
edges={}; 
For[k=1,k<= nver, k++ , 
vertex = vnums[[k]]; 
vonedge = VertexOnEdge[vertex, #]&/@enums;
dPrint["k: ", k, " vertex: ", vertex, " enums: ", enums, " vonedge: ", vonedge]; 
vonedge = Pick[enums, vonedge]; 
If[Length[vonedge]>1, Print["Error: ToTorus: VerticesOnEdge: Vertex ", vertex," is on multple edges: ", vonedge];
]; 
If[Length[vonedge]<1, Print["Error: ToTorus: VerticesOnEdge: Vertex ", vertex, " is not on any edge."]; 
vonedge={$Failed}; 
];
vonedge=First[vonedge]; 
AppendTo[edges, vonedge]; 
dPrint["vertex: ", vertex, " edge: ", vonedge]; 
];
debug=savebug; 
Return[Transpose[{vnums, edges}]]; 
];

(* get a list of the outer new vertices and their corresponding edges *)

VertexEdgePairs=Join[
VerticesOnWhichEdge[nnewvtj, et],
VerticesOnWhichEdge[nnewvbj, eb], 
VerticesOnWhichEdge[nnewvlj, el], 
VerticesOnWhichEdge[nnewvrj, er] 
]; 
dPrint["VertexEdgePairs: ", VertexEdgePairs]; 

(* divide the tissue at the identified locations *)

tnew = tissue;
Block[{vertex, edge, vep},
vep = VertexEdgePairs; 
While[Length[vep]>0,
{vertex, edge}=First[vep];
dPrint["inserting vertex ", vertex, " in edge ", edge, " .."];  
vep=Rest[vep]; 
vertex=v[[vertex]]; 
tnew = DivideEdge[tnew, edge, vertex];
]
]; 

eob=EdgesOnBoundary[tnew];
dPrint["eob: ", eob]; 

(* deterermine the toroidal matching *)
Block[{eobv,eobvxy,  edges, vert, topedges, bottomedges, leftedges, rightedges, matches, ETopQ, EBottomQ, ERightQ, ELeftQ, ELeft, ERight, ETop, EBottom, GetLeftx, GetBottomy, ETopx, EBottomx, ELefty, ERighty, SortBy}, 
matches[x_, y_]:= Abs[x-y]<tolerance;
matches[x_, y_, z_]:= And[matches[x,y], matches[y,z]];  

edges = TissueEdges[tnew]; 
vert = TissueVertices[tnew]; 

eobv = edges[[#]]&/@eob;
eobvxy = vert[[#]]&/@eobv; 
dPrint["eobv: ", eobv]; 
dPrint["eobvxy: ", eobvxy]; 

ETopQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[y1, y2, top]; 
EBottomQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[y1, y2, bottom]; 
ELeftQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[x1, x2, left]; 
ERightQ[{{x1_, y1_}, {x2_, y2_}}]:= matches[x1, x2, right]; 

ETop =Pick[eob,  ETopQ/@eobvxy]; 
EBottom =Pick[eob,  EBottomQ/@eobvxy]; 
ELeft =Pick[eob,  ELeftQ/@eobvxy]; 
ERight =Pick[eob,  ERightQ/@eobvxy]; 
GetLeftx[{{x1_, y1_}, {x2_, y2_}}]:=First[ Sort[{x1, x2}]]; 
GetBottomy[{{x1_, y1_}, {x2_, y2_}}]:= First[Sort[{y1, y2}]]; 

ETopx =GetLeftx/@Pick[eobvxy,  ETopQ/@eobvxy]; 
EBottomx =GetLeftx/@Pick[eobvxy,  EBottomQ/@eobvxy]; 
ELefty =GetBottomy/@Pick[eobvxy,  ELeftQ/@eobvxy]; 
ERighty =GetBottomy/@Pick[eobvxy,  ERightQ/@eobvxy]; 


If[Length[ETop]!= Length[EBottom], Print["Program Error: ToTorus: Number of Top Edges = ", ETop, " is different from the number of Bottom Edges= ", EBottom]; Return[$Failed]; ]; 
If[Length[ELeft]!= Length[ERight], Print["Program Error: ToTorus: Number of Left Edges = ", ELeft, " is different from the number of Right Edges= ", ERight]; Return[$Failed]; ]; 

dPrint["ETop:    ", ETop]; 
dPrint["EBottom: ", EBottom]; 
dPrint["ERight:  " ,ERight]; 
dPrint["ELeft:   ", ELeft]; 

dPrint["ETopx:    ", ETopx]; 
dPrint["EBottomx: ", EBottomx]; 
dPrint["ERighty:  " ,ERighty]; 
dPrint["ELefty:   ", ELefty]; 

SortBy[list_, keys_]:=Last[ Transpose[Sort[Transpose[{keys, list}]]]]; 

ETop = SortBy[ETop, ETopx]; 
EBottom = SortBy[EBottom, EBottomx]; 
ELeft= SortBy[ELeft, ELefty]; 
ERight = SortBy[ERight, ERighty]; 

dPrint["ETop:    ", ETop]; 
dPrint["EBottom: ", EBottom]; 
dPrint["ERight:  " ,ERight]; 
dPrint["ELeft:   ", ELeft]; 


EdgeMatches =Sort[Join[
MapThread[Rule, {ETop, EBottom}], 
MapThread[Rule, {EBottom, ETop}], 
MapThread[Rule, {ELeft, ERight}], 
MapThread[Rule, {ERight, ELeft}]
]]; 

(* Pick out matches (larger edge #)--> (Smaller Edge #) only *)

EdgeMatches=
Rule@@#&/@Union[Reverse/@Sort/@EdgeMatches/.{Rule-> List}];

dPrint["EdgeMatches: ", EdgeMatches]; 

]; (* end Block *)

Return[Torus[tnew, EdgeMatches]]; 

(*
Return[Tissue[v,e,c]];
*) 


];



(* ::Input::Initialization:: *)
TorusQ[Torus[x_?TissueQ, y_]]:= Module[{isrule, ok}, 
isrule[z_Rule]:= True;
isrule[z___]:= False; 
If[!ListQ[y], Return[False]]; 
ok = isrule/@y; 
Return[And@@ok]; 
];
TorusQ[x___]:= False; 

TorusCheck[Torus[tissue_, rules_]]:= Module[{tissuecheck, isrule, ok}, 
tissuecheck = TissueCheck[tissue]; 
If[!tissuecheck, Print["TorusCheck: First argument of Torus[..] is not a valid Tissue object."];
]; 
isrule[z_Rule]:= True;
isrule[z___]:= False; 
If[!ListQ[rules],
Print["TorusCheck: Second argument is not a list of rules."]; 
 Return[False]]; 
ok = isrule/@rules; 
ok = And@@ok; 
If[ok, Print[Length[rules], " edge matching rules. "]]; 
If[!ok,
Print["TorusCheck: Second argument is not a list of rules."]; 
 Return[False]]; 
Return[tissuecheck]; 
];
TorusCheck[x___]:=(Print["Error: Expecting TorusCheck[Torus[Tissue[], rules]"]; $Failed); 


(* ::Input::Initialization:: *)
TorusTissue[Torus[tissue_, rules_]]:= Module[{ok},
ok = TorusQ[Torus[tissue, rules]]; 
If[Not[ok],
Print["Error: TorusTissue: Invalid Torus object. "];
TorusCheck[Torus[tissue, rules]];
 Return[$Failed];
];
Return[tissue]; 
];
TorusTissue[x___]:=(Print["Error: expecting TorusTissue[Torus[..]]."]; $Failed); 
TorusRules[Torus[tissue_, rules_]]:= Module[{ok},
ok = TorusQ[Torus[tissue, rules]]; 
If[Not[ok],
Print["Error: TorusRules: Invalid Torus object. "];
TorusCheck[Torus[tissue, rules]];
 Return[$Failed];
];
Return[rules]; 
];
TorusRules[x___]:=(Print["Error: expecting TorusRules[Torus[..]]."]; $Failed); 


(* ::Input::Initialization:: *)
DTissueQ[DTissue[v_?ListQ,e_?ListQ,c_?ListQ]]:= RuleQ[c];
DTissueQ[x___]:= False;
ISTissue[x___]:= TissueQ[x]\[Or]DTissueQ[x];


(* ::Input::Initialization:: *)
Tissue2DTissue[tissue_?TissueQ,opt___?OptionQ]:= Module[{numbers,v,e,c,nc,maxnumber},
numbers ="Numbers"/.{opt}/.{"Numbers"-> {}}; 
v=TissueVertices[tissue];
c=TissueCells[tissue]; 
e=TissueEdges[tissue]; 
nc=Length[c]; 
If[numbers=={}, numbers=Range[nc]]; 
maxnumber=Max[numbers]; 
While[Length[numbers]<nc,
maxnumber++;
AppendTo[numbers, maxnumber]
]; 
c=MapThread[Rule,{numbers,c}]; 
DTissue[v,e,c]
];
Tissue2DTissue[x___]:= $Failed


(* ::Input::Initialization:: *)
DTissue2Tissue[DTissue[v_,e_,c_]]:= 
If[DTissueQ[DTissue[v,e,c]],Tissue[v,e,Last/@c],$Failed];
DTissue2Tissue[DTissue[v_,e_,c_], sim_,time_,x_:Global`x,y_:Global`y]:= Module[{vnew,NV,vused,vflags,vold},
NV = Length[v]; 
vused=VerticesUsed[DTissue[v,e,c]]; 
vflags = MemberQ[vused,#]&/@Range[NV]; 
vold = ({x[#][time],y[#][time]}&/@Range[NV])/.Flatten[sim];

vnew = MapThread[
If[#1, #2,{\[Infinity],\[Infinity]}]&,{vflags,vold}
];

Tissue[vnew,e,Last/@c]
];

DTissue2Tissue[x___]:= $Failed; 


(* ::Input::Initialization:: *)
DeleteCell[dtissue_?DTissueQ, n_]:= Module[{v,e,c,T,cells,indices, found},
v=TissueVertices[dtissue];
e=TissueEdges[dtissue];
c=TissueCells[dtissue];
indices=First/@c; 
found =Flatten[Position[indices,n]];
If[found=={}, 
Print["Warning: attempt to delete non-existent cell ",n, " failed."];
Return[dtissue]];

found=found[[1]]; 
indices = Drop[indices,{found}]; 
cells = Drop[Last/@c, {found}];
c = MapThread[Rule,{indices,cells}]; 
Return[DTissue[v,e,c]]; 

]; 


(* ::Input::Initialization:: *)
CellAreaEquations[tissue_?TissueQ,opt___?OptionQ]:= Module[{x,y,area, xy},
xy="xy"/.{opt}/.{"xy"-> True}; 

x = "x"/.{opt}/.{"x"-> Global`x}; 
y = "y"/.{opt}/.{"y"-> Global`y}; 
area="CellVariable"/.{opt}/.{"CellVariable"-> Global`cell};
If[ToString[area]=="False", Return[{}]]; 
AbortIf[ToString[xy]=="False", "\"CellVariable\"\[Rule]"<>ToString[area]<>" but \"xy\"\[Rule]False; vertex coordinates must be recorded if the area is to be calculated."];
CellAreaEquations[tissue,x,y,area,opt]
]; 
CellAreaEquations[tissue_?TissueQ,x_,y_, area_,opt___?OptionQ]:= Module[{vertices, f,cellnumbers,nc,eqlhs, eqrhs, equations},

vertices = CellVertexNumbers[tissue];
nc = Length[vertices];  
(* area function for a single cell *)
f[vlist_]:= Module[{coords}, 
coords={x[#][Global`t],y[#][Global`t]}&/@vlist;
areafunction[coords]
];
cellnumbers = "Numbers"/.{opt}/.{"Numbers"-> {}}; 
If[cellnumbers=={}, cellnumbers = Range[nc]]; 
If[Length[cellnumbers]<nc, Print["Error: ", Length[cellnumbers], " cell numbers provided for ", nc," cells."]; Return[$Failed]]; 
eqlhs = areafunction[#][Global`t]&/@cellnumbers; 
eqrhs = f/@vertices;
equations = MapThread[Equal,{eqlhs,eqrhs}]
];
CellAreaEquations[tissue_?DTissueQ,opt___?OptionQ]:= Module[{cellnumbers, T},
T=DTissue2Tissue[tissue]; 
cellnumbers = First/@TissueCells[tissue]; 
CellAreaEquations[T,"Numbers"-> cellnumbers, opt]
];
CellAreaEquations[tissue_?DTissueQ, x_,y_,area_,opt___?OptionQ]:= Module[{cellnumbers, T},
T=DTissue2Tissue[tissue]; 
cellnumbers = First/@TissueCells[tissue]; 
CellAreaEquations[T,x,y,area,"Numbers"-> cellnumbers, opt]
]


(* ::Input::Initialization:: *)
FastPolyArea[r_,angle1_,angle2_, nint_:50]:=Module[{angles, dtheta,rs,left,right,sindtheta},
dtheta = Abs[angle2-angle1]/nint; 
sindtheta = Sin[dtheta]; 
angles=Table[angle1+i*dtheta,{i,0,nint}];
rs = r/@angles;
(Most[rs].Rest[rs])*0.5*sindtheta
];


(* ::Input::Initialization:: *)
FastTrapPolyArea[r_,angle1_,angle2_,nint_:50]:= Module[{dtheta,angles,rs,first, last},
dtheta = Abs[angle2-angle1]/nint; 
angles=Table[angle1+i*dtheta,{i,0,nint}];
rs = r/@angles;
rs = #^2&/@rs; 
first = First[rs]; last = Last[rs]; 
((first + last) + (Plus@@rs))*(angle2-angle1)/(2.0*nint)
]


(* ::Input::Initialization:: *)
FastTrapPartialArea[r_,angle1_,angle2_,nint_:50]:=Module[{sector,triangle,DTR,r1,r2,r3,a1,a2,sign},a1=Min[angle1,angle2];
a2=Max[angle1,angle2];
sector=FastTrapPolyArea[r,angle1,angle2,nint];
r1=r[angle1];r2=r[angle2];
triangle=Hero2[r1,r2,(angle2-angle1)];
sign=If[Abs[angle1-angle2]<Pi,-1,1];
sector+sign*triangle]


(* ::Input::Initialization:: *)
FastPolyPartialArea[r_,angle1_,angle2_,nint_: 50]:=
Module[{sector,triangle,r1,r2,a1,a2,sign},
a1=Min[angle1,angle2];
a2=Max[angle1,angle2];
sector=FastPolyArea[r,angle1,angle2,nint];
r1=r[angle1];r2=r[angle2];
triangle=Hero2[r1,r2,(angle2-angle1)];
sign=If[Abs[angle1-angle2]<Pi,-1,1];
sector+sign*triangle]


(* ::Input::Initialization:: *)
PartialArea[r_,theta1_,theta2_,n_]:=Module[{pts,dt},
If[theta1==theta2, Return[0]]; 
dt=(theta2-theta1)/n;
pts=r[#] {Cos[#],Sin[#]}&/@Range[theta1,theta2-dt,dt];
If[Length[pts]<3,Return[0.]];
areafunction[pts]]


(* ::Input::Initialization:: *)
FastPolyDegAreaSector[r_,angle1_,angle2_,nint_: 50]:=Module[{angles,dtheta,rs,left,right,sindtheta,DTR},
DTR=Pi/180.0;
dtheta=Abs[angle2-angle1]/nint;
sindtheta=Sin[dtheta*DTR];
angles=Table[angle1+i*dtheta,{i,0,nint}];
rs=r/@angles;
(Most[rs].Rest[rs])*0.5*sindtheta];

FastPolyDegArea[r_,angle1_,angle2_,nint_: 50]:=Module[{sector,triangle,DTR,r1,r2,r3,a1,a2,sign},
a1=Min[angle1,angle2];
a2=Max[angle1,angle2];
sector=FastPolyDegAreaSector[r,angle1,angle2,nint];
DTR=Pi/180.0;
r1=r[angle1];r2=r[angle2];
triangle=Hero2[r1,r2,DTR*(angle2-angle1)];
sign=If[Abs[angle1-angle2]<180,-1,1];
sector+sign*triangle]



(* ::Input::Initialization:: *)
HalfAreaAngle[r_,theta1_,A_]:=Module[{f,x1,x2,y1,y2,i,x3,y3,yprime,imin},f[\[Theta]_]:=FastPolyDegArea[r,theta1,theta1+\[Theta],500]-A/2;
x1=90;x2=180;
y1=f[x1];
y2=f[x2];
For[i=1,((i<=5)\[And](Abs[x1-x2]>.1)),i++,yprime=(y2-y1)/(x2-x1);
x3=x2-(f[x2]/yprime);
y3=f[x3];
x1=x2;x2=x3;y1=y2;y2=y3;];
Return[theta1+x2]];
Errera[r_InterpolatingFunction,npts_]:=Module[{anglepairs,A,point,DTR,points,distances,imin},
DTR=Pi/180.;
A=FastPolyDegArea[r,0,360,500];
anglepairs={#,HalfAreaAngle[r,#,A]}&/@Range[0.,360.,360./npts];
point[theta_]:=r[theta]*{Cos[theta*DTR],Sin[theta*DTR]};
points[angles_]:=point/@angles;
distances=points/@anglepairs;
distances=Norm/@(Subtract@@#&/@distances);
imin=Ordering[distances,1][[1]];
{anglepairs[[imin]],points[anglepairs[[imin]]]}];
Errera[vertices_?ListQ,npts_]:=Module[{center,xyz,angles,rdeg,data,rrad, result, point1,point2,dbg=False, dPrint},
dPrint[x___]:= If[dbg, Print["Errera: ", x]]; 
center=Centroid[vertices];
xyz=(#-center)&/@vertices;
rrad=RadialPolygon[xyz,npts];
data=Table[{theta*180.0/Pi,rrad[theta]},{theta,0,2 Pi,2.0*Pi/npts}];
rdeg=Interpolation[data,InterpolationOrder->1,PeriodicInterpolation->True];
{angles, {point1,point2}}=Errera[rdeg,npts];
angles = Sort[Mod[#,360]&/@angles];
result={angles,center+point1,center+point2};
dPrint["vertices: ", xyz]; 
dPrint["result: ", result];
dPrint[Graphics[{Line[Append[xyz,First[xyz]]], PointSize[.02],Dashed, Line[{point1,point2}],  Point[{point1,point2}]}]]; 

Return[result]
]



(* ::Input::Initialization:: *)
AreaPotentialMatrix[points_,dtheta_,opt___?OptionQ]:=Module[{A,r,n, theta1,theta2,delta,v,V,i,j,m},
n="Intervals"/.{opt}/.{"Intervals"-> 100}; 
r=RadialPolygon[points,n];
(* A=NIntegrate[r[t]*r[t]/2.0,{t,0,2Pi},Method\[Rule]"TrapezoidalRule"]; *)
A=FastPolyArea[r,0,2Pi,n];
delta = dtheta *Pi/180; 
m=Round[360.0/dtheta];
V=Table[0,{i,0,m}, {j,0,m}]; 

For[i=0,i<= m, i++, 
theta1 = i*delta; 
V[[i+1,i+1]]=Infinity; 
For[j=i+1,j<= m,j++,
theta2=j*delta; 
v = AreaPotentialFunction[r,A,theta1,theta2]; 
V[[i+1,j+1]]=v;
V[[j+1,i+1]]=v; 

];
];
V
];
AreaPotentialFunction[r_,A_,theta1_,theta2_]:= Module[{r1,r2,Astart,Aend,triangle,A1,A2,min,max,n1, angle1, angle2, teeny=.001},
If[theta1== theta2, Return[1]]; 
{angle1, angle2}=Sort[Mod[#,2Pi]&/@{theta1, theta2}]; 
If[Abs[angle1-angle2]<teeny, Return[1]]; 

A1 = FastPolyPartialArea[r, angle1, angle2, 50];
(*A2 = FastPolyArea[r, 0, 2Pi,50]-A1;*)
A2=A-A1;
 
((A1-A2)/A)^2
]


(* ::Input::Initialization:: *)
$LENGTH\[UnderBracket]ALT\[UnderBracket]MULT=1.0;
LengthPotentialFunction[r_,dmin_, theta1_, theta2_]:= Module[{r1, r2,x1,y1,x2,y2,d,v1,v2,v3,cosa,sina,h,V,teeny=.0001, altitude, a, dbg=False, dPrint},
dPrint[x___]:= If[dbg, Print["LengthPotentialFunction: ", x]]; 
r1=r[theta1]; 
r2=r[theta2];
x1=r1*Cos[theta1]; x2=r2*Cos[theta2];
y1=r1*Sin[theta1]; y2=r2*Sin[theta2]; 
v1={x1,y1};v2={x2,y2}; 
v3 =v2-v1; 
d=v3.v3;
d=Abs[d];

If[d>teeny*dmin, d=Sqrt[d], d=0];  
a=Norm[v3]; 
altitude=0;
dPrint["a,r1,r2:", {a,r1,r2}];
If[a>0,
altitude = AltitudeTriangle[a, r1, r2]];

dPrint["altitude,d,dmin: ", altitude, ",", d,",",dmin]; 


(* cosa = Abs[Normalize[v1].Normalize[v3]];
sina = Sqrt[Abs[1.0-cosa*cosa]];
h=r1*sina ; *)
V= + ((d-dmin )^2+$LENGTH\[UnderBracket]ALT\[UnderBracket]MULT*altitude^2)/(d+dmin)^2 ; 
Return[V];
]



(* ::Input::Initialization:: *)
$DIRECTION\[UnderBracket]ALT\[UnderBracket]MULT=1;
$DIRECTION\[UnderBracket]EXPONENT=2; 
DirectionPotentialFunction[r_, thetaa1_, thetaa2_,v_]:= Module[{r1,r2,x1,x2,y1,y2,v1,v2,v3,v4,val,lv3,theta1,theta2,n, teeny=.001*Pi/180.,V,altitude},
theta1=Mod[thetaa1,2 Pi];
theta2=Mod[thetaa2,2 Pi];
{r1,r2}={r[theta1],r[theta2]};
x1=r1*Cos[theta1];x2=r2*Cos[theta2];
y1=r1*Sin[theta1];y2=r2*Sin[theta2];
v1={x1,y1};v2={x2,y2};
v3=v2-v1;
lv3=Norm[v3];
v3=Normalize[v3];
v4=Normalize[v];
(* val=(v2.v4-v1.v4)^2; *)
(*Print[{lv3,val,lv3,val/(lv3*lv3)}];*)

n=$DIRECTION\[UnderBracket]EXPONENT;
V=If[lv3<teeny,0.0,(v3.v4)^n];

(* altitude=AltitudeTriangle1[r1,r2,theta2-theta1]; *)
altitude = 0;
If[lv3>0, 
altitude=AltitudeTriangle[lv3,r1, r2];
altitude=altitude/(.5 (r1+r2));
]; 

V+$DIRECTION\[UnderBracket]ALT\[UnderBracket]MULT*altitude
]


(* ::Input::Initialization:: *)
DivisionPotential[r_,A_,dmin_, weights_?ListQ,VGrowth_?ListQ, VCell_?ListQ,{theta1_,theta2_}]:= Module[{w,v, VA, VL, VD,VX,q1,q2,VTotal,u,w1,w2,w3,w4,vg,vc, dbg=False, dPrint},
dPrint[x___]:= If[dbg, Print["DivisionPotential: ", x]]; 

w1=If[Length[weights]>0,weights[[1]],1.0]; 
w2=If[Length[weights]>1,weights[[2]],0.0]; 
w3=If[Length[weights]>2,weights[[3]],0.0]; 
w4=If[Length[weights]>3,weights[[4]],0.0]; 
dPrint["weights: ", {w1,w2,w3,w4}]; 
w=Normalize[Abs/@{w1,w2,w3,w4}]; 
vg=Normalize[VGrowth];
vc = Normalize[VCell];  
(* q1=theta1*Pi/180;
q2=theta2*Pi/180;*) 
{q1,q2}={theta1,theta2}; 
If[w1>0, VA=AreaPotentialFunction[r,A,q1,q2], VA=0];
dPrint[VA]; 
If[w2>0, 
VL=LengthPotentialFunction[r,dmin, q1,q2], 
VL= 0];
If[w3>0, VD=DirectionPotentialFunction[r,q1,q2,vg], VD=0];
If[w4>0, VX=DirectionPotentialFunction[r,q1,q2,vc], VX=0];
dPrint["w=",w, " w2>0:",w2>0]; 
dPrint[{VA, VL,VD, VX}]; 

VTotal=w.{VA,VL,VD, VX};
Return[VTotal];
]


(* ::Input::Initialization:: *)
$DEBUGMINIMIZATION=False;
GlobalSearchMinimizationOfDivisionPotential[R_,A_,d_,w_,v1_,v2_, dangle_:3.6,angleDiffMin_: 135]:=Module[{x,y,f,F,xmin,ymin,val,angle1,angle2,vnew,delta,dbg=$DEBUGMINIMIZATION, dPrint, fdata, fdatarow},
dPrint[u___]:= If[dbg, Print["GlobalSearchMinimizationOfDivisionPotential: ", u]]; 

f[x_,y_]:=DivisionPotential[R,A,d,w,v1,v2,{x,y}];
F[x_,y_]:=f[x*Pi/180.0,y*Pi/180];
val=Infinity;
fdata={}; 
For[angle1=0,angle1<360,angle1=angle1+dangle,
For[angle2=angle1+dangle,angle2<360,angle2=angle2+dangle,
fdatarow={};
delta = Abs[angle1-angle2];
If[Min[delta,360.0-delta]<angleDiffMin ,Continue[]];
vnew=F[angle1,angle2];
 dPrint[{angle1, angle2, vnew}]; 
If[vnew<val,
val=vnew;xmin=angle1;ymin=angle2;
dPrint["===========>>>>New Minimum: ", vnew," at ", {xmin, ymin}];
];
];
];

dPrint["**** About to return: "]; 
dPrint[fdata];
dPrint[{val, xmin, ymin}]; 
{val,xmin,ymin}
]


(* ::Input::Initialization:: *)
$DEBUGOPTIMIZATION=False;
OptimizeDivisionPotential[points_, w_?ListQ,vgrowth_?ListQ,vcell_?ListQ,anglespreadmin_]:= Module[{result,angles,r,A,A1,A2, p1,p2,C,dmin,tab},

If[$DEBUGOPTIMIZATION, Print["OptimizeDivisionPotential (1):  w=",w, " vg=",vgrowth, " vc= ", vcell]; ]; 


r = RadialPolygon[points,100]; 
A = areafunction[points]; 
(*Find minimum pseudo-diameter from 100 points*)
dmin=Min[Table[r[u]+r[u+Pi],{u,0,Pi,Pi/100.0}]]; 
OptimizeDivisionPotential[r, A, dmin, Centroid[points], w,vgrowth,vcell,anglespreadmin]

];

OptimizeDivisionPotential[r_InterpolatingFunction, A_,dmin_, Center_, w_?ListQ,vgrowth_?ListQ,vcell_?ListQ,anglespreadmin_,npts_:50]:= Module[{result,angles,A1,A2, p1,p2,C,tab},
If[$DEBUGOPTIMIZATION, Print["OptimizeDivisionPotential (2):", " vg=",vgrowth, " vc= ", vcell];]; 

result=GlobalSearchMinimizationOfDivisionPotential[r,A,dmin,w,vgrowth, vcell,360./npts,anglespreadmin];
angles = Rest[result]; 

{A1, A2} = (Pi/180.0)*angles; 
p1 = Center+ r[A1]*{Cos[A1], Sin[A1]}; 
p2 = Center+r[A2]*{Cos[A2], Sin[A2]}; 
Return[{angles, p1, p2}];

];

OptimizeDivisionPotential[r_Function, A_,dmin_, Center_, w_?ListQ,vgrowth_?ListQ,vcell_?ListQ,anglespreadmin_]:= Module[{result,angles,A1,A2, p1,p2,C,tab},
If[$DEBUGOPTIMIZATION, Print["OptimizeDivisionPotential (3):  "," vg=",vgrowth, " vc= ", vcell];]; 

result=GlobalSearchMinimizationOfDivisionPotential[r,A,dmin,w,vgrowth, vcell,3.6,anglespreadmin];
angles = Rest[result]; 

{A1, A2} = (Pi/180.0)*angles; 
p1 = Center+ r[A1]*{Cos[A1], Sin[A1]}; 
p2 = Center+r[A2]*{Cos[A2], Sin[A2]}; 
Return[{angles, p1, p2}];

]


(* ::Input::Initialization:: *)
PrincipalCellDirection[T_?DTissueQ,cellnumber_, solution_,time_,xvar_,yvar_]:= Module[{vertexNumbers,vertexNumbersT,coordinates,CM,evals,evec,tissue,C},
vertexNumbers=CellVertexNumbers[T,cellnumber];
vertexNumbersT={xvar[#][Global`t],yvar[#][Global`t]}&/@vertexNumbers;
coordinates =Flatten[ (vertexNumbersT/.solution)/.{Global`t->time}]; 
coordinates = Partition[coordinates, 2]; 
CM=Covariance[coordinates];
evec=Eigenvectors[CM][[1]];

Return[evec];
];

PrincipalCellDirection[x___]:= (Print["Expecting PrincipalCellDirection[Tissue,cell,solution,t,x,y]; x = ",Short/@{x}]);


(* ::Input::Initialization:: *)
PrincipalGrowthDirection[T_?DTissueQ,cellnumber_, solution_,time_,xvar_,yvar_]:= Module[{vertexNumbers,vertexNumbersT,velocities,CM,evals,evec,tissue,C},
vertexNumbers=CellVertexNumbers[T,cellnumber];
vertexNumbersT={xvar[#][Global`t],yvar[#][Global`t]}&/@vertexNumbers;
velocities=Partition[D[#,Global`t]&/@Flatten[vertexNumbersT/.solution],2]/.{Global`t->time};
CM=Covariance[velocities];
evec=Eigenvectors[CM][[1]]
];

PrincipalGrowthDirection[x___]:= (Print["Expecting PrincipalGrowthDirection[Tissue,cell,solution,t,x,y]; x = ",Short/@{x}]);


(* ::Input::Initialization:: *)
CellEigenRatio[T_?TissueQ,i_]:= EigenRatio[CellVertexCoordinates[T,i]]; 
CellEigenRatio[x___]:= AbortIf[True, "Error: Expecting CellEigenRatio[Tissue, index]"]; 
EigenRatio[listOfVertices_?ListQ]:= Module[{Cov, e1, e2, ratio},
AbortIf[
Not[And[ListQ/@listOfVertices]],"Error: EigenRatio: Invalid input (element not a list): "<>ToString[InputForm[x]]];
AbortIf[Length[Union[Length/@listOfVertices]]!= 1, 
"Error: EigenRatio: Invalid input (inconsistent dimensions)"<>ToString[InputForm[x]]]; 

Cov=Covariance[listOfVertices];
{e1,e2}=Eigenvalues[Cov]; 
If[e1!= 0, Return[e1/e2], Return[Infinity]]; 
];
EigenRatio[x___]:= AbortIf[True, "Unexpected Input to EigenRatio: "<>ToString[InputForm[x]]]; 


(* ::Input::Initialization:: *)
PrincipalDirectionFormula[T_Tissue, x___]:= AbortIf[True, "Expecting a DTissue as the first argument to PrincipalDirectionFormula"]; 
PrincipalDirectionFormula[T_?DTissueQ, center_, PD_, x_, y_]:= Module[{PDBASE, PDX, PDY, PDUNITX, PDUNITY, PDNORM, PDEV1, PDEV2, PDMAXEV, PDA, PDB, PDD},
PDBASE = ToString[PD]; 
PDX =ToExpression[PDBASE<>"X"];
PDY =ToExpression[PDBASE<>"Y"];
PDNORM=ToExpression[PDBASE<>"NORM"];

PDUNITX =ToExpression[PDBASE<>"UNITX"];
PDUNITY =ToExpression[PDBASE<>"UNITY"];

PDEV1 =ToExpression[PDBASE<>"EV1"];
PDEV2 =ToExpression[PDBASE<>"EV2"];
PDMAXEV =ToExpression[PDBASE<>"MAXEV"];

PDA =ToExpression[PDBASE<>"A"];
PDB =ToExpression[PDBASE<>"B"];
PDD =ToExpression[PDBASE<>"D"];


PrincipalDirectionFormula[T, center, PDX, PDY, PDNORM, PDUNITX, PDUNITY, PDEV1, PDEV2, PDMAXEV, PDA, PDB, PDD, x, y]
]; 

PrincipalDirectionFormula[T_?DTissueQ, center_, PDX_, PDY_,PDNORM_, PDUNITX_, PDUNITY_, PDEV1_, PDEV2_, PDMAXEV_,PDA_, PDB_, PDD_, x_, y_]:= Module[{n,nc,cvn, cellnumbers, xyvals, cell, M, cosfunc,sinfunc,i,j,  funcs, a,  b, d, discr, ev1, ev2, ev, epsilon=0.01},
n=NTissueVertices[T]; 
nc=NTissueCells[T]; 
cvn=CellVertexNumbers[T]; 
cellnumbers=First/@TissueCells[T];
funcs={};
For[i=1, i<= nc, i++,
cell = cvn[[i]]; 
xyvals = {x[#][Global`t]-center[i,1][Global`t], y[#][Global`t]-center[i,2][Global`t]} &/@cell;
M=Transpose[xyvals].xyvals;
a=M[[1,1]]; 
b=M[[1,2]]; (* matrix is symmetric, b=c *)
d=M[[2,2]]; 
discr=a^2+d^2+b^2-2*a*d; 
ev1 = .5*(a+d+Sqrt[discr]); 
ev2 = .5*(a+d-Sqrt[discr]); 

j=cellnumbers[[i]]; 
(* this is the wrong matrix, need to do SVD before taking cosine or sine *)
AppendTo[funcs, {
PDA[j][Global`t]==a, 
PDB[j][Global`t]==b, 
PDD[j][Global`t]==d, 

PDEV1[j][Global`t]==ev1,
PDEV2[j][Global`t]== ev2,
PDMAXEV[j][Global`t]==Max[PDEV1[j][Global`t], PDEV2[j][Global`t]], 
(* B-epsilon is a check for b>0 with numerical inaccuracies *)
(* PDX is 1 if b>0 OR if b<0 and a>d*)
PDX[j][Global`t]==
.5(1+Sign[Abs[PDB[j][Global`t]]-epsilon]) + 
.5(1-Sign[Abs[PDB[j][Global`t]]-epsilon]).5(1+Sign[PDA[j][Global`t]-PDD[j][Global`t]]),

(* (1/2)(1-Sign(a-d)) = 0 if A>D, and 1 if A< D *)
(* (1/2)(1+Sign[b] = 1/0 if B >0 and 0 otherwise *)
(* (1/2)(1-Sign[b] = 1/0 if B <0 and 0 otherwise *)
(* The epsilon is added to PDB in the denominator to prevent 1/0 calculations *)

PDY[j][Global`t]==(.5(1+Sign[Abs[PDB[j][Global`t]]-epsilon]))*((PDMAXEV[j][Global`t]-PDA[j][Global`t])(Sign[PDB[j][Global`t]])/(Abs[PDB[j][Global`t]]+epsilon))+
(.5(1-Sign[Abs[PDB[j][Global`t]]-epsilon]))(.5*(1-Sign[PDA[j][Global`t]-PDD[j][Global`t]])),

PDNORM[j][Global`t]==Sqrt[PDX[j][Global`t]^2 + PDY[j][Global`t]^2],
PDUNITX[j][Global`t]== PDX[j][Global`t]/PDNORM[j][Global`t],
PDUNITY[j][Global`t]== PDY[j][Global`t]/PDNORM[j][Global`t]
}];
]; 
funcs=Flatten[funcs];
funcs
]


(* ::Input::Initialization:: *)
SVDPrincipalDirectionFormula[T_Tissue]:= AbortIf[True, "Expecting SVDPrincipalDirection[DTissue,...], not Tissue"];
(*SVDPrincipalDirectionFormula[T_?DTissueQ, center_, PD_, x_, y_]:= Module[{PDBASE, PDX, PDY, PD2X,PD2Y, PDUNITX, PDUNITY, PD2N,PDU2X,PDU2Y, PDNORM},
PDBASE = ToString[PD]; 
PDX =ToExpression[PDBASE<>"X"];
PDY =ToExpression[PDBASE<>"Y"];
PD2X =ToExpression[PDBASE<>"2X"];
PD2Y =ToExpression[PDBASE<>"2Y"];
PD2N=ToExpression[PDBASE<>"N"];
PDU2X =ToExpression[PDBASE<>"U2X"];
PDU2Y =ToExpression[PDBASE<>"U2Y"];


PDNORM=ToExpression[PDBASE<>"NORM"];

PDUNITX =ToExpression[PDBASE<>"UNITX"];
PDUNITY =ToExpression[PDBASE<>"UNITY"];

SVDPrincipalDirectionFormula[T, center, PDX, PDY,PD2X,PD2Y,PD2N, PDNORM, PDUNITX, PDUNITY,  x, y]
]; *)

SVDPrincipalDirectionFormula[T_?DTissueQ, center_, PD_,  x_, y_]:= Module[{n,nc,cvn, cellnumbers, xyvals, cell, M, i,j,  funcs, a,  b, d, discr, ev1, ev2, ev, S2T, C2T, \[Epsilon]=0.001, 
PDBASE, PDX, PDY, PD2X, PD2Y,PDUNIT2X,PDUNIT2Y, PD2NORM, PDUNITX, PDUNITY, PDNORM
},

PDBASE = ToString[PD]; 
PDX =ToExpression[PDBASE<>"X"];
PDY =ToExpression[PDBASE<>"Y"];
PD2X =ToExpression[PDBASE<>"2X"];
PD2Y =ToExpression[PDBASE<>"2Y"];
PD2NORM=ToExpression[PDBASE<>"2NORM"];
PDUNIT2X =ToExpression[PDBASE<>"UNIT2X"];
PDUNIT2Y =ToExpression[PDBASE<>"UNIT2Y"];


PDNORM=ToExpression[PDBASE<>"NORM"];

PDUNITX =ToExpression[PDBASE<>"UNITX"];
PDUNITY =ToExpression[PDBASE<>"UNITY"];



n=NTissueVertices[T]; 
nc=NTissueCells[T]; 
cvn=CellVertexNumbers[T]; 
cellnumbers=First/@TissueCells[T];
funcs={};
For[i=1, i<= nc, i++,
cell = cvn[[i]]; 
xyvals = {x[#][Global`t]-center[i,1][Global`t], y[#][Global`t]-center[i,2][Global`t]} &/@cell;
M=Transpose[xyvals].xyvals;
a=M[[1,1]]; 
b=M[[1,2]]; (* matrix is symmetric, b=c *)
d=M[[2,2]]; 
j=cellnumbers[[i]]; 
C2T=(a-d);
S2T=2b; 
AppendTo[funcs, {

PD2X[j][Global`t]==C2T, 
PD2Y[j][Global`t]==S2T, 
(* convert to have of two-theta *)
PD2NORM[j][Global`t]==Sqrt[PD2X[j][Global`t]^2 + PD2Y[j][Global`t]^2],
PDUNIT2X[j][Global`t]==PD2X[j][Global`t]/PD2NORM[j][Global`t],
PDUNIT2Y[j][Global`t]==PD2Y[j][Global`t]/PD2NORM[j][Global`t],



(* If 2\[Theta] is in 1st/2nd quadrant, andswer is in 1st quadrant, use + roots for both sine and cosine *)
(* If 2\[Theta] is in 3rd/4th quadrant, answer is in 2nd/quadrant. This means
positive sine and negative cosine. Negative cosine only occurs when STC is negative *)
(* The Sign[PD2Y] causes an NDSolve stiffness when PD2Y passes through zero;
adding the epsilong curves the functions so the slope is non-infinite *)

PDX[j][Global`t]== (* Sign[PD2Y[j][Global`t]]* *) 
(PD2Y[j][Global`t]/(\[Epsilon]+Abs[PD2Y[j][Global`t]]))*
Sqrt[\[Epsilon]+1.0+PDUNIT2X[j][Global`t]/2.0], 

PDY[j][Global`t]== Sqrt[\[Epsilon]+1.0-PDUNIT2X[j][Global`t]/2.0] 

}];

];  
funcs=Flatten[funcs];
funcs
]


(* ::Input::Initialization:: *)
DetermineL2AnticlinalPlane[T_, i_]:= Module[{cn, l1, v, e, c, cvn, cvni, cvnn,icvn, ipairs, vpairs, ipair, v1, v2, p1, p2, dx, dy, cvc, theta1, theta2, cen, dbg=False, dPrint},
dPrint[u___]:= If[dbg, Print["DetermineL2AnticlinalPlane: ", u]]; 
cn=CellNeighbors[T,i];
l1=L1Cells[T];
(* l1 cells that abut i on L2 *)
cn = Intersection[l1, cn]; 

{v,e, c} = T/.{Tissue-> List}; 
dPrint["cn = ", cn]; 
cvn = CellVertexNumbers[T]; 
(* vertex numbers of cell i *)
cvni=cvn[[i]]; 
cvc =v[[#]]&/@cvni; 
dPrint["cvc: ", cvc]; 
cen = Centroid[cvc]; 
(* vertex numbers of cells Abuting cell i in L1 *)
cvnn = Flatten[cvn[[cn]]]; 
(* common vertex numnbers *)
icvn = Intersection[cvni, cvnn]; 
AbortIf[Length[icvn]<2, "DetermineL2AnticlinalPlane: does not appear to be an L2 cell, i = "<>ToString[InputForm[i]]];
dPrint["icvn: ", icvn]; 
ipairs = Select[Permutations[icvn,{2}], First[#]<Last[#]&]; 
vpairs =distance@@#&/@( v[[#]]&/@ipairs);  
dPrint["ipairs: ", ipairs]; 
dPrint["vpairs: ", vpairs]; 
ipair = Ordering[vpairs,-1];
While[ListQ[ipair] \[And]Length[ipair]>0, ipair=First[ipair]]; 
AbortIf[ListQ[ipair], "DetermineL2AnticlinalPlane: fewer than two vertices of cell are shared with L1. This does not appear to be an L2 cell: "<>ToString[InputForm[i]]]; 
dPrint["ipair: ", ipair]; 
ipair=ipairs[[ipair]]; 
dPrint["ipair: ", ipair]; 
v1=v[[ipair[[1]]]]; 
v2 = v[[ipair[[2]]]];  
dPrint["v1=", v1, "v2 = ", v2]; 
{dx, dy}=v2-v1; 
dPrint["{dx,dy}=", {dx, dy}]; 
{p1, p2} =PolygonIntersection[{-dy, dx},cvc];
p1=p1[[2]]; p2=p2[[2]]; 
theta1=(180.0/Pi)*ArcTan@@(p1+cen); 
theta2=(180.0/Pi)*ArcTan@@(p2+cen);
Return[{{theta1, theta2}, p1,p2}]

]


(* ::Input::Initialization:: *)
DetermineAnticlinalPlane[T_, i_]:= Module[{v,e,c,outeredge,vouter, cvc,cen,v1,v2,dx,dy,p1,p2,theta1,theta2,dbg=False, dPrint},
dPrint[u___]:= If[dbg, Print["DetermineAnticlinalPlane: ", u]]; 
{v,e,c} = T/.{Tissue-> List}; 
cvc = CellVertexCoordinates[T,i]; 
outeredge = Complement[c[[i]],Flatten[c[[CellNeighbors[T,i]]]]]; 
dPrint["outeredge: ", outeredge];
vouter = "Vertices"/.SortCellEdges[outeredge, e]; 
dPrint["vouter: ", vouter];  
v1 = First[vouter];
v2=Last[vouter];
dPrint["{v1,v2}: ", {v1, v2}]; 
v1=v[[v1]]; v2=v[[v2]]; 


cen = Centroid[cvc]; 
(* find intersection between normal through center and edge *)
{dx, dy}=v2-v1; 
{p1, p2} =PolygonIntersection[{-dy, dx},cvc];

(* find intersection between midpoint through edge *)
{dx, dy}=0.5(v2+v1)-cen;
{p1, p2} =PolygonIntersection[{dx, dy},cvc];

p1=p1[[2]]; p2=p2[[2]]; 
theta1=(180.0/Pi)*ArcTan@@(p1+cen); 
theta2=(180.0/Pi)*ArcTan@@(p2+cen);
Return[{{theta1, theta2}, p1,p2}]

]


(* ::Input::Initialization:: *)
DetermineCellDivisionPoints[sim_,DT_?DTissueQ,L1Anticlinal_,L2Anticlinal_, L2AnticlinalRatio_, upwards_, w_?ListQ,x_: Global`x,y_: Global`y,method_, minAngleSpread_:135]:=Module[{divided,span,done,s,T,actualCellNumber,CDT,CT,dividedCellEdgeNumbers,positionalcellindex,CVC,PGD,dPrint,dbg=False,weight,angles, results, PCD,cellMinimumYCoordinate, BC,doneByL1L2,v,ymin,meanradius,evr},dPrint[u___]:=If[dbg,Print["DetermineCellDivision: ",u]];
done="Finished"/.sim;
s="Solution"/.sim;
span="TimeSpan"/.sim;
divided="Divide"/.sim;
CDT=TissueCells[DT];
If[done,Return[{}]];
T=DTissue2Tissue[DT,s,span[[2]]];
CT=TissueCells[T];
v=TissueVertices[T];

ymin=Min[Transpose[v][[2]]]; 
meanradius=Sqrt[Mean[areafunction[T]]/Pi];

results={}; 

BC = CellsOnBoundary[T]; 

If[L1Anticlinal ,  l1cells=L1Cells[DT]]; 
If[L2Anticlinal, l2cells=L2Cells[DT]];

dPrint[ "L1Anticlinal: ", L1Anticlinal, " l1cells ", l1cells]; 
dPrint["L2Anticlinal: ", L2Anticlinal, " l2cells: ", l2cells]; 

While[Length[divided]>0,actualCellNumber=First[divided];
dPrint["actualCellNumber = ",actualCellNumber];
divided=Rest[divided];
dividedCellEdgeNumbers=actualCellNumber/.CDT;
dPrint["dividedCellEdgeNumbers = ",dividedCellEdgeNumbers];
positionalcellindex=Position[CT,dividedCellEdgeNumbers];
While[ListQ[positionalcellindex],positionalcellindex=First[positionalcellindex]];
dPrint["positionalcellindex=",positionalcellindex];
CVC=CellVertexCoordinates[T,positionalcellindex];
dPrint["CVC = ",CVC];

(* check for anticlinal division *)

doneByL1L2=False;

dPrint["L1Anticlinal: ", L1Anticlinal]; 
dPrint["L2Anticlinal: ", L2Anticlinal];
dPrint["Boundary Cells: ", BC]; 

doneByL1L2=False; 
If[L2Anticlinal,
If[MemberQ[l2cells, positionalcellindex], 
(* Test for Elongation *)
If[(evr=EigenRatio[CVC])>L2AnticlinalRatio, 
Print["L2 Anticlinal division overriden: Cell ", positionalcellindex , " ratio of eigenvalues = ",evr , " exceeds ", L2AnticlinalRatio]
,
Print["L2 Anticlinal division: Cell ", positionalcellindex]; 
angles = DetermineL2AnticlinalPlane[T, positionalcellindex]; 
doneByL1L2=True; 
]
]; 

]; 

If[Not[doneByL1L2], 
If[L1Anticlinal, 
(* anticlinal if on the boundary *)

If[MemberQ[l1cells,positionalcellindex], 
angles = DetermineAnticlinalPlane[T, positionalcellindex]; 

Print["L1 Anticlinal division:Cell ", positionalcellindex]; 
doneByL1L2=True]

]; 
]; 

If[Not[doneByL1L2],
Switch[method,
1, 
(*Want to be perpendicular to Princ. Growth Direction *)
PGD=PrincipalGrowthDirection[DT,actualCellNumber,s,span[[2]],x,y];
dPrint["PGD = ",PGD];
(* Same Thing for Principal Cell Direction *) 
PCD =PrincipalCellDirection[DT, actualCellNumber, s, span[[2]], x, y]; 
dPrint["PCD = ",PCD];
weight=Take[PadRight[Flatten[{w}],4],4];

Print["Cell Division Weight Vector: ", weight]; 

dPrint["weight = ",weight];
angles=OptimizeDivisionPotential[CVC,weight,PGD,PCD, minAngleSpread];
dPrint["angles = ",angles];
,
2,
Print["Cell Division Errera's Method"]; 
angles=Errera[CVC,120]
,
_, 
AbortIf[True, "Error: DetermineCellDivisionPoints: Invalid Method = "<>ToString[method]]
]];
AppendTo[results, angles]; 
];
dPrint["DetermineCellDivisionPoints: results: ", results]; 
Return[results]
]


(* ::Input::Initialization:: *)
DivideNSigmas[q_Tissue,nsig_]:=Module[{cvc,q1,q2,areas,sigma,nsigs,mu,n,angles,p1,p2,dbg=False,dPrint},
dPrint[u___]:= If[dbg, Print["DivideNSigmas: ", u]]; 
cvc=CellVertexCoordinates[q];
q1=q;
areas=areafunction[q];
mu=Mean[areas];
sigma=StandardDeviation[areas];
dPrint["mu=",mu," sigma=",sigma];
dPrint["areas=", areas]; 
nsigs=Pick[Range[Length[areas]],(#>(mu+nsig*sigma))&/@areas];
dPrint["nsigs: ", nsigs]; 
While[Length[nsigs]>0,n=First[nsigs];
nsigs=Rest[nsigs];
{angles,p1,p2}=Cellzilla2D`Private`Errera[cvc[[n]],25];
q1=DivideCell[q1,n,{p1,p2}];
dPrint[Show[ShowTissue[q1, "CellNumbers"-> True],ImageSize->300]];
];
q1]


(* ::Input::Initialization:: *)
CelleratorNetwork[inputTissue_, 
opt___?OptionQ
]:= Module[{r, k, n, in, out,  diff, reactions, i, j, vPrint, nInside, nDiff, nTotal, ok, istissue, istorus, c, icc,  tissue, intracellular, dPrint, edgeVariable, areaVariable, debug, verbose, diffusingSpecies, pumps, boundaryConditions,static,areas,edgeLengths}, 

debug = "Debug"/.{opt}/.{"Debug"-> False};
verbose="Verbose"/.{opt}/.{"Verbose"-> True}; 

diffusingSpecies = "Diffusion"/.{opt}/.{"Diffusion"-> {}}; 
intracellular = "Reactions"/.{opt}/.{"Reactions"-> {}}; 
pumps = "Pumps"/.{opt}/.{"Pumps"-> {}}; 
If[pumps!= {}, Print["Warning: \"Pumps\" Option is not yet implemented and will be ignored."]]; 
boundaryConditions = "BoundaryConditions"/.{opt}/.{"BoundaryConditions"-> {}};
If[boundaryConditions!= {}, Print["Warning: \"BoundaryConditions\" Option is not yet implemented and will be ignored."]]; 

edgeVariable="EdgeVariable"/.{opt}/.{"EdgeVariable"->None}; 
areaVariable="CellVariable"/.{opt}/.{"CellVariable"-> None}; 

static=Or[edgeVariable===None,areaVariable===None];

edgeVariable=edgeVariable/.{None-> Global`edge}; 
areaVariable=areaVariable/.{None-> Global`area}; 


dPrint[x___]:= If[debug, Print["CelleratorNetwork: ", x]]; 

istissue=TissueQ[inputTissue]; 
istorus=TorusQ[inputTissue]; 

ok=istissue \[Or] istorus;
If[!ok, Print["Error: Expecting CelleratorNetwork[tissue, options]."]; Return[$Failed]]; 

If[istissue, tissue = inputTissue]; 
If[istorus, tissue = TorusTissue[inputTissue]];

c=TissueCells[tissue]; 

dPrint["Tissue: ", istissue, " Torus: ", istorus]; 

vPrint[x___]:= If[verbose, Print[x]]; 

(* generate intracellular reactions *)

r=lowLevelReactions[intracellular]; 
dPrint["r (1): ", r]; 
r=indexify[r, i];
dPrint["r (2): ", r]; 
n=NTissueCells[tissue]; 
vPrint[n, " Cells."]; 
vPrint[Length[r], " internal reactions in each cell."]; 
in = Join@@Table[r/.{i-> k}, {k, 1, n}]; 
dPrint["in: ", in]; 

nInside=Length[in]; 
vPrint[nInside, " intracellular reactions."]; 

edgeLengths = EdgeLengths[tissue]; 
areas = areafunction[tissue]; 

(* generate diffusion reactions *)
diff={}; 
If[Length[diffusingSpecies]>0,
Block[{   diffusionReaction, diffusionReactions,allneighbors,  neighbors, edgeBetween, l,   beta, Y, difSpec, temp, allEdgesBetween, diffData, func, One,newEdge},
One[p_,q_]:= 1; 
allneighbors = CellNeighbors[inputTissue];  
neighbors[p_]:= allneighbors[[p]]; 
allEdgesBetween=EdgesBetween[inputTissue]; 
dPrint["allEdgesBetween: ", Short[MatrixForm[allEdgesBetween]]]; 
edgeBetween[p_, q_]:= allEdgesBetween[[p,q]];
l[p_,q_]:= edgeVariable[edgeBetween[p,q]][Global`t];
diffusionReaction[X_,func_,  {p_, q_}]:={X[p]\[RightArrowLeftArrow]Global`\[EmptySet], ( l[p,q] func[p,q])/areaVariable[p][Global`t], (l[p,q] func[p,q])/areaVariable[p][Global`t] X[q][Global`t]};  


diffusionReactions[X_, \[Beta]_, p_]:= Table[
diffusionReaction[X, \[Beta], {p, inbr}], {inbr, neighbors[p]}];

difSpec=diffusingSpecies;
While[Length[difSpec]>0,

dPrint["difSpec: ", difSpec];

diffData = First[difSpec]; 
difSpec=Rest[difSpec]; 

diffData = Flatten[{diffData}]; 
Y=diffData[[1]]; 
beta = If[Length[diffData]>1, diffData[[2]], 0]; 
func=If[SameQ[Head[beta], Function],
beta, Evaluate[beta]&];
(* This allows users to input edges as edge[p,q] rather than by edge number *)
newEdge[u___]:=edgeVariable[edgeBetween[u]]; 
func=func/.{edgeVariable-> newEdge}; 
temp = Join@@(diffusionReactions[Y, func, #]&/@Range[n]);
diff = Join[diff, temp];  
]; 
]; 
]; 
nDiff=Length[diff]; 
vPrint[nDiff, " diffusion reactions."]; 

(* generate intercellular reactions if spectified *)
out  = {}; 
(** this is TBD *)

reactions=Join[in, diff, out]; 
nTotal = Length[reactions]; 
vPrint[nTotal, " total reactions."]; 

If[static,
Block[{NewEdgeVariable, NewAreaVariable},
NewEdgeVariable[edgeNumber_][Global`t]:=edgeLengths[[edgeNumber]]; 
NewAreaVariable[cellNumber_][Global`t]:= areas[[cellNumber]];

reactions = (reactions/.{edgeVariable-> NewEdgeVariable, areaVariable-> NewAreaVariable})
]
];(**)


Return[reactions];
]; 
CelleratorNetwork[x___]:= (Print["Error: CelleratorNetwork: Expecting CelleratorNetwork[tissue,options]"]; $Failed);


(* ::Input::Initialization:: *)
UnwalledNetwork[tissue_?DTissueQ, opt___?OptionQ
]:= Module[
{r,k,n,ne, in,out,diff,reactions,i,j,vPrint,nInside,nDiff,nTotal,ok,istissue,istorus,c,icc,dPrint,edgeVariable,areaVariable,debug,wall, verbose,e,v,  static, wallreactions,nwall, Depth,requestedDynamic,
areas,edgeLengths, boundaryConditions,allEdgesBetween, neighbors, allneighbors,outeredges, outercells,One,ZERO,subnet,
pumps,pr,diffusingSpecies, intracellular,getTransferFunction, growing,GR,GE,nv,growthstuff,AEQ,equations,x,y,cvn,eused,vused, inputTissue,cellEdgeIndices,cellNumbers,boundaryConditionSet, INTERCELLULARReactions, TE, dbgPumps=False, xy
},
debug="NDebug"/.{opt}/.{"NDebug"->False};
dPrint[x___]:=If[debug,Print["UnwalledNetwork: ",x]];
dPrint["NDebug: ", debug]; 

One[p_,q_,r_]:=1;
ZERO[p_,q_, r_]:= 0; 
getTransferFunction[stuff_]:= 
If[SameQ[Head[stuff], Function],stuff,Evaluate[stuff]&];

verbose="Verbose"/.{opt}/.{"Verbose"->True};
edgeVariable="EdgeVariable"/.{opt}/.{"EdgeVariable"->None};
areaVariable="CellVariable"/.{opt}/.{"CellVariable"->None};
xy = "xy"/.{opt}/.{"xy"-> True}; 
x = "x"/.{opt}/.{"x"-> Global`x}; 
y="y"/.{opt}/.{"y"-> Global`y}; 
pumps = "Pumps"/.{opt}/.{"Pumps"-> {}}; 
diffusingSpecies="Diffusion"/.{opt}/.{"Diffusion"-> {}}; 
intracellular = "Reactions"/.{opt}/.{"Reactions"-> {}}; 
INTERCELLULARReactions = "Intercellular"/.{opt}/.{"Intercellular"-> {}}; 

growing = "Growing"/.{opt}/.{"Growing"-> False}; 

Depth = "CellDepth"/.{opt}/.{"CellDepth"-> Global`CellDepth}; 
boundaryConditions=getBC[opt]; 
boundaryConditionSet="BoundaryConditionSet"/.{opt}/.{"BoundaryConditionSet"-> False};
If[Length[boundaryConditions]>0, boundaryConditionSet=True];  

(* force use of dynamic variable names; replace with static values at end if needed *)

static=Or[edgeVariable===None,areaVariable===None, growing==False];
(* If[growing, static=False];  *)


edgeVariable=edgeVariable/.{None-> Symbol["Global`edge"]};
areaVariable=areaVariable/.{None-> Symbol["Global`cell"]}; 

c=TissueCells[tissue];
dPrint["c=", c]; 
cellNumbers=First/@c;
cellEdgeIndices = Last/@c; 
e=TissueEdges[tissue];
ne = Length[e]; 
v=TissueVertices[tissue]; 
nv=Length[v]; 
vPrint[x___]:=If[verbose,Print[x]];

dPrint["e=", e," ne=", ne];  
dPrint["v=", v, " nv=", nv]; 

(*generate intracellular reactions*)

dPrint["intracellular: ", intracellular]; 
r=lowLevelReactions[intracellular];
subnet[i_]:=indexify[r,i, opt];
dPrint["subnet[i] = ", subnet[i]]; 
n=Length[c]; 
vPrint[n," Cells."];
vPrint[Length[r]," internal reactions in each cell."];
(* in=Join@@Table[r/.{i\[Rule]k},{k,1,n}];*) 
in = Join@@(subnet/@cellNumbers); 

nInside=Length[in];
vPrint[nInside," total intracellular reactions."];
dPrint["in = ", in]; 

inputTissue=DTissue2Tissue[tissue]; 

edgeLengths=EdgeLengths[inputTissue];
dPrint["edgeLengths:", edgeLengths]; 


(* The following use the static cell number *)

areas=areafunction[inputTissue];
allEdgesBetween=EdgesBetween[inputTissue];
allneighbors=CellNeighbors[inputTissue];
neighbors[p_]:=allneighbors[[p]];
dPrint["allNeighbors: ",allneighbors]; 
outeredges = EdgesOnBoundary[inputTissue]; 
outercells = CellsOnBoundary[inputTissue]; 
dPrint["allEdgesBetween: ",MatrixForm[allEdgesBetween]];
dPrint["outeredges = ", outeredges]; 

(*generate concentration dependent pump reactions*)

pr = generatePumpReactions[c,  pumps, allEdgesBetween, allneighbors,outercells, outeredges, 
edgeVariable, areaVariable,  "Debug"-> dbgPumps]; 
If[dbgPumps, Print["pr = ", pr]]; 

vPrint[Length[pr]," transport reactions."];

(*generate diffusion reactions*)

vused=VerticesUsed[inputTissue];
eused=EdgesUsed[inputTissue];


diff = generateDiffusionReactions[c, e, eused,diffusingSpecies, allEdgesBetween, allneighbors, outercells,  outeredges, edgeVariable, areaVariable, x, y, edgeLengths,  boundaryConditionSet,
debug];


nDiff=Length[diff];
vPrint[nDiff," diffusion reactions."];

(*generate intercellular reactions if spectified*)


out = generateIntercellularReactions[c, INTERCELLULARReactions, allneighbors, outercells,  outeredges,  areaVariable, x, y,  boundaryConditionSet,
debug];


reactions=Join[in,diff, pr, out];

(* If static tissue is requested *)
(* replace variable names with static values *)

If[static,
Block[{NewEdgeVariable, NewAreaVariable,NewVertexVariable, newx, newy, temp},
NewEdgeVariable[edgeNumber_][Global`t]:=edgeLengths[[edgeNumber]]; 
NewAreaVariable[cellNumber_][Global`t]:= areas[[cellNumber]];
NewAreaVariable[cellNumber_]'[Global`t]:= 0; 
newx[i_][Global`t]:= v[[i,1]];
newy[i_][Global`t]:= v[[i,2]];


reactions = (reactions/.{ edgeVariable-> NewEdgeVariable, areaVariable-> NewAreaVariable, x-> newx, y-> newy});
AEQ={}; 
],
AEQ=CellAreaEquations[tissue,opt]; 
vPrint[Length[AEQ], " equations for cell area."]; 
]; 

cvn = CellVertexNumbers[tissue]; 

dPrint["boundaryConditions: ", boundaryConditions]; 


If[static,
GR={}; 
TE=generateSpecialVariables[inputTissue, opt]; 
dPrint["TE=", TE]; 
GE={}; 
If[xy, 
GE=Flatten[{x[#][Global`t]== v[[#,1]], y[#][Global`t]==v[[#,2]]}&/@vused];
]; 
AEQ=CellAreaEquations[tissue,opt];
GE = Join[TE, GE]; 
,
growthstuff=generateGrowthReactions[c,cvn, e,v, eused, vused, edgeVariable, outeredges,  opt];
GR="reactions"/.growthstuff; 
GE="equations"/.growthstuff; 
]; 


dPrint["GR: ", GR//Short]; 
dPrint["GE: ", GE//Short]; 



vPrint[Length[GE]," algebraic equations for spring growth."]; 

reactions = Join[reactions, GR]; 
reactions = reactions /.boundaryConditions; 


nTotal=Length[reactions];
vPrint[nTotal," total reactions."];

equations = Join[GE, AEQ]; 
equations = equations/.boundaryConditions;
reactions = reactions/.boundaryConditions; 


dPrint["equations: ", equations]; 

Return[{reactions, equations}];
]; 
UnwalledNetwork[x___]:= (Print["Error: UnwalledNetwork: Expecting UnwalledNetwork[DTissue,options]"]; $Failed);


(* ::Input::Initialization:: *)
generateIntercellularReactions[c_, intercellular_, allneighbors_, outercells_,  outeredges_,  areaVariable_, x_, y_,  boundaryConditionSet_,debug_]:= Module[{dPrint, HandleReaction, grn},
dPrint[u___]:= If[debug, Print["generateIntercellularReactions: ", u]]; 

dPrint["intercellular: ", intercellular]; 
dPrint["allneighbors: ", allneighbors]; 

HandleReaction[{RightTeeArrow[inputVar_, outputVar_],xlr8r`GRN[stuff___]}]:= Module[{ilist, 
makereaci},
dPrint[RightTeeArrow[inputVar, outputVar]," is ok"]; 
ilist = Range[Length[allneighbors]]; 
dPrint["ilist: ", ilist]; 
(* correct concentrations for different volumes by changing multiplier *)
makereaci[i_]:= Module[{r,arg1,argrest, newstuff, v},
If[Length[{stuff}]>0, arg1=First[{stuff}],arg1=1.0]; 
If[Length[{stuff}]>1, argrest=Rest[{stuff}], argrest={}]; 
v[ifrom_, ito_]:= arg1*areaVariable[ito][Global`t]/areaVariable[ifrom][Global`t];
r={RightTeeArrow[inputVar[i], outputVar[#]],xlr8r`GRN[
Sequence@@Flatten[{v[i,#],argrest}]]}&/@allneighbors[[i]]
];
Join@@(makereaci/@ilist)
];

HandleReaction[u___]:= (Print["generateIntercellularReactions: Invalid Intercellular Reaction: ", u];Abort[]);  
grn = Join@@(HandleReaction/@intercellular);

dPrint["grn reactions: ", grn]; 
grn
];


(* ::Input::Initialization:: *)
generateDiffusionReactions[c_, e_, eused_, diffusingSpecies_, 
allEdgesBetween_, allneighbors_, outercells_,  outeredges_, edgeVariable_, areaVariable_, x_, y_, edgeLengths_,  boundaryConditionSet_,
debug_]:=
Module[{dPrint, cellNumbers, toDynamicNumberRules, toStaticNumberRules,cellIndices, neighbors,edgeBetween,l, DR,diffusionReactions,difSpec, diffData, getTransferFunction,Y, \[Beta], \[Beta]outer, temp, diff, DRBOUNDARY,bdry, outerEdgesOf,outerCELLS},
dPrint[u___]:= If[debug, Print["generateDiffusionReactions: ", u]]; 



getTransferFunction[stuff_]:= 
If[SameQ[Head[stuff], Function],stuff,Evaluate[stuff]&];

cellNumbers=First/@c;
toDynamicNumberRules=MapThread[Rule,{Range[Length[c]],cellNumbers}];toStaticNumberRules=Reverse/@toDynamicNumberRules;dPrint["toDynamicNumberRules: ",toDynamicNumberRules];dPrint["toStaticNumberRules: ",toStaticNumberRules]; 
outerCELLS = outercells/.toDynamicNumberRules;

cellIndices=Last/@c;

neighbors[p_]:=(allneighbors[[p/.toStaticNumberRules]])/.toDynamicNumberRules;


outerEdgesOf[p_]:= ((p/.c)\[Intersection]outeredges); 

edgeBetween[p_,0]:=  ((p/.c)\[Intersection]outeredges)[[1]]; 
edgeBetween[p_,q_]:=allEdgesBetween[[p/.toStaticNumberRules,q/.toStaticNumberRules]];
l[p_,q_]:=edgeVariable[edgeBetween[p,q]][Global`t];

DR[X_,func_,{p_,q_}]:=With[{edge=edgeBetween[p,q]}, {X[p]\[RightArrowLeftArrow]Global`\[EmptySet],(l[p,q] func[p,q,edge])/areaVariable[p][Global`t],(l[p,q] func[p,q,edge])/areaVariable[p][Global`t] X[q][Global`t]}
];

DRBOUNDARY[X_,func_,p_]:=Module[{rset,edge,lvar},
lvar[u_]:=edgeVariable[u][Global`t] ;
rset[edge_]:= {X[p]\[RightArrowLeftArrow]Global`\[EmptySet],(lvar[edge]* func[p,0,edge])/areaVariable[p][Global`t],(lvar[edge]* func[p,0,edge])/areaVariable[p][Global`t] X[0][Global`t]};
Join[rset/@outerEdgesOf[p]]
]; 

diffusionReactions[X_,\[Beta]_,p_]:=Table[DR[X,\[Beta],{p,inbr}],{inbr,neighbors[p]}];
difSpec=diffusingSpecies;
If[Length[difSpec]>0,
AbortIf[ToString[areaVariable]=="False",
"Diffsion Requested but Cellvariable\"\[Rule]False"
];
]; 
diff={}; 
While[Length[difSpec]>0,dPrint["difSpec: ",difSpec];



dPrint["difSpec: ",difSpec];
diffData=First[difSpec];
difSpec=Rest[difSpec];


Y=diffData[[1]];
dPrint["diffData=",diffData, " Y=", Y];

If[Length[diffData]>1,
\[Beta]=getTransferFunction[diffData[[2]]],
\[Beta]=0&
]; 
If[Length[diffData]>2,
\[Beta]outer=getTransferFunction[diffData[[3]]], 
(* if specified, middle argument should be zero *)
\[Beta]outer=0&
]; 

dPrint["cellIndices: ", cellNumbers]; 
temp=Flatten[Join[diffusionReactions[Y,\[Beta], #]&/@cellNumbers],1];
dPrint["temp: ", Short[temp, 5]]; 
dPrint["boundaryConditionSet: ", boundaryConditionSet]; 

If[boundaryConditionSet, 
dPrint["outerCELLS: ", outerCELLS]; 
bdry=Flatten[Join[DRBOUNDARY[Y,\[Beta]outer,#]&/@outerCELLS,1],1],
bdry={}
]; 
dPrint["bdry: ", Short[bdry,5]]; 
 
diff=Join[diff,temp,bdry];
]; 
diff
]; 


(* ::Input::Initialization:: *)
generatePumpReactions[c_,  pumps_, allEdgesBetween_, allneighbors_,outercells_, outeredges_, 
edgeVariable_, areaVariable_, opt___?OptionQ]:= Module[{dbg, dPrint, pumpdata,r, pump, var, fout, fin, PR, toStaticNumberRules, toDynamicNumberRules, cellNumbers, neighbors, XPR, pumpReactions, rnew},
dbg = "Debug"/.{opt}/.{"debug"-> False}; 
dPrint[x___]:= If[dbg, Print["generatePumpReactions: ", x]]; 
dPrint["pumps: ", pumps]; 
dPrint["allneighbors: ", allneighbors];
cellNumbers=First/@c;
toDynamicNumberRules =MapThread[Rule,{ Range[Length[c]],cellNumbers}]; 
toStaticNumberRules=Reverse/@toDynamicNumberRules; 

neighbors[p_]:=(allneighbors[[p/.toStaticNumberRules]])/.toDynamicNumberRules;


XPR[X_,fout_,fin_, {p_,q_}]:=
Module[{edge, AC, E},
edge=allEdgesBetween[[p/.toStaticNumberRules,q/.toStaticNumberRules]];
E=edgeVariable[edge][Global`t];

AC = areaVariable[p][Global`t]; 
{{X[p]\[Implies] Global`\[EmptySet],(fout[p,q,edge]+fin[q,p,edge])*E/AC},
{Global`\[EmptySet]\[Implies]X[p], (fin[p,q,edge]+fout[q,p,edge])*E/AC}}
];

pumpReactions[X_,FOUT_,FIN_ ,p_]:=Module[{reactions,nbrs},
nbrs=neighbors[p]; 
reactions=Join@@Table[
XPR[X,FOUT, FIN, {p,inbr}],{inbr,nbrs}]
];

pumpReactions[X_, FOUT_, FIN_]:= Join@@(pumpReactions[X,FOUT,FIN,#]&/@cellNumbers); 



r={}; 
pumpdata=pumps; 
While[Length[pumpdata]>0,
pump=First[pumpdata];
AbortIf[!ListQ[pump], "Expecting a list for transport function: "<>ToString[InputForm[pump]]];
AbortIf[Length[pump]<1, "No variable specified for transport."];
var = pump[[1]]; 
AbortIf[Length[pump]<2, "Expecting a transport function in the second position for transported constitutent "<>ToString[InputForm[var]]]; 
fout = pump[[2]]; 
If[Length[pump]>2, fin=pump[[3]], fin=0&]; 

dPrint["var: ", var, " fin: ", fin, " fout: ", fout]; 

pumpdata=Rest[pumpdata];

rnew = pumpReactions[var, fout, fin];
dPrint[rnew]; 
r = Join[r, rnew]; 

];

r];


(* ::Input::Initialization:: *)
WalledNetwork[tissue_?DTissueQ,opt___?OptionQ]:=Module[{r,k,n,ne, in,out,diff,reactions,i,j,vPrint,nInside,nDiff,nTotal,ok,istissue,istorus,c,icc,dPrint,edgeVariable,areaVariable,debug,wall, verbose,e,v,  static,aij, wallreactions,nwall, Depth,requestedDynamic,
areas,edgeLengths, boundaryConditions,allEdgesBetween, neighbors, allneighbors,outeredges, outercells,One,ZERO,subnet,
pumps,pr,diffusingSpecies, intracellular,getTransferFunction, growing,GR,GE,nv,growthstuff,AEQ,equations,x,y,cvn,eused,vused, inputTissue,cellNumbers,cellEdgeIndices
},
debug="NDebug"/.{opt}/.{"NDebug"->False};
dPrint[x___]:=If[debug,Print["WalledNetwork: ",x]];
dPrint["NDebug: ", debug]; 

One[p_,q_,r_]:=1;
ZERO[p_,q_, r_]:= 0; 
getTransferFunction[stuff_]:= 
If[SameQ[Head[stuff], Function],stuff,Evaluate[stuff]&];

verbose="Verbose"/.{opt}/.{"Verbose"->True};
edgeVariable="EdgeVariable"/.{opt}/.{"EdgeVariable"->None};
areaVariable="CellVariable"/.{opt}/.{"CellVariable"->None};
x = "x"/.{opt}/.{"x"-> Global`x}; 
y="y"/.{opt}/.{"y"-> Global`y}; 

pumps = "Pumps"/.{opt}/.{"Pumps"-> {}}; 
diffusingSpecies="Diffusion"/.{opt}/.{"Diffusion"-> {}}; 
intracellular = "Reactions"/.{opt}/.{"Reactions"-> {}}; 
growing = "Growing"/.{opt}/.{"Growing"-> False}; 

Depth = "CellDepth"/.{opt}/.{"CellDepth"-> Global`CellDepth}; 
aij = "WallThickness"/.{opt}/.{"WallThickness"-> Global`halfwall};
wall = "WallReactions"/.{opt}/.{"Wall"-> {}};  
boundaryConditions=getBC[opt]; 


(* force use of dynamic variable names; replace with static values at end if needed *)

static=Or[edgeVariable===None,areaVariable===None];
If[growing, static=False]; 

edgeVariable=edgeVariable/.{None-> Symbol["Global`edge"]};
areaVariable=areaVariable/.{None-> Symbol["Global`area"]}; 

c=TissueCells[tissue];
dPrint["c=", c]; 
cellNumbers=First/@c;
cellEdgeIndices = Last/@c; 
e=TissueEdges[tissue];
ne = Length[e]; 
v=TissueVertices[tissue]; 
nv=Length[v]; 
vPrint[x___]:=If[verbose,Print[x]];

dPrint["e=", e," ne=", ne];  
dPrint["v=", v, " nv=", nv]; 

(*generate intracellular reactions*)

dPrint["intracellular: ", intracellular]; 
r=lowLevelReactions[intracellular];
subnet[i_]:=indexify[r,i, opt];
dPrint["subnet[i] = ", subnet[i]]; 
n=Length[c]; 
vPrint[n," Cells."];
vPrint[Length[r]," internal reactions in each cell."];
(* in=Join@@Table[r/.{i\[Rule]k},{k,1,n}];*) 
in = Join@@(subnet/@cellNumbers); 

nInside=Length[in];
vPrint[nInside," total intracellular reactions."];
dPrint["in = ", in]; 

wallreactions=generateCelleratorInWallReactions[wall,c,verbose];
nwall= Length[wallreactions]; 
vPrint[nwall," total intrawall reactions."]; 
dPrint[" wallreactions: ", wallreactions]; 


inputTissue=DTissue2Tissue[tissue]; 

edgeLengths=EdgeLengths[inputTissue];
dPrint["edgeLengths:", edgeLengths]; 


(* The following use the static cell number *)

areas=areafunction[inputTissue];
allEdgesBetween=EdgesBetween[inputTissue];
allneighbors=CellNeighbors[inputTissue];
neighbors[p_]:=allneighbors[[p]];
dPrint["allNeighbors: ",allneighbors]; 
outeredges = EdgesOnBoundary[inputTissue]; 
outercells = CellsOnBoundary[inputTissue]; 
dPrint["allEdgesBetween: ",MatrixForm[allEdgesBetween]];
dPrint["outeredges = ", outeredges]; 

(*generate concentration dependent pump reactions*)

pr = generateCelleratorWalledPumpReactions[c,  pumps, allEdgesBetween, allneighbors,outercells, outeredges, 
edgeVariable, areaVariable, aij, "Debug"-> debug]; 
vPrint[Length[pr]," transport reactions."];


(*generate diffusion reactions*)

vused=VerticesUsed[inputTissue];
eused=EdgesUsed[inputTissue];

diff = generateCelleratorWalledDiffusionReactions[c, e, eused,diffusingSpecies, allEdgesBetween, allneighbors, outercells,  outeredges, edgeVariable, areaVariable, x, y, edgeLengths, aij, 
debug];


nDiff=Length[diff];
vPrint[nDiff," diffusion reactions."];

(*generate intercellular reactions if spectified*)

out={};

(**this is TBD*)

reactions=Join[in,diff, pr, out,wallreactions];

(* If static tissue is requestested *)
(* replace variable names with static values *)

If[static,
Block[{NewEdgeVariable, NewAreaVariable,NewVertexVariable, newx, newy},
NewEdgeVariable[edgeNumber_][Global`t]:=edgeLengths[[edgeNumber]]; 
NewAreaVariable[cellNumber_][Global`t]:= areas[[cellNumber]];
newx[i_][Global`t]:= v[[i,1]];
newy[i_][Global`t]:= v[[i,2]];


reactions = (reactions/.{edgeVariable-> NewEdgeVariable, areaVariable-> NewAreaVariable, x-> newx, y-> newy});
AEQ={}; 
],
AEQ=CellAreaEquations[tissue,opt]; 

vPrint[Length[AEQ], " equations for cell area."]; 
]; 

cvn = CellVertexNumbers[tissue]; 
growthstuff=generateGrowthReactions[c,cvn, e,v, eused, vused, edgeVariable, outeredges,  opt];
GR="reactions"/.growthstuff; 
GE="equations"/.growthstuff; 
vPrint[Length[GE]," algebraic equations for spring growth."]; 

reactions = Join[reactions, GR]; 
reactions = reactions /.boundaryConditions; 

nTotal=Length[reactions];
vPrint[nTotal," total reactions."];

equations = Join[GE, AEQ]; 

Return[{reactions, equations}];
];
WalledNetwork[x___]:=(Print["Error: Expecting WalledNetwork[DTissue, options]"];$Failed);


(* ::Input::Initialization:: *)
generateCelleratorWalledDiffusionReactions[c_, e_, eused_, diffusingSpecies_, 
allEdgesBetween_, allneighbors_, outercells_,  outeredges_, edgeVariable_, areaVariable_, x_, y_, edgeLengths_, aij_, 
debug_]:= Module[{diff,DR,DRW, DRWW,DRWWC, diffusionReactions,diffusionWWReactions,edgeBetween,l,beta,Y,difSpec,temp,diffData,func,  \[Beta]in,\[Beta]out,\[Beta]wall, fin, fout, fwall,intesectingEdges, diffusionOEReactions, neighborSharingEdge, drow, DROW, nxtra,dPrint, neighbors, getTransferFunction,ne, n, neused,eflags,cellNumbers,toDynamicNumberRules,toStaticNumberRules,cellIndices}, 
diff={}; 
dPrint[u___]:=If[debug,Print["generateCelleratorWalledDiffusionReactions: ",u]];
dPrint["c=",c]; 

If[Length[diffusingSpecies]>0,

ne = Length[e]; 
n = Length[c];
eflags = MemberQ[eused,#]&/@Range[ne];  
neused = Length[eused]; 

cellNumbers=First/@c;toDynamicNumberRules=MapThread[Rule,{Range[Length[c]],cellNumbers}];toStaticNumberRules=Reverse/@toDynamicNumberRules;dPrint["toDynamicNumberRules: ",toDynamicNumberRules];dPrint["toStaticNumberRules: ",toStaticNumberRules];

cellIndices=Last/@c;

neighbors[p_]:=(allneighbors[[p/.toStaticNumberRules]])/.toDynamicNumberRules;


getTransferFunction[stuff_]:= 
If[SameQ[Head[stuff], Function],stuff,Evaluate[stuff]&];

neighborSharingEdge[cellnum_,edgenum_]:=Module[{staticindex},
staticindex=Position[Normal[allEdgesBetween], edgenum][[1]];
Complement[staticindex/.toDynamicNumberRules, {cellnum}][[1]]
]; 

(* artificial zeroth compartment for "outside" *)

edgeBetween[p_,0]:=  ((p/.c)\[Intersection]outeredges)[[1]]; 
edgeBetween[p_,q_]:=allEdgesBetween[[p/.toStaticNumberRules,q/.toStaticNumberRules]];
l[p_,q_]:=edgeVariable[edgeBetween[p,q]][Global`t];


(* X \[RightArrowLeftArrow] \[EmptySet] for Cell to Adjacent Wall Compartment *)
(* change of cell concentration *) 
 
DR[X_, Fout_, Fin_, {p_,q_}]:=Module[
{edge, reaction, forward, reverse, dr}, 
edge=edgeBetween[p,q];
dPrint["DBG: DR: , edge=", edge];
reaction=X[p]\[RightArrowLeftArrow]Global`\[EmptySet];
forward = ( Fout[p,q,edge] *edgeVariable[edge][Global`t])/(areaVariable[p][Global`t]); 
reverse = ( Fin[p,q, edge] * edgeVariable[edge][Global`t]/(areaVariable[p][Global`t])) X[p,edge][Global`t]; 
dr={reaction,forward, reverse};
dPrint ["DBG: forward: ", forward]; 
dPrint ["DBG: reverse: ", reverse]; 

dPrint["DBG: dr: ", dr]; 
Return[dr]
];


(*change of wall concentration*) 
 
DRW[X_, Fout_, Fin_, {p_,q_}]:=
With[{edge=edgeBetween[p,q]},

{X[p, edge]\[RightArrowLeftArrow]Global`\[EmptySet], 
Fin[p,q, edge] /(aij)  , 
 Fout[p,q, edge]  X[p][Global`t]/aij}];

(* Wall to Wall Diffusion (except for corners) *)

DRWW[X_,  FWall_, {cell1_, cell2_}]:=Module[{edge}, 
edge = edgeBetween[cell1,cell2];
{X[cell1,edge]\[RightArrowLeftArrow]Global`\[EmptySet],
 FWall[cell1,cell2, edge]/aij,  FWall[cell2,cell1,edge] X[cell2, edge][Global`t]/aij}
];

(* Wall to Wall Diffusion (at Corners) *)
(* Only allow diffusion between wall components of same cell *)

DRWWC[X_, FWall_, {e1_,e2_}]:=Module[{p,q,r,s, E1, E2, v1,v2, da, cell1, cell2, cell3, cell4,commonCell, theEdge,reaction,reaction2,c1,c2,c3,c4,e1cells,e2cells, interactionWidth,wall1Area,wall2Area, result}, 
dPrint["DRWWC e1,e2=", {e1,e2}]; 
{p,q} = e[[e1]]; 
{r,s} = e[[e2]]; 
dPrint["DRWWC {p,q},{r,s}=", {p,q},{r,s}]; 
E1 = edgeVariable[e1][Global`t]; (* edgeLengths[[e1]]; *)
E2 = edgeVariable[e2][Global`t]; (* edgeLengths[[e2]]; *) 
dPrint["DRWWC E1,E2=", E1,",", E2]; 

(*v1 = (v[[p]]-v[[q]])/E1; v2 = (v[[r]] -v[[s]])/E2; *)

Block[{vp,vq,vr,vs},
vp={x[p][Global`t],y[p][Global`t]};
vq={x[q][Global`t],y[q][Global`t]}; 
vr={x[r][Global`t],y[r][Global`t]};
vs={x[s][Global`t],y[s][Global`t]}; 
v1=(vp-vq)/E1;
v2=(vr-vs)/E2; 
(* 
v1 = (V[p][Global`t]-V[q][Global`t])/E1;
v2 = (V[r][Global`t] -V[s][Global`t])/E2;*)
]; 

(* Either r=q or r=p or s=q or s=p *)
(* Want vectors to either start at same point or end at same point *)
If[r==q || s==p, v2=-v2]; 
If[{p,q}=={r,s} || {p,q}=={s,r}, Print["Error: DRWWC: ", {p,q}, {r, s}]; Return[Infinity]]; 

(* da is the ratio d/a (diagonal/altitude) *)

interactionWidth = aij/Sqrt[(1.0-v1.v2)/2.0]; 
wall1Area=aij*E1;
wall2Area=aij*E2; 

(* replace l[p,q] with the edge between vertices p and q *) 


If[MemberQ[outeredges, e1], 
cell1 = Position[cellIndices, e1][[1,1]]; 
cell2 = 0;
, 
{cell1, cell2} = Position[Normal[allEdgesBetween], e1][[1]]

];
If[MemberQ[outeredges, e2],
cell3 = Position[cellIndices, e2][[1,1]]; 
cell4 = 0;
, 
{cell3, cell4} = Position[Normal[allEdgesBetween], e2][[1]]
];
{cell1,cell2,cell3,cell4}={cell1,cell2,cell3,cell4}/.toDynamicNumberRules; 
(* Ignore any edge-edge intersection that is not between edges of the same cell *)

commonCell={cell1,cell2}\[Intersection]{cell3,cell4};
dPrint["DRWWC {cell1,cell2}, {cell3, cell4}=", {cell1,cell2}, {cell3, cell4}];  
If[commonCell=={0}, dPrint["Edge Cell no common edge."];  Return[{}]]; 
If[commonCell=={}, dPrint["Edge Cell no common edge."];  Return[{}]]; 
commonCell = Complement[commonCell, {0}]; 
dPrint["commonCell=", commonCell]; 
commonCell = commonCell[[1]]; 
(* The PadRight adds a zero if there is only one cell that includes an edge *)
e1cells=PadRight[First/@Position[cellIndices,e1],2];
e2cells=PadRight[First/@Position[cellIndices,e2],2]; 
dPrint["DRWWC e1cells,e2cells:", e1cells,",",e2cells]; 

dPrint["DRWWC cell1,cell2,cell3,cell4=", {cell1,cell2}, {cell3,cell4}];
dPrint["DRWWC commonCell=", commonCell];  

dPrint["DRWWC linteractionWidth=", interactionWidth]; 
dPrint["DRWWC {wall1Area, wall2Area}:", {wall1Area, wall2Area}]; 

{c1,c2}=e1cells;


reaction={{X[commonCell,e1]\[RightArrowLeftArrow]Global`\[EmptySet],
(interactionWidth * FWall[c1,c2,e1]  )/(wall1Area) ,(interactionWidth *  FWall[c1,c2,e1]/(wall1Area)) X[commonCell,e1][Global`t]}};

{c3,c4}=e2cells;
reaction2={{X[commonCell,e2]\[RightArrowLeftArrow]Global`\[EmptySet],
(interactionWidth * FWall[c3,c4,e2]  )/(wall2Area),(interactionWidth *  FWall[c3,c4,e2]/(wall2Area) )X[commonCell,e2][Global`t]}};
 
result = {reaction, reaction2};
dPrint["DRWWC result=", result]; 

Return[result]; 
];


(* diffusion cell to adjacent wall *) 

diffusionReactions[X_ ,Fout_, Fin_, p_]:=Module[{t1,t2,t, nbrs},
nbrs = neighbors[p];
dPrint["diffusionReactions: p, nbrs: ",p,";",  nbrs]; 
t1=Table[DR[X,Fout, Fin, {p,inbr}], {inbr, nbrs}];
t2= Table[DRW[ X, Fout, Fin, {p, inbr}], {inbr, nbrs}]; 
t=Join[t1,t2];
dPrint["dbg: DiffusionReactions: t: ", t]; 
Return[t];
]; 

(* also need to diffuse from cell to adjacent wall of OUTER EDGE cells *)

diffusionOEReactions[X_, Fout_, Fin_]:=Map[DR[X,Fout, Fin, {#,0}]&, outercells];


(* drow does not work for dynamic walls *)

drow[X_,Fout_,Fin_, {cell_,edge_}]:=
{
{X[cell]\[RightArrowLeftArrow]Global`\[EmptySet],
  Fout[cell,0, edge]edgeVariable[edge][Global`t]/(areaVariable[cell][Global`t]),(  Fin[cell,0,edge] edgeVariable[edge][Global`t]/ (areaVariable[cell][Global`t])) X[cell,edge][Global`t]},
{X[cell, edge]\[RightArrowLeftArrow]Global`\[EmptySet],
 Fin[cell,0,edge]/aij ,
( Fout[cell,0,edge]) X[cell][Global`t]/aij}
};



DROW[X_,  Fout_, Fin_]:= Module[{cells,cell,dcell,rlist, edges, nextr, dbg=False,ddPrint},
ddPrint[u___]:= If[dbg, Print[u]]; 
rlist={}; 
cells = outercells;
dPrint["DROW: outer cells: ", cells]; 
While[Length[cells]>0,
cell = First[cells]; cells=Rest[cells]; 
edges = (cellIndices[[cell]] \[Intersection] outeredges); 
dcell = cell/.toDynamicNumberRules; 
ddPrint["DROW: dcell: ", dcell, " edges: ", edges]; 

(*Print["c=", c, "c[cell]=", c[[cell]]," edges=", edges]; *) 
AppendTo[rlist, drow[X,  Fout, Fin,{dcell, #}]&/@edges]
];
ddPrint["DROW: rlist:", rlist]; 
Return[rlist]; 
]; 


(* diffusion cell wall to adjacent cell wall *)

diffusionWWReactions[X_, Fwall_, p_]:=Module[{nbrs},
nbrs = neighbors[p];
dPrint["diffusionWWReactions: p, nbrs = ", p," ; ", nbrs]; 
Table[DRWW[X, Fwall, {p,inbr}],{inbr,nbrs}]
];

(* need to drop all outer edges from the following *)
dPrint["eused: ", eused]; 
intesectingEdges=
Most/@Select[Join@@Table[{eused[[i]],eused[[j]],Length[e[[eused[[i]]]]\[Intersection]e[[eused[[j]]]]]},{i,1,neused},{j,i+1,neused}],Last[#]>0&];

dPrint["intesectingEdges = ", intesectingEdges]; 

difSpec=diffusingSpecies;
While[Length[difSpec]>0,
dPrint["difSpec: ",difSpec];
diffData=First[difSpec];
difSpec=Rest[difSpec];

Y=diffData[[1]];
dPrint["diffData=",diffData, " Y=", Y];

If[Length[diffData]>1,
\[Beta]out=getTransferFunction[diffData[[2]]],
\[Beta]out=0&
]; 
dPrint["\[Beta]out=",\[Beta]out];

If[Length[diffData]>2,
\[Beta]in=getTransferFunction[diffData[[3]]];,
\[Beta]in=0&
]; 
dPrint["\[Beta]in=",\[Beta]in];
If[Length[diffData]>3,
\[Beta]wall=getTransferFunction[diffData[[4]]];,
\[Beta]wall=0&
]; 
dPrint["\[Beta]wall=",\[Beta]wall];

temp={}; 

 
(* *)
Block[{temp1, temp2, temp3, temp4}, 
dPrint["cellIndices: ", cellNumbers]; 
temp1=Flatten[Join[diffusionReactions[Y,\[Beta]out, \[Beta]in, #]&/@cellNumbers],1];
dPrint["temp1: ", temp1]; 

temp2=Join@@(diffusionWWReactions[Y,\[Beta]wall,#]&/@cellNumbers); 
dPrint["temp2: ", temp2];  
 temp3 = Flatten[Join@@ DRWWC[Y,\[Beta]wall, #]&/@intesectingEdges,1]; 
dPrint["temp3=", temp3]; 
temp4 = Flatten[Join@@DROW[Y, \[Beta]out, \[Beta]in],1]; 
 dPrint["temp4=", temp4];  
temp = Join@@{temp1, temp2, temp3, temp4};

]; 
(* *) 

nxtra=Length[Select[temp, Complement[Rest[#],{0.,0}] ==  {}&]]; 
If[nxtra>0, 
Print["Removing ",nxtra," null reactions for ", Y]]; 


temp=Select[temp, Complement[Rest[#],{0.,0}] != {}&]; 

diff=Join[diff,temp]; 
];

];
Return[diff]
]; 


(* ::Input::Initialization:: *)
generateCelleratorWalledPumpReactions[c_,  pumps_, allEdgesBetween_, allneighbors_,outercells_, outeredges_, 
edgeVariable_, areaVariable_, aij_, options___?OptionQ]:= Module[{pr,XPR,XPROW,  pumpReactions,pumpReactionsOuterWall,pumpdata,nextpump,Y, F,F1,Fin,Fout,F2,  temp1, temp2, temp, DPrint, ZERO, neighbors,dbg,n, cellNumbers,toDynamicNumberRules,toStaticNumberRules, cellIndices}, 
dbg = "Debug"/.{options}/.{"Debug"-> False};
DPrint[x___]:=If[dbg, Print["DBG:generateCelleratorWalledPumpReactions:",x]]; 

cellNumbers=First/@c;
toDynamicNumberRules =MapThread[Rule,{ Range[Length[c]],cellNumbers}]; 
toStaticNumberRules=Reverse/@toDynamicNumberRules; 
DPrint["toDynamicNumberRules: ", toDynamicNumberRules]; 
DPrint["toStaticNumberRules: ", toStaticNumberRules]; 

cellIndices = Last/@c;

pr={}; 
n=Length[c]; 
If[Length[pumps]>0,
ZERO[p_,q_, r_]:= 0; 
neighbors[p_]:=(allneighbors[[p/.toStaticNumberRules]])/.toDynamicNumberRules;



DPrint["pumps: ", pumps];
(* Pump Reaction - *)
(* Convert reactions x[i] \[Rule] x[i,edge} and x[i,edge]\[Rule] x[i] into: *)
(* Reactions x[i] \[Rule] \[EmptySet], \[EmptySet] \[Rule] x[i], x[i,edge]\[Rule] \[EmptySet], \[EmptySet] \[Rule] x[i,edge]*)
XPR[X_,fout_,fin_, {p_,q_}]:=
Module[{edge,r1,r2,r3,r4, AW,AC, E},
edge=allEdgesBetween[[p/.toStaticNumberRules,q/.toStaticNumberRules]];
E=edgeVariable[edge][Global`t];
AW = aij * E;  
AC = areaVariable[p][Global`t]; 
r1={X[p]\[Implies] Global`\[EmptySet],fout[p,q,edge]*E/AC};
r2={Global`\[EmptySet]\[Implies] X[p, edge],fout[p,q, edge] *E/AC   };
r3={X[p,edge]\[Implies] Global`\[EmptySet], fin[p,q,edge] *E/AC};
r4={Global`\[EmptySet]\[Implies]X[p], fin[p,q,edge]*E/AC}; 
{r1,r2,r3,r4}
];

(* Same Thing but for outer wall *)
XPROW[X_,fout_, fin_, {cell_,edge_}]:=Module[{r1,r2,r3,r4, E,AC, AW},
E=edgeVariable[edge][Global`t];
AC = areaVariable[cell][Global`t]; 
AW = aij * E;  
r1={X[cell]\[Implies] Global`\[EmptySet],fout[cell,0, edge]*E/AC};
r2={Global`\[EmptySet]\[Implies] X[cell, edge],fout[cell,0,edge] *E/AC};
r3={X[cell,edge]\[Implies] Global`\[EmptySet], fin[cell,0,edge]*E/AC};
r4={Global`\[EmptySet]\[Implies]X[cell], fin[cell,0,edge]*E/AC}; 
Return[{r1,r2,r3,r4}]
];

(* Generate list of reactions for a given cell corresponding to all of its neighbors *)

pumpReactions[X_,FOUT_,FIN_ ,p_]:=Module[{reactions,nbrs},
nbrs=neighbors[p]; 
DPrint["pumpReactions: p: ", p, " neighbors: ", nbrs]; 
reactions=Join@@Table[
XPR[X,FOUT, FIN, {p,inbr}],{inbr,nbrs}]
];

pumpReactions[X_, FOUT_, FIN_]:= Join@@(pumpReactions[X,FOUT,FIN,#]&/@cellNumbers); 

pumpReactionsOuterWall[X_, FOUT_,FIN_]:= Module[
{cells,cell,result, edges, nextr},
result={}; 
cells = outercells;
DPrint["pumpReactionsOuterWall: outercells: ", outercells]; 
While[Length[cells]>0,
cell = First[cells]; cells=Rest[cells]; 
edges = (cellIndices[[cell]] \[Intersection] outeredges); 
result=Join[result, XPROW[X, FOUT,FIN,{cell/.toDynamicNumberRules, #}]&/@edges]
];
result = Join@@result; 
Return[result]; 
]; 

pumpdata=pumps; 
DPrint["pumpdata: ", pumpdata]; 
While[Length[pumpdata]>0,
nextpump=First[pumpdata];
pumpdata=Rest[pumpdata]; 
If[Not[ListQ[nextpump]], Print["Error: Incorect form for pump data:  ", nextpump]; Abort[]];
If[Length[nextpump]<1, Print["Error: No species specified for pump data: ", nextpump]; Abort[]];
DPrint["nextpump:", nextpump];
Y=nextpump[[1]]; 
If[Length[nextpump]>1, 
F1=nextpump[[2]];

If[SameQ[Head[F1], Function],
Fout=F1,
Fout=Evaluate[F1]&];
, 
Fout=ZERO]; 
If[Length[nextpump]>2, 
F2=nextpump[[3]];
DPrint["F2=", F2]; 
If[SameQ[Head[F2], Function],
Fin=F2,
Fin=Evaluate[F2]&];
, 
Fin=ZERO]; 

DPrint["{Y,Fout,Fin}:", {Y, Fout, Fin}]; 

temp1=pumpReactions[Y,Fout,Fin];
DPrint["temp1:", temp1];
temp2=pumpReactionsOuterWall[Y,Fout,Fin];
DPrint["temp2:", temp2]; 
temp = Join[temp1, temp2];

Block[{nxtra},
nxtra=Length[Select[pr, Complement[Rest[#],{0.,0}] ==  {}&]]; 
If[nxtra>0, 
Print["Removing ",nxtra," null reactions for ", Y]]; 

temp=Select[temp, Complement[Rest[#],{0.,0}] != {}&]; 
]; 

pr = Join[pr, temp];
]; 

DPrint["pr=", pr]; 

];
 
Return[pr]
];


(* ::Input::Initialization:: *)
generateCelleratorInWallReactions[wall_,cells_, verbose_:True]:= Module[{wallreactions,w,cellnumber,edgenumber,thenextcell,edgewallpairs,subnet,i},
wallreactions={}; 
If[Length[wall]>0,
If[verbose, Print[Length[wall]," internal reactions in each wall compartment."]]; 
edgewallpairs = Flatten[MapThread[Outer[List,{#1},#2]&,Transpose[cells/.{Rule->List}]],2]; 
w=lowLevelReactions[wall];
w=indexify[w,i]/.{i-> Sequence@@{cellnumber,edgenumber}};
subnet[i_]:=indexify[wall,i];
wallreactions = Join@@(subnet[i]/.{i->Sequence@@#}&)/@edgewallpairs;
];
Return[wallreactions];  
];


(* ::Input::Initialization:: *)
getBC[opt___?OptionQ]:=Module[{boundaryConditions,okbc,BCVars,BCVals, dbg=False, dPrint, diffVars, pumpVars,missingBC},
dPrint[x___]:= If[dbg, Print["getBC: ", x]]; 
boundaryConditions = "BoundaryConditions"/.{opt}/.{"BoundaryConditions"-> {}}; 
diffVars = First/@("Diffusion"/.{opt}/.{"Diffusion"-> {}});
pumpVars =First/@("Pumps"/.{opt}/.{"Pumps"-> {}}); 
okbc=False; 
If[RuleQ[boundaryConditions],okbc=And@@(NumberQ/@Last/@boundaryConditions)];
If[okbc,
BCVars =First/@boundaryConditions;
BCVals = Last/@boundaryConditions;
dPrint["BCVars: ", BCVars]; 
dPrint["BCVals: ", BCVals]; 
boundaryConditions=MapThread[Rule[#1 [0][Global`t], #2]&, {BCVars, BCVals}]; 
,
Print["Error: Invalid Format for \"BoundaryConditions\"\[Rule]",boundaryConditions," should be alist of rules of the form variable \[Rule] number."];
boundaryConditions={}
];
diffVars=Complement[diffVars,BCVars];
pumpVars=Complement[pumpVars,BCVars];
missingBC = Union[Flatten[{diffVars,pumpVars}]]; 
missingBC = (#[0][Global`t]-> 0)&/@missingBC; 

dPrint["missinBC: ", missingBC];  
boundaryConditions = Join[boundaryConditions, missingBC]; 


Return[boundaryConditions]; 
]



(* ::Input::Initialization:: *)
StaticSimulation[DT_DTissue, tstart_, tstop_, opt___?OptionQ]:= Module[{},

grow[DT,tstart, tstop,
"Growing"-> False, 
"DivisionThreshold"-> Infinity,
opt, 
"Intercellular"->{},
"IC"->{},
"Walls"->False,
"TestCase"->"Static-Simulation",
"Reactions"->{},
"Pumps"->{}, 
"Diffusion"->{},
"WallReactions"->{},
"BoundaryConditions"->{},
"Parameters"->{},
"Verbose"->False,
"Show"-> False, 
(* turn off position dependent variables by default to save CPU *)
"tip"->False,
"xy"->False,
(* make simulation internal and do not save to file to save CPU *)
"Internal"->True,"Save"->False
]
]


(* ::Input::Initialization:: *)
generateTipEquations[T_, x_, y_, tip_]:= Module[{ v, tipEQ, vx,vy, itip,n,tops, found, top,allcellnumbers}, 
If[ToString[tip]=="False", Return[{"equations"-> {}, "vertex"-> False}]]; 

(* there may be some vertices that are not used in cells, what to ignore those! *)
v=TissueVertices[T]; 
n=Length[v];
tops=Reverse[Ordering[Last/@v]];
found=False;
top=0;
allcellnumbers=Union@@CellVertexNumbers[T];
While[Length[tops]>0\[And]Not[found],
top=First[tops];tops=Rest[tops];
If[MemberQ[allcellnumbers,top],found=True]
];
tipEQ=(
{vx,vy}=Transpose[v];
itip=top;
{tip[1][Global`t]== x[itip][Global`t],
tip[2][Global`t]== y[itip][Global`t]}
);
Return[{"equations"-> tipEQ, "vertex"-> itip}]
];


(* ::Input::Initialization:: *)
generateTipIndicatorEquations[T_, TIP_, vtip_]:= Module[{cvn,icell,n, eqs},
If[ToString[TIP]== "False", Return[{}]]; 
AbortIf[ToString[vtip]=="False", "\"TipFlag\"\[Rule]True but by \"tip\"\[Rule]False; A tip variable must be set if the TipFlag is used."];
If[ToString[vtip]=="False", Return[{}]]; 
cvn = MemberQ[#,vtip]&/@CellVertexNumbers[T]; 
n = Length[cvn]; 
icell=Pick[Range[n], cvn];
eqs=(If[MemberQ[icell, #], TIP[#][Global`t]== 1, TIP[#][Global`t]== 0]&/@Range[n]);
Return[eqs]; 
]


(* ::Input::Initialization:: *)
generateCenterEquations[T_Tissue,center_,x_, y_,  area_]:= Module[{centroidEQS, cf,j, n,fx, fy}, 
n=NTissueCells[T]; 
centroidEQS={}; 
If[ToString[center]!= "False",
cf[j_]:= CentroidFormula[T,j,x,y,area]; 
For[j=1, j<= n, j++,
{fx,fy}=cf[j]; 
AppendTo[centroidEQS,center[j,1][Global`t]== fx];
AppendTo[centroidEQS,center[j,2][Global`t]== fy];
];
];

Return[centroidEQS]
];


(* ::Input::Initialization:: *)
generateTipDistanceEquations[tipdist_,center_, tip_,n_]:= Module[{tipdistEQS, j}, 
tipdistEQS={}; 
 
If[ToString[tipdist]!= "False",
AbortIf[
ToString[center]==  "False",
"Error: \"tipDistance\" variable has been requested, but \"center\" variable name has not been assigned. Assign a variable name to \"center\" and re-run the program. "
]; 
AbortIf[
ToString[tip]==  "False",
"Error: \"tipDistance\" variable has been requested, but \"tip\" variable name has not been assigned. Assign a variable name to \"tip\" and re-run the program. "
]
For[j=1, j<=n, j++, 
AppendTo[tipdistEQS,
tipdist[j][Global`t]== 
Norm[{center[j,1][Global`t]-tip[1][Global`t],center[j,2][Global`t]-tip[2][Global`t]}]
];
]; 

]; 


Return[tipdistEQS]
]; 


(* ::Input::Initialization:: *)
generateL1Equations[T_, L1_]:= Module[{l1cells,n,eqs},
If[ToString[L1]== "False", Return[{}]]; 
l1cells=L1Cells[T];
n=NTissueCells[T];
eqs=(If[MemberQ[l1cells, #], L1[#][Global`t]== 1, L1[#][Global`t]== 0]&/@Range[n]);
eqs
];
generateL2Equations[T_, L2_]:= Module[{l2cells,n,eqs},
If[ToString[L2]== "False", Return[{}]]; 
l2cells=L2Cells[T];
n=NTissueCells[T];
eqs=(If[MemberQ[l2cells, #], L2[#][Global`t]== 1, L2[#][Global`t]== 0]&/@Range[n]);
eqs
]


(* ::Input::Initialization:: *)
generatePDEquations[T_Tissue, center_, PD_, x_, y_]:= Module[{DT},
If[ToString[PD]== "False", Return[{}]]; 
DT=Tissue2DTissue[T];
AbortIf[ToString[center]=="False", "PrincipalDirection requested by \"center\" not defined."]; 
SVDPrincipalDirectionFormula[DT,center, PD,x,y]
]


(* ::Input::Initialization:: *)
generateSpecialVariables[T_, opt___?OptionQ]:= Module[{tip, tipEQ, center,x, y, v, area, centroidEQS, tipdist, tipdistEQS, eqs,n, L1, L2, L1EQS, L2EQS, vtip, tipf, TFEQ, dbg=False, dPrint, xy, PD, PDEQS}, 

dPrint[u___]:= If[dbg, Print["generateSpecialVariables: ", u]]; 

xy="xy"/.{opt}/.{"xy"-> True}; 
If[ToString[xy]=="False", Return[{}]]; 

x = "x"/.{opt}/.{"x"-> Global`x}; 
y="y"/.{opt}/.{"y"-> Global`y}; 

v=TissueVertices[T]; 

tip="tip"/.{opt}/.{"tip"-> Global`tip}; 
tipEQ=generateTipEquations[T, x, y, tip];
vtip = "vertex"/.tipEQ;
tipEQ="equations"/.tipEQ; 

dPrint["tipEQ: ", tipEQ]; 

tipf="TipFlag"/.{opt}/.{"TipFlag"-> False};
TFEQ=generateTipIndicatorEquations[T,tipf,vtip]; 
dPrint["TFEQ: ", TFEQ]; 

center = "center"/.{opt}/.{"center"-> False}; 
area="CellVariable"/.{opt}/.{"CellVariable"-> Global`cell}; 
centroidEQS=generateCenterEquations[T,center,x, y, area];
dPrint["cengtroidEQS: ", centroidEQS]; 

tipdist = "tipDistance"/.{opt}/.{"tipDistance"-> False}; 
n=NTissueCells[T]; 
tipdistEQS=generateTipDistanceEquations[tipdist,center, tip,n]; 
dPrint["tipdistEQS: ", tipdistEQS]; 


L1 = "L1"/.{opt}/.{"L1"-> False}; 
L1EQS = generateL1Equations[T, L1]; 
dPrint["L1: ", L1EQS]; 

L2 = "L2"/.{opt}/.{"L2"-> False}; 
L2EQS = generateL2Equations[T, L2]; 
dPrint["L2: ", L2EQS]; 


PD = "PrincipalDirection"/.{opt}/.{"PrincipalDirection"-> False}; 
PDEQS=generatePDEquations[T, center, PD, x, y]; 



eqs=Join[tipEQ, centroidEQS, tipdistEQS, L1EQS, L2EQS,TFEQ, PDEQS]; 
 

Return[eqs]
]


(* ::Input::Initialization:: *)
generateGrowthReactions[c_,cvn_, e_,vertexCoordinates_,eused_,vused_, edgeVariable_,outeredges_, opt___?OptionQ]:=Module[{ne,\[Mu],k,P,\[CapitalPsi],rest,ER,DR,GR,verbose,vPrint,edgeBetween,nv,v,neighbors,xR,xRterm,XYR,yR,yRterm,x,y,R,equations,EV,EVS,PR,eflags,vflags,neused,nvused, eallowed,
GV, \[Mu]min, \[Mu]max, \[Mu]\[Theta]0,\[Mu]outer, GVS, isotropic,kmin, kmax,k\[Theta]0,kouter, isospring, SE, SES,kvar, kformula,kindexed, dbg=False, dPrint,cellsAbuttingEdge, outers,upwards, tip,iv, tipEQ,
muindexed,muvar,muformula,vx,vy,itip,outerperps, L1L2,kouters, muouters, muL1L2,muouterperps,\[Mu]L1,\[Mu]L1L2,center, DT, T,area, cf, centroidEQS,n,fx,fy, perim, perimEQS,  PREQ, tipdist, tipdistEQS,j,SVEQS, EVX, EVY, EVARX, EVARY, ell
},
dPrint[u___]:= If[dbg, Print["generateGrowthReactions: ", u]]; 

DT=DTissue[vertexCoordinates,e,c]; 
T=DTissue2Tissue[DT];
n=NTissueCells[T];  

(* top[{{x1_,y1_},{x2_,y2_}}]:= Max[y1,y2];
len[{{x1_,y1_}, {x2_,y2_}}]:= Norm[{x2-x1,y2-y1}]; *)
ne=Length[e];
nv=Length[vertexCoordinates];

(*In future iterations replace mu,k,with indexed variable in the same way as diffusion rates*)
verbose="Verbose"/.{opt}/.{"Verbose"->False};
vPrint[x___]:=If[verbose,Print[x]];
\[Mu]="mu"/.{opt}/.{"mu"->Global`\[Mu]};

(* \[Mu]x="mux"/.{opt}/.{"mux"\[Rule]1}; 
\[Mu]y="muy"/.{opt}/.{"muy"\[Rule]1}; *)

\[Mu]max="mumax"/.{opt}/.{"mumax"->1}; 
\[Mu]min="mumin"/.{opt}/.{"mumin"->\[Mu]max}; 
\[Mu]\[Theta]0=(Pi/180.0)*("muMaxDegrees"/.{opt}/.{"muMaxDegrees"->90.0}); 
\[Mu]outer="muouter"/.{opt}/.{"muouter"-> False}; 
\[Mu]L1L2="muL1L2"/.{opt}/.{"muL1L2"-> False};
\[Mu]L1="muL1"/.{opt}/.{"muL1"-> False};  

upwards = "Upwards"/.{opt}/.{"Upwards"-> False}; 

{outers,outerperps , L1L2}=findOuters[upwards,vertexCoordinates,e,Last/@c, outeredges];

If[NumberQ[\[Mu]L1L2], muL1L2=L1L2,muL1L2={}]; 
If[NumberQ[\[Mu]outer], muouters=outers, muouters={}]; 
If[NumberQ[\[Mu]L1], muouterperps=outerperps, muouterperps={}]; 


kmax="kmax"/.{opt}/.{"kmax"->1};
kmin="kmin"/.{opt}/.{"kmin"->kmax}; 
k\[Theta]0 = (Pi/180.0)*("kMaxDegrees"/.{opt}/.{"kMaxDegrees"-> 90.0}); 
kouter = "kouter"/.{opt}/.{"kouter"-> False}; 
If[NumberQ[kouter], kouters=outers, kouters={}]; 



k="k"/.{opt}/.{"k"->Global`springconstant};
P="P"/.{opt}/.{"P"->Global`P};
x="x"/.{opt}/.{"x"->Global`x};
y="y"/.{opt}/.{"y"->Global`y};
eflags = MemberQ[eused,#]&/@Range[ne];  
neused = Length[eused]; 
vflags = MemberQ[vused,#]&/@Range[nv];  
nvused = Length[vused];

iv=Pick[Range[nv], vflags]; 

(* coordinates of tip of "template" (tip of meristem) *)
SVEQS=generateSpecialVariables[T,opt];
dPrint["SVEQS: ", SVEQS]; 


(* perimeters *)
perim="perimeter"/.{opt}/.{"perimeter"-> False}; 
perimEQS={}; 
If[ToString[perim]!=  "False",
For[j=1, j<= n, j++, 
AppendTo[perimEQS, perim[j][Global`t]== PerimeterFormula[T,j,edgeVariable]]; 
];
];  
dPrint["perimEQS: ", Short[perimEQS,5]]; 

rest="Restlength"/.{opt}/.{"Restlength"->Global`resting};
\[CapitalPsi][u_]:=(u+Abs[u])/2;

(*growth of the spring-increase in resting length*)(*Subscript[d\[ScriptL],ij]/dt=Subscript[\[Mu],ij]\[CapitalPsi][(Subscript[d,ij]-Subscript[\[ScriptL],ij])]*)


isotropic = "IsotropicGrowth"/.{opt}/.{"IsotropicGrowth"-> True}; 
isospring="IsotropicSprings"/.{opt}/.{"IsotropicSprings"-> True}; 


muindexed=False; 
If[ListQ[\[Mu]],
muindexed=True; 
muvar=First[\[Mu]];
muformula=Rest[\[Mu]];
If[Length[muformula]>0, muformula=muformula[[1]], muformula=1&]; 
\[Mu]=muvar;
,
muformula=1&;
muvar=\[Mu]; 
];

If[dbg,
dPrint["muindexed = ", muindexed]; 
dPrint["muvar=", muvar]; 
dPrint["muformula=", muformula]; 
dPrint["\[Mu]=", \[Mu]]; 
]; 

If[isotropic,
ER[j_]:={Global`\[EmptySet]->rest[j],\[Mu]*\[CapitalPsi][edgeVariable[j][Global`t]-rest[j][Global`t]]},
ER[j_]:={Global`\[EmptySet]->rest[j],\[Mu][j][Global`t]*\[CapitalPsi][edgeVariable[j][Global`t]-rest[j][Global`t]]}
]; 


GR=Join@@({ER[#]}&/@Pick[Range[ne],eflags]);
vPrint[Length[GR]," spring growth reactions."];

(*vertex dynamics due to springs*)

v=Pick[Range[nv],vflags];

eallowed = Pick[e,eflags]; 
neighbors[v_]:=Complement[Flatten[Select[eallowed,MemberQ[#,v]&]],{v}];
edgeBetween[p_,q_]:=Union[Flatten[{Position[e,{p,q}],Position[e,{q,p}]}]][[1]];
cellsAbuttingEdge[p_]:= PadRight[Flatten[First/@Position[c,p]],2];

kindexed=False; 
If[ListQ[k],
kindexed=True; 
kvar=First[k];
kformula=Rest[k];
If[Length[kformula]>0, kformula=kformula[[1]], kformula=1&]; 
k=kvar;
,
kformula=1&;
kvar=k; 
];
If[dbg,
dPrint["kindexed = ", kindexed]; 
dPrint["kvar=", kvar]; 
dPrint["kformula=", kformula]; 
dPrint["k=", k]; 
]; 





If[isospring,
xRterm[i_,j_]:=With[{p=edgeBetween[i,j]},k*(x[j][Global`t]-x[i][Global`t])*(1-rest[p][Global`t]/edgeVariable[p][Global`t])],
xRterm[i_,j_]:=With[{p=edgeBetween[i,j]},k[p][Global`t]*(x[j][Global`t]-x[i][Global`t])*(1-rest[p][Global`t]/edgeVariable[p][Global`t])]
]; 
xR[i_]:={Global`\[EmptySet]->x[i],Plus@@(xRterm[i,#]&/@neighbors[i])};
If[isospring,
yRterm[i_,j_]:=With[{p=edgeBetween[i,j]},k*(y[j][Global`t]-y[i][Global`t])*(1-rest[p][Global`t]/edgeVariable[p][Global`t])],
yRterm[i_,j_]:=With[{p=edgeBetween[i,j]},k[p][Global`t]*(y[j][Global`t]-y[i][Global`t])*(1-rest[p][Global`t]/edgeVariable[p][Global`t])]
];

yR[i_]:={Global`\[EmptySet]->y[i],Plus@@(yRterm[i,#]&/@neighbors[i])};
XYR=Join@@({xR[#],yR[#]}&/@Pick[Range[nv],vflags]);
vPrint[Length[XYR]," spring reactions."];

(*Set up equations (not ODEs)*)

ell=ToString[edgeVariable]; 
EVARX=ToExpression[ell<>"X"];
EVARY=ToExpression[ell<>"Y"]; 
EVX[i_]:=(EVARX[i][Global`t]==(x[e[[i,1]]][Global`t]-x[e[[i,2]]][Global`t]));
EVY[i_]:=(EVARY[i][Global`t]==(y[e[[i,1]]][Global`t]-y[e[[i,2]]][Global`t]));
EV[i_]:= (edgeVariable[i][Global`t]==Sqrt[EVARX[i][Global`t]^2 + EVARY[i][Global`t]^2]);

(*EV[i_]:=With[{v1=e[[i,1]],v2=e[[i,2]]},
(edgeVariable[i][Global`t]\[Equal]Sqrt[(x[v1][Global`t]-x[v2][Global`t])^2+(y[v1][Global`t]-y[v2][Global`t])^2])];
*)
EVS=
Join[
EVX/@Pick[Range[ne], eflags], 
EVY/@Pick[Range[ne], eflags],
EV/@Pick[Range[ne],eflags]
]; 

If[isotropic,
GVS={},
(* Anisotropic Growth mu = mumin + (mumax - mumin) Cos^2(theta-theta0)*)

GV[i_]:= Module[{v1,v2, cosine, sine, cos0=Cos[\[Mu]\[Theta]0], sin0=Sin[\[Mu]\[Theta]0], costotal, formula,p,q}, 
Which[

(* for upwards growth use the outer edge value *)
upwards \[And] MemberQ[muouters, i], 
formula=(\[Mu][i][Global`t]==\[Mu]outer), 

(* inhibit perp. growth in L1 *)

upwards \[And] MemberQ[muouterperps, i], 
formula=(\[Mu][i][Global`t]==\[Mu]L1), 

(* inhibit growth on L1/L2 interface *)

upwards \[And] MemberQ[muL1L2, i], 
formula=(\[Mu][i][Global`t]==\[Mu]L1L2), 


(* Otherwise, apply the growth model *)
True,
v1=e[[i,1]];v2=e[[i,2]];
cosine = (x[v1][Global`t]-x[v2][Global`t])/ edgeVariable[i][Global`t];
sine =(y[v1][Global`t]-y[v2][Global`t])/ edgeVariable[i][Global`t];
(* Use Cos(x-y)=cosx cosy + sinx siny*)
costotal = cosine*cos0 + sine*sin0;
If[muindexed,
{p,q}=cellsAbuttingEdge[i];
formula=(\[Mu][i][Global`t]==((\[Mu]max-\[Mu]min)*Abs[(costotal)] + \[Mu]min)*(muformula@@{p,q,i})),
formula=(\[Mu][i][Global`t]==((\[Mu]max-\[Mu]min)*Abs[(costotal)] + \[Mu]min))
];
]; 

Return[formula]; 
];
GVS = GV/@Pick[Range[ne], eflags]
]; 

dPrint["GVS=",Short[ GVS,5]]; 

(* Non-isotropic spring constants *)

If[isospring,
SES={},

(* Anisotropic Growth: k = kmin + (kmax-kmin)*Cos^2(theta-theta0)*)

SE[i_]:= Module[
{v1,v2,p,q, cosine, sine,costotal,cos0=Cos[k\[Theta]0], sin0=Sin[k\[Theta]0], formula}, 
v1=e[[i,1]];
v2=e[[i,2]];
cosine = (x[v1][Global`t]-x[v2][Global`t])/ edgeVariable[i][Global`t];
sine =(y[v1][Global`t]-y[v2][Global`t])/ edgeVariable[i][Global`t];
costotal = cosine*cos0 + sine*sin0;

If[kindexed,
{p,q}=cellsAbuttingEdge[i];
formula=(k[i][Global`t]==((kmax-kmin)*Abs[(costotal)]+ kmin)*(kformula@@{p,q,i}))
,
Which[
upwards \[And] MemberQ[kouters, i], 
formula=(k[i][Global`t]==kouter),

(*upwards \[And] MemberQ[outerperps, i], 
formula=(k[i][Global`t]\[Equal]kmin),
*)
True,
formula=(k[i][Global`t]==(kmax-kmin)*Abs[(costotal)] + kmin)
]; 
];
 
Return[formula]; 
];
SES = SE/@Pick[Range[ne], eflags]
]; 

dPrint["SES = ", Short[SES,5]]; 

equations=Join[EVS, GVS, SES,perimEQS, SVEQS];

(*Pressure Force on Outer Wall (for Stability)*)

If[ListQ[P],
PR=generateIndexedPressureReactions[P,x,y, vertexCoordinates, e, c, vused, eused, cvn];
PREQ = "equations"/.PR;
PR="reactions"/.PR; 
equations=Join[equations,PREQ]; 
,

PR=generateCelleratorOuterWallPressurePressureReactions[x,y,P,c,cvn, e,outeredges,vertexCoordinates,vused,eused, opt];
PREQ={}; 
];

dPrint["PR=", Short[PR,5]]; 
dPrint["PREQ=", Short[PREQ,5]]; 

vPrint[Length[PR]," pressure reactions."];


R=Join[GR,XYR,PR];




Return[{"reactions"->R,"equations"->equations}];];


(* ::Input::Initialization:: *)
findOuters[upwards_,v_,e_,c_, outeredges_]:= Module[{ymin,dbg=False,dPrint,eoe,eouter,edgelengths,len,top,meanlength,tops,bottoms,outers,perps,n,L1AC,flags, L1L2, T},

dPrint[u___]:= If[dbg, Print["findOuters: ", u]]; 
top[{{x1_,y1_},{x2_,y2_}}]:= Max[y1,y2];
len[{{x1_,y1_}, {x2_,y2_}}]:= Norm[{x2-x1,y2-y1}]; 
outers={};
perps={}; 
If[upwards,
(* figure out which edges are on the L1 outer edge *)
ymin = Min[Last/@v]; 
dPrint["ymin=", ymin]; 
eoe=e[[outeredges]];
eouter = v[[#]]&/@eoe;
edgelengths=len/@eouter;
dPrint["lens: ", edgelengths]; 
meanlength=Mean[edgelengths];
dPrint["meanlength: ", meanlength]; 
tops = top/@eouter; 
dPrint["tops: ", tops];
bottoms = (#<0.5*meanlength)&/@tops;
dPrint["bottoms: ", bottoms];

outers=Pick[outeredges, Not/@bottoms];
dPrint["outers: ", outers]; 


eoe=e[[outers]];
n=Length[e];
L1AC[edge_]:=Length[Flatten[Union[Intersection[edge,#]&/@eoe]]]>0;
flags=L1AC/@e;
perps=Complement[Pick[Range[n],flags],outers];
perps=Complement[perps,bottoms];

T=Tissue[v,e,c]; 
L1L2=FindL1L2Edges[T, meanlength]; 

];
Return[{outers,perps, L1L2}];
]


(* ::Input::Initialization:: *)
generateIndexedPressureReactions[P_, x_,y_, v_, e_, c_, vused_, eused_, cvn_]:= Module[{dbg=False, dPrint, pvar, pfunc, cellnumbers, cells,  edgesAtVertex,ev, cellsAbuttingEdge,cellsAbuttingEdges,cv,i, vertex, RelevantEdges, RelevantCells,centroids,nv,xreactions,yreactions, edge, edgecells,iedge, nextcell, TheEdge, TheVertices, TheMidPoint,x1,y1,x2,y2,ANormalVector,TheVerticesVariables,x1v,x2v,y1v,y2v,ANormalVectorVariables,TheCentroid,AnOutwardVector,TheNormalVector,TheNormalVectorVariables,mult,TheRates,xRate,yRate,icell, eqs},
dPrint[u___]:= If[dbg, Print["Indexed Pressure: ", u]]; 
pvar = First[P];
If[Length[P]>1, pfunc=P[[2]], pfunc=1&]; 
dPrint["P: ", P]; 
dPrint["pfunc: ", pfunc];
cellnumbers = First/@c;
cells = Last/@c; 
dPrint["vused: ", vused]; 
edgesAtVertex[j_]:= First/@Position[e,j];
ev=edgesAtVertex/@vused;
dPrint["edges at each used vertex: ", ev]; 
cellsAbuttingEdge[j_]:= First/@Position[cells,j];
cellsAbuttingEdges[j_]:= cellsAbuttingEdge/@j;
cv=cellsAbuttingEdges/@ev;
dPrint["cells along each set of edges: ", cv]; 
centroids=Centroid/@(v[[#]]&/@cvn);
dPrint["centroids: ", centroids]; 
nv=Length[vused]; 
xreactions={};
yreactions={};

 For[i=1,i<= nv, i++,
vertex = vused[[i]];
RelevantEdges = ev[[i]];
RelevantCells=cv[[i]];
dPrint["vertex: ", vertex, " edges: ", RelevantEdges, " Cells: ", RelevantCells]; 
For[iedge=1, iedge<= Length[RelevantEdges], iedge++,
edge=RelevantEdges[[iedge]];
edgecells=RelevantCells[[iedge]];
(* dPrint["---: edge ", edge, " abuts  cells " , edgecells]; *)
TheEdge=e[[edge]];
TheVertices=v[[#]]&/@TheEdge;
TheMidPoint=0.5*Plus@@TheVertices;
{{x1,y1},{x2,y2}}=TheVertices;
ANormalVector={y2-y1, x1-x2}; 

TheVerticesVariables={x[#][Global`t],y[#][Global`t]}&/@TheEdge;
{{x1v,y1v}, {x2v,y2v}}=TheVerticesVariables;
ANormalVectorVariables = {y2v-y1v, x1v-x2v}; 

For[icell=1, icell<= Length[edgecells], icell++,


nextcell=edgecells[[icell]]; 
dPrint["-----------------> Force on vertex " ,vertex, " along edge ", edge," due to pressure in cell ", nextcell] ;
TheCentroid=centroids[[nextcell]]; 
AnOutwardVector=TheMidPoint-TheCentroid;

If[AnOutwardVector.ANormalVector<0, mult=-1.0, mult=1.0]; 
TheNormalVector=Normalize[ANormalVector]*mult;
TheNormalVectorVariables=ANormalVectorVariables*mult; 
TheRates = 0.5*pvar[icell][Global`t]*TheNormalVectorVariables;
{xRate,yRate}=TheRates;



dPrint["TheEdge: ", TheEdge, " TheVertices: ", TheVertices,"The Vertices Variables: ", TheVerticesVariables," TheMidPoint: ", TheMidPoint, " Centroid: ", TheCentroid, " AnOutwardVector: ", AnOutwardVector, " ANormalVector: ", ANormalVector, " ANormalVectorVariables: ", ANormalVectorVariables, " TheNormalVector: ", TheNormalVector, " TheNormalVectorVariables: ", TheNormalVectorVariables, " TheRates:", TheRates];


AppendTo[xreactions,{Global`\[EmptySet]->x[vertex],xRate}]; 
AppendTo[yreactions,{Global`\[EmptySet]->y[vertex],yRate}]; 

];
];

]; 

ncells = Length[c]; 
eqs={}; 
For[icell=1, icell<= ncells, icell++, 
AppendTo[eqs, pvar[icell][Global`t]== pfunc[icell]]; 
]; 

dPrint["Reactions: ", {xreactions, yreactions}]; 
dPrint["Equations: ", eqs]; 


Return[ {
"reactions"-> Join[xreactions, yreactions],
"equations"-> eqs
}
];
];


(* ::Input::Initialization:: *)
generateCelleratorOuterWallPressurePressureReactions[x_,y_,P_,c_,cvn_, e_,outeredges_,vertexCoordinates_,vused_, eused_, opt___?OptionQ]:=Module[{r,reactions,allneighbors, oddneighbor,neighbors,outerv,outere, whichcell,dbg=False, dPrint,v},
dbg="DebugPressure"/.{opt}/.{"DebugPressure"-> False}; 
dPrint[u___]:= If[dbg, Print["generateCelleratorOuterWallPressurePressureReactions: ",u]]; 
dPrint["outeredges: ", outeredges]; 
dPrint["e: ", e]; 
dPrint["cvn: ", cvn]; 
outere=e[[outeredges]];
dPrint["outere: ", outere]; 
outerv=Union[Flatten[outere]];
neighbors[v_]:=Complement[Flatten[Select[outere,MemberQ[#,v]&]],{v}];
allneighbors[v_]:=Complement[Flatten[Select[eused,MemberQ[#,v]&]],{v}];
oddneighbor[v_]:=Complement[allneighbors[v], neighbors[v]]; 

r[i_]:=Module[{j,k,n, rx,ry,mult,dot},
{j,k}=neighbors[i];
n=oddneighbor[i]; 
n = Select[n, MemberQ[vused,#]&]; 
dPrint["Vertex i: ", i, ", neighbors {j,k}: ", {j,k},", oddneighbor n=",n]; 

If[Length[n]>0, 

n=First[n];
(* use third neighboring vertex as "inside" point*)
v=vertexCoordinates[[n]];
dPrint["using neighbor vertex = ", v]; 
, 

whichcell=Position[cvn,i];
While[ListQ[whichcell],whichcell=First[whichcell]]; 
v=Centroid[
vertexCoordinates[[   cvn[[whichcell]]]]];
dPrint["using cell centroid = ", v]; 
]; 
(*vector now*)

rx=vertexCoordinates[[j,2]]-vertexCoordinates[[k,2]];
ry=vertexCoordinates[[k,1]]-vertexCoordinates[[j,1]];
dot=({rx,ry}).(v-vertexCoordinates[[i]]);
mult=1.0;
If[dot>0,mult=-1.0];

(*dynamic vector*)

rx=mult*(P/2) (y[j][Global`t]-y[k][Global`t]);
ry=mult*(P/2) (x[k][Global`t]-x[j][Global`t]);

{{Global`\[EmptySet]->x[i],rx},{Global`\[EmptySet]->y[i],ry}}
];
reactions=Join@@(r/@outerv);
dPrint["reactions: ", reactions]; 
Return[reactions]; 
]


(* ::Input::Initialization:: *)
ShowPressureArrows[sim_,DT_,time_,pressure_,x_,y_, opt___?OptionQ]:=Module[{T,nv,n,origins,indices,xy,ct,ctr,cvn, vr,gt=Global`t,directions,a,cells,be,edges,PR,g,vused, dbg,dPrint,edgesused}, 
dbg="DebugPressure"/.{opt}/.{"DebugPressure"-> False}; 
dPrint[u___]:= If[dbg, Print["ShowPressureArrows: ",u]]; 
vused = VerticesUsed[DT]; 
nv=NTissueVertices[DT];
xy={x[#][gt],y[#][gt]}&/@Range[nv]/.Flatten[sim]/.{gt->time};
ct={x[#][gt],y[#][gt]}&/@Range[nv];
ctr=MapThread[Rule,{Flatten[ct],Flatten[xy]}];
T=DTissue2Tissue[DT];
cells=TissueCells[T];
edges=TissueEdges[T];
edgesused = edges[[EdgesUsed[T]]]; 
dPrint["edges: ", edges]; 
dPrint["edgesused: ", edgesused]; 

be=EdgesOnBoundary[T];
cvn = CellVertexNumbers[T]; 
PR=generateCelleratorOuterWallPressurePressureReactions[x,y,pressure,cells,cvn, edges,be,xy,vused,edgesused, opt];
vr=interpret[PR][[1]]/.ctr/.{pressure->1};
indices=Sort[VerticesOnBoundary[T]];
origins={x[#][gt],y[#][gt]}&/@indices/.Flatten[sim]/.{gt->time};
n=Length[indices];
directions=Partition[Last/@vr,n]//Transpose;
a=Graphics[MapThread[Arrow[{#1,#1+#2}]&,{origins,directions}]];
g=SimShow[sim,time,DT,opt];
Show[{g,a},MyFilterOptions[Graphics,opt]]];


(* ::Input::Initialization:: *)
ProcessVolumeCorrectionArrows[net_, growing_, cell_]:= Module[{ species,dbg=False, dPrint,arrow, rnew},
dPrint[u___]:= If[dbg, Print["ProcessVolumeCorrectionArrows: ", u]]; 

If[Not[growing], Return[{}]]; 
species=interpret[net][[2]]; 
dPrint["species: ", species]; 
arrow[var_]:= {var-> Global`\[EmptySet], -cell'[Global`t]/cell[Global`t]};
rnew = arrow/@species;
dPrint["rnew: ", rnew]; 
Return[rnew]; 
];


(* ::Input::Initialization:: *)
TransportQ[{X_\[LongRightArrow]X_,  Transport[u___]}]:= True;
TransportQ[u___]:= False; 
BadTransportQ[{X_\[LongRightArrow] Y_, Transport[u___]}]:= (ToString[X]!= ToString[Y]); 
BadTransportQ[X___]:= False; 

DiffusionReactionQ[{X_\[LongRightArrow] X_, Diffusion[u___]}]:= True; 
DiffusionReactionQ[X___]:= False; 
BadDiffusionQ[{X_\[LongRightArrow] Y_, Diffusion[u___]}]:= (ToString[X]!= ToString[Y]); 
BadDiffusionQ[{X_-> Y_, Diffusion[u___]}]:= True; 
BadDiffusionQ[X___]:= False; 



IGRNQ[{RightTeeArrow[X_, Y_], IGRN[Z___]}]:= True; 
IGRNQ[X___]:= False; 

IGRN2GRN[{RightTeeArrow[X_, Y_], IGRN[Z___]}]:= {RightTeeArrow[X, Y], GRN[Z]}
IGRN2GRN[X___]:= AbortIf[True, "IGRN2GRN: expecting an IGRN arrow, not: "<>ToString[InputForm[X]]]; 



SpringQ[Spring[X___]]:= True; 
SpringQ[X___]:= False; 
GrowthRateQ[GrowthRate[X___]]:= True;  
GrowthRateQ[X___]:= False; 
PressureQ[Pressure[X___]]:= True;
PressureQ[X___]:= False; 

ProcessCellzillaArrows[opt___?OptionQ]:= Module[{opt1, optt, net, onet, PR,PRQ,  dbg=False,PV,PA, dPrint, ArgReaction, SpeciesReaction, explicitPumps, DR, DRQ, DV, DA, explicitDR, IR, explicitIR, IRQ, GA, GAQ, ArgsGrow, kS, muS, pS,cell, GrowthQ, BadGrowthQ, BGQ, BG,cellq, notcellq, DivisionQ, DAQ, DivA, DivisionArgs, DivisionRule, divVar, divThreshold, divSigma, divWeight, arguments, SymbolQ, theDivaA, divRule, BadDivisionQ, BD, BDQ, BadD, BadT, VCA, VC},
dPrint[x___]:= If[dbg, Print["ProcessCellzillaArrows: ", x]]; 


SymbolQ[X_]:= (ToString[Head[X]]=="Symbol"); 

cell="CellVariable"/.{opt}/.{"CellVariable"-> Global`cell}; 

cellq[x_]:= (ToString[x]== ToString[cell]); 
notcellq[x_]:= (ToString[x]!= ToString[cell]);

arguments[f_[x___]]:= {x}; 

GrowthQ[{cell\[LongRightArrow]cell, Grow[Z___]}]:= True; 
GrowthQ[X___]:= False; 

BadGrowthQ[{X_?notcellq\[LongRightArrow]Y_?notcellq, Grow[Z___]}]:= True; 
BadGrowthQ[X___]:= False; 

DivisionQ[{cell\[LongRightArrow]cell+cell, ErreraRule[Z___]}]:= True;
DivisionQ[{cell\[LongRightArrow]cell+cell, Potential[Z___]}]:= True;
DivisionQ[{cell\[LongRightArrow]cell+cell, UnknownRule_[Z___]}]:= True;
DivisionQ[X___]:= False; 

BadDivisionQ[{cell\[LongRightArrow]cell+X_?notcellq,f_[Z___]}]:= True; 
BadDivisionQ[{Z_\[LongRightArrow]X_+Y_, f_[u___]}]:= (notcellq[X]\[Or]notcellq[Y]\[Or]notcellq[Z])\[And](cellq[X]\[Or]cellq[Y]\[Or]cellq[Z]); 
BadDivisionQ[{cell\[LongRightArrow]cell+ cell}]:= True; 
BadDivisionQ[Y___]:= False; 


DivisionArgs[{cell\[LongRightArrow]cell+cell, ErreraRule[Z___]}]:= ErreraRule[Z];
DivisionArgs[{cell\[LongRightArrow]cell+cell, Potential[Z___]}]:=Potential[Z]; 
DivisionArgs[Z___]:=AbortIf[True, "ProcessCellzillaArrows: DivisionArgs: Expecting {"<>ToString[cell]<>"\[LongRightArrow]"<>ToString[cell]<>"+"<>ToString[cell]<>", SomeValidRule[\[Ellipsis]]} and not "<>ToString[InputForm[Z]]]; 

DivisionRule[ErreraRule[X___]]:= "Errera"; 
DivisionRule[Potential[X___]]:= "Potential"; 
DivisionRule[Unknown___]:= AbortIf[True, "ProcessCellzillaArrows: Invalid Division Rule "<>ToString[Unknown]]; 



ArgReaction[{X_\[LongRightArrow] X_, Y_[Z___]}]:= Flatten[{Z}]; 
SpeciesReaction[{X_\[LongRightArrow]X_, Y_[Z___]}]:= X; 
ArgsGrow[{cell\[LongRightArrow]cell,Grow[Z___]}]:= {Z}; 
ArgsGrow[Z___]:= AbortIf[True, "ProcessCellzillaArrows: ArgsGrow: Expecting {"<>ToString[cell]<>"\[LongRightArrow]"<>ToString[cell]<>",Grow[\[Ellipsis]]} and not "<>ToString[InputForm[Z]]];

net = "Reactions"/.{opt}/.{"Reactions"-> {}}; 
onet = net; (* keep because of sorting *)

(* Extract Pump Reactions *)

PRQ = TransportQ/@net; 
PR = Pick[net, PRQ]; 
net = Complement[net, PR]; 
dPrint["Pump Reactions: ", PR]; 
dPrint["rest of network: ", net]; 
PV = SpeciesReaction/@PR;
PA = ArgReaction/@PR; 
dPrint["Pump Variables: ", PV]; 
dPrint["Pump Arguments: " ,PA]; 
PR = MapThread[Prepend[#1,#2]&, {PA, PV}]; 
dPrint["PR: ", PR]; 
explicitPumps="Pumps"/.{opt}/.{"Pumps"-> {}}; 
PR = Join[PR, explicitPumps]; 
dPrint["PR: ", PR]; 
optt = Select[{opt}, ToString[First[#]]!= "Pumps"&]; 

BadT = BadTransportQ/@onet;  
BadT = Pick[onet, BadT]; 

AbortIf[Length[BadT]>0,
"There are incorrectly formatted Transport Reactions, which must have the precise form {X\[LongRightArrow]X,Transport[\[Ellipsis]]}, with the same variable on both sides of the arrow, and not "<>ToString[InputForm[BadT]]
]; 

(* Extract Diffusion *)

DRQ = DiffusionReactionQ/@net; 
DR = Pick[net, DRQ]; 
net=Complement[net, DR];
DV = SpeciesReaction/@DR;
DA = ArgReaction/@DR; 
DR = MapThread[Prepend[#1,#2]&, {DA,DV}]; 
explicitDR = "Diffusion"/.{opt}/.{"Diffusion"-> {}}; 
DR=Join[DR, explicitDR]; 
optt = Select[optt, ToString[First[#]]!= "Diffusion"&]; 

BadD = BadDiffusionQ/@onet;  
BadD = Pick[onet, BadD]; 

AbortIf[Length[BadD]>0,
"There are incorrectly formatted Diffusion Reactions, which must have the precise form {X\[LongRightArrow]X,Diffusion[\[Ellipsis]]}, with the same variable on both sides of the arrow, and not "<>ToString[InputForm[BadD]]
]; 

(* Extract Intracellular GRN Arrows *)

IRQ = IGRNQ/@net; 
IR = Pick[net, IRQ]; 
net = Complement[net, IR]; 
IR = IGRN2GRN/@IR; 
explicitIR = "Intercellular"/.{opt}/.{"Intercellular"-> {}}; 
IR = Join[IR, explicitIR]; 
optt = Select[optt, ToString[First[#]]!= "Intercellular"&]; 

(* Extract any growth arrows from onet, but remove from net to keep ordering *)
GAQ = GrowthQ/@onet; 
GA = Pick[onet, GAQ]; 
net = Complement[net, GA]; 
GA = ArgsGrow/@GA; 
GA = Join@@GA; 

kS=Pick[GA, SpringQ/@GA]; 
If[Length[kS]>= 1, 
kS=First[kS]/.{Spring-> List},  
kS= "k"/.{opt}/.{"k"->Global`k}
]; 
optt = Select[optt, ToString[First[#]]!= "k"&]; 


muS = Pick[GA, GrowthRateQ/@GA]; 
If[Length[muS]>= 1, 
muS=First[muS]/.{GrowthRate-> List}, 
muS="mu"/.{opt}/.{"mu"-> Global`\[Mu]}
]; 
optt = Select[optt, ToString[First[#]]!= "mu"&]; 

pS = Pick[GA, PressureQ/@GA]; 
If[Length[pS]>= 1, 
pS=First[pS]/.{Pressure-> List},
pS="P"/.{opt}/.{"P"-> Global`P}
]; 
optt = Select[optt, ToString[First[#]]!= "P"&]; 


dPrint["kS= ", kS]; 
dPrint["muS= ", muS]; 
dPrint["pS=", pS]; 

(* Check for badly formatted Growth reactions *)
BGQ = BadGrowthQ/@onet;  
BG = Pick[onet, BGQ]; 

AbortIf[Length[BG]>0,
"There are incorrectly formatted Growth Reactions, which must only refer to the CellVariable \""<>ToString[cell]<>"\" in the reaction arrow, e.g.,  as {"<>ToString[cell]<>"\[LongRightArrow]"<>ToString[cell]<>",Grow[\[Ellipsis]]}, and not as "<>ToString[InputForm[BG]]
]; 

(* Pick out the Division Arrows*)
DAQ = DivisionQ/@onet; 
dPrint["DAQ: ", DAQ]; 
DivA = Pick[onet, DAQ]; 
If[Length[DivA]>0, theDivaA=First[DivA]]; 
net = Complement[net, DivA];

DivA=DivisionArgs/@DivA; 

(* get default values from options in case not specified, then reomve from options *)

divThreshold="DivisionThreshold"/.{opt}/.{"DivisionThreshold"-> Infinity}; 
optt = Select[optt, ToString[First[#]]!= "divThreshold"&]; 
divSigma="DivisionSigma"/.{opt}/.{"DivisionSigma"-> 0.1}; 
optt = Select[optt, ToString[First[#]]!= "divSigma"&]; 
divVar="DivisionVariable"/.{opt}/.{"DivisionVariable"-> cell}; 
optt = Select[optt, ToString[First[#]]!= "divVar"&]; 
divWeight="Weight"/.{opt}/.{"Weight"-> {1,1,1}}; 
optt = Select[optt, ToString[First[#]]!= "Weight"&]; 
divRule="DivisionModel"/.{opt}/.{"DivisionModel"-> "Errera"}; 
optt = Select[optt, ToString[First[#]]!= "DivisionModel"&]; 

(* extract division rule arguments *)
(* ErreraModel[variable, threshold, sigma] or *) 
(* Potential[variable, threshold, sigma, weightvector] *)

If[Length[DivA]>0,
DivA=DivA[[1]]; 
divRule = DivisionRule[DivA]; 
DivA=arguments[DivA]; 
If[Length[DivA]>0, 
divVar=DivA[[1]];
AbortIf[!SymbolQ[divVar], "Invalid Division Variable: "<>ToString[divVar]<>" requested in "<>ToString[InputForm[theDivaA]]];]; 
If[Length[DivA]>1, divThreshold=DivA[[2]]]; 
If[Length[DivA]>2,divSigma=DivA[[3]]];If[Length[DivA]>3, divWeight=Flatten[{DivA[[4]]}]];  
];

dPrint["Division Model: var: ", divVar, " threshold: ", divThreshold, " sigma: ", divSigma, " Weight: ", divWeight]; 

(* Look for most likely badly formatted cell division rules *)
(* Check for badly formatted Growth reactions *)
BDQ = BadDivisionQ/@onet;  
BD = Pick[onet, BDQ]; 

AbortIf[Length[BD]>0,
"There are incorrectly formatted Cell Division Reactions, which must only refer to the CellVariable \""<>ToString[cell]<>"\" in the reaction arrow, e.g.,  as {"<>ToString[cell]<>"\[LongRightArrow]"<>ToString[cell]<>"+"<>ToString[cell]<>",Grow[\[Ellipsis]]}, and not as "<>ToString[InputForm[BD]]
];




(* remove input reactions *)

optt = Select[optt, ToString[First[#]]!= "Reactions"&]; 

VC="VolumeCorrection"/.{optt}/.{"VolumeCorrection"-> True}; 

If[VC,
VCA= ProcessVolumeCorrectionArrows[
net, 
 ("Growing"/.{optt}/.{"Growing"-> False}),
cell]; 

net=Join[net, VCA]; 
];

opt1 = Flatten[{"Reactions"-> net, "Diffusion"-> DR, "Pumps"-> PR, "Intercellular"-> IR, 
"k"-> kS, "mu"-> muS, "P"-> pS, "DivisionModel"-> divRule, "DivisionThreshold"-> divThreshold, "DivisionSigma"-> divSigma, "DivisionVariable"-> divVar, "Weights"-> divWeight,
 optt}]; 

Return[opt1];
]


(* ::Input::Initialization:: *)
go[DT_?DTissueQ, network_,  tbegin_, tend_,opt___?OptionQ]:= Module[{s, equations, odes,vars,systemvars, event,sim,w,DTNOW, TF1,TF, lineage,edgelineage, dbg, IRH, dPrint, save,SaveODES, stepstring,simdir,memtrace,cpu0,MemPrint,OK,ic,parameters,initialRates,result, TF2,maxradius,eventequations,SaveEquations,eventIC,
dbgDivide, upwards,y,x,lhs, lhshead, rhs, found,n, LHS, RHS, UPONLY,variables, variable,meanradius,yvals,ybottom,i, newode,index, divisionthreshold, dump, growing, cell,okflag,mostrates, cellrates},

index[x_[j_]]:= j; 

meanradius = Sqrt[(1.0/Pi)*Mean[areafunction[DT]]];
yvals=#[[2]]&/@TissueVertices[DT]; 
ybottom = (#<.5*meanradius)&/@yvals;
ybottom=Pick[Range[Length[yvals]],ybottom];


growing = "Growing"/.{opt}/.{"Growing"-> False}; 
cell = "CellVariable"/.{opt}/.{"CellVariable"-> Global`cell}; 

UPONLY[x_]:= Max[x,0]; 
dbgDivide="DivideDebug"/.{opt}/.{"DivideDebug"-> False};
dbg = "GoDebug"/.{opt}/.{"GoDebug"-> False}; 
dPrint[u___]:= If[dbg, Print["go: ", u]]; 

memtrace="MemTrace"/.{opt}/.{"MemTrace"-> False}; 
cpu0="CPU0"/.{opt}/.{"CPU0"-> TimeUsed[]}; 
MemPrint[u___]:= If[memtrace, Print[MemoryInUse[]," ", MaxMemoryUsed[]," ",TimeUsed[]-cpu0," ", u]]; 

ic = "IC"/.{opt}/.{"IC"-> {}};
equations="Equations"/.{opt}/.{"Equations"-> {}};
w="Weights"/.{opt}/.{"Weights"-> {1,1,1}};

$$REACTIONS = network;

dPrint["Interpreting."]; 
{odes, vars}=interpret[network]; 
MemPrint["interpret"]; 
upwards = "Upwards"/.{opt}/.{"Upwards"-> False}; 

y=ToString["y"/.{opt}]; 
x=ToString["x"/.{opt}]; 
If[upwards,
(* dPrint["***** upwards *****"]; *)
lhs = First/@odes;
lhshead = Head[First[#]]&/@((Head/@lhs)/.{Derivative[1]-> List}); 


found = Equal[ToString[#], y]&/@lhshead;

variables = First/@((Head/@lhs)/.{Derivative[1]-> List}); 
(* dPrint["go: variables: ", variables]; *)

rhs = Last/@odes;

(* dPrint["go: lhs: ", lhs];
dPrint["go: lhshead: ", lhshead]; 
dPrint["go: found: ", found]; 
dPrint["go: rhs: ", rhs]; *) 

n=Length[odes];
(* rebuild ODES to use wrapper if necessary*)
odes={}; 
For[i=1,i<= n, i++, 
LHS=lhs[[i]];
RHS=rhs[[i]];
variable = variables[[i]]; 

(* If the variable is "y" force upwards movement *)
If[found[[i]],
(* if its on the bottom row, make sure it stays fixed *)
If[MemberQ[ybottom, index[variable]],
RHS = 0.0, 
(*otherwise, force upwards *)
RHS=UPONLY[RHS] 
];

]; 

newode = Equal[LHS, RHS]; 
odes = Append[odes, Equal[LHS, RHS]]; 

]; 
 (* Print["go: revised odes: ", odes]; *)

];
parameters="Parameters"/.{opt}/.{"Parameters"-> {}};
dPrint["Checking ICs"]; 
OK = HasSufficientInfo[odes,vars,equations,ic,parameters, growing, x, y, cell, False];
 
{okflag, initialRates}=OK; 

MemPrint["Checking ICs"];
 
If[Not[okflag], 
Print/@HasSufficientInfo[odes,vars,equations,ic,parameters,growing, x, y, cell, True];
Print["Simulation Error at t = ", tbegin]; 
Abort[]; 
];


save = "Save"/.{opt}/.{"Save"-> True};
dump = "Dump"/.{opt}/.{"Dump"-> True}; 
dump = dump \[And] save; 
SaveODES="SaveODES"/.{opt}/.{"SaveODES"-> False}; 
SaveEquations="SaveEquations"/.{opt}/.{"SaveEquations"-> False}; 

systemvars = Join[vars, Head/@First/@equations];
{event,eventequations, eventIC} = setDivision[systemvars, DT, opt];
dbgDivide="DivideDebug"/.{opt}/.{"DivideDebug"-> True};

divisionthreshold = "DivisionThreshold"/.{opt}/.{"DivisionThreshold"-> \[Infinity]};
If[divisionthreshold<Infinity,
equations=Join[ eventequations, equations];
If[dbgDivide,equations=Join[{(Global`DivisionEventFlag[Global`t]==event)}, equations]];
]; 


Block[{eventic,eific, funcinate,icrules},
funcinate[x_]:= x[Global`t]; 
icrules = (funcinate[#[[1]]]-> #[[2]])&/@Join[eventIC,ic]; 
eventic = event/.icrules;
If[Abs[divisionthreshold]<Infinity,
ic=Join[eventIC, ic];
If[dbgDivide,ic = Prepend[ic,Global`DivisionEventFlag-> eventic]]; 
];
]; 

dPrint["Division event set to: ", event]; 
MemPrint["SetDivision"];


If[save ,
stepstring="StepString"/.{opt}/."StepString"-> "";
simdir = "SimDir"/.{opt}/."SimDir"-> Directory[]; 
If[SaveODES,
MemPrint["Saving ODEs"]; 
$ODEFILE = UniqueFileName[simdir,"ODES"<>stepstring,"nb"]; 
SaveFile[$ODEFILE,ToString[InputForm[odes]]];
]; 

If[SaveEquations,
MemPrint["Saving Equations"]; 
$EQNFILE=UniqueFileName[simdir,"Equations"<>stepstring,"nb"];
SaveFile[$EQNFILE,equations]];

MemPrint["Saving ICs"]; 
$ICFILE=UniqueFileName[simdir,"IC"<>stepstring,"nb"];
SaveFile[$ICFILE,ic];

]; 



dPrint["Solving."]; 
event = event + Abs[\[CapitalPsi][Global`t-tend]];

$$SYSTEM={odes,vars}; 
$$IC=ic;
$$RATES=initialRates/.{Global`t-> tbegin};

$$EQUATIONS=equations; 
If[Length[equations]==0, initialRates={}]; 
s=run[{odes,vars}, 
"Equations"-> equations, 
"IC"-> ic, 
MaxSteps-> Infinity, 
opt, "TimeSpan"-> {tbegin,tend}, 
"InitialRates"-> $$RATES,
Method-> { "EventLocator",  "Event"-> event, "Direction"-> 1}];
s=Flatten[s]; 
MemPrint["run"]; 
 

dPrint["IRH."]; 

IRH = identifyReasonForHalt[s,DT, eventequations, tend, opt]; 
sim = Append[IRH,"Solution"-> s]; 
MemPrint["IRH"]; 

dPrint["Reason for halt: ", IRH];

TF1=performAllNecessaryCellDivisions[sim,DT,opt];
MemPrint["CellDivision"]; 

result = Join[sim,TF1];
dPrint["*** GO: Tissue (TF1): ", "Tissue"/.TF1]; 

maxradius = "MaxRadius"/.{opt}/.{"MaxRadius"-> \[Infinity]};
If[ maxradius< \[Infinity], 
dPrint["Checking for Outliers."]; 
TF2= ExpungeOutliers[result,opt]; 
If[Length[TF2[[3]]]<1,
Print[Style["Error: All cells have been classified as outliers and removed from the tissue at t="<>ToString[Last["TimeSpan"/.IRH]],Red,Bold]
]; 
];

dPrint["*** GO: Tissue (TF2): ", TF2]; 

result = Select[result, First[#]!= "Tissue"&]; 
result = Prepend[result, "Tissue"-> TF2]; 
]; 

Return[result]
];


(* ::Input::Initialization:: *)
ExpungeOutliers[sim_,opt___?OptionQ]:=Module[{s,dbg,rmax,dPrint, T,bcells,cvc,TC,d, droppers, TNew,D2S,nstatic,cnums,staticbcells, origin},
dbg = False;
dPrint[u___]:= If[dbg, Print["DropOutlyingCells: ", u]]; 

rmax = "MaxRadius"/.{opt}/.{"MaxRadius"-> \[Infinity]}; 
origin = "Origin"/.{opt}/.{"Origin"-> {0.0,0.0}}; 

dPrint["rmax=", rmax]; 
T="Tissue"/.sim; 
cnums = First/@TissueCells[T]; 
nstatic=Range[Length[cnums]]; 
D2S=MapThread[Rule,{cnums,nstatic}]; 
bcells = CellsOnBoundary[T]; 
dPrint["Boundary Cells: ", bcells]; 
staticbcells=bcells/.D2S;
dPrint["Static Boundary Cells: ", staticbcells];
cvc = (CellVertexCoordinates[T])[[staticbcells]];
If[ToString[origin]=="Centroid", 
TC = TissueCentroid[DTissue2Tissue[T]],
TC=origin
]; 
dPrint["TC: ", TC]; 
TNew  = T; 


Block[{cells, cell,voutlier,outliers, outlier, cellnumber, coordinates},
cells=MapThread[Rule,{bcells,cvc}]; 
dPrint["cells: ", Short[cvc,5]]; 
(* figure out which cells poke out the boundary *) 
outliers={}; 
While[Length[cells]>0,
cell=First[cells]; cells=Rest[cells]; 
coordinates = Last[cell]; cellnumber=First[cell]; 
voutlier= (distance[#,TC]>rmax)&/@coordinates; (* dPrint["cell: ", cellnumber, " voutlier: ", voutlier];*)  
If[And@@voutlier, AppendTo[outliers, cellnumber]]; 
];
dPrint["outliers: ", outliers]; 
droppers = outliers;

]; 

TNew = T; 

(* drop required cells *)

If[Length[droppers]>=Length[TNew[[3]]],
Print[Style["Error: All cells have been classified as outliers and removed from the tissue.",Red,Bold]
]; 
]; 


While[Length[droppers]>0, 
d=First[droppers]; droppers=Rest[droppers]; 
TNew=DeleteCell[TNew,d]; 
]; 

Return[TNew];

];


(* ::Input::Initialization:: *)
grow[DT1_?DTissueQ,tstart_, tend_, options___?OptionQ]:= Module[{Network,Equations,ell,area,restlength,k,mu,P, IC,x,y, extension,rmin,rmax,OK,parameters,S,DT,weights, DivThresh,DivSigma,DivVar,ThreshVar,Rates, BC, internal,save,simdir,tdir,stepcounter,stepstring,stepdigits=4, show,showoptions,species,done,tbegin,initial,MinAngleSpread,dbg, dPrint,maxdivs,ndivs,lineage,edgeLineage,ne,cpu0,memtrace,MemPrint, haswalls, tstopped,maxradius, DTOLD,origin,Virtual,MaxMemAllowed, SaveEquations, SaveODES, SaveNet,continuation, continuationnote, GB,TestCase,snapshot, IgnoreDivisionBeyondThisRadius, divisionModel, IsotropicGrowth, IsotropicSprings, L1Anticlinal, L2Anticlinal,L2AnticlinalRatio, tip,center,perim,tipdist, growing, L1, L2, TIPF, opt, xy,dump, PD},

GB=1024.0*1024.0*1024.0;
cpu0=TimeUsed[]; 

opt = Sequence@@ProcessCellzillaArrows[options]; 

dPrint[{opt}];



dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
$DebugHasSufficientInfo="DebugHasSufficientInfo"/.{opt}/.{"DebugHasSufficientInfo"-> False}; 
dPrint[u___]:= If[dbg, Print["grow: ", u]]; 
memtrace="MemTrace"/.{opt}/.{"MemTrace"-> False}; 
MemPrint[u___]:= If[memtrace, Print[MemoryInUse[]," ", MaxMemoryUsed[]," ",TimeUsed[]-cpu0," ", u]]; 

(* override any default values further downstream! *)
IsotropicGrowth="IsotropicGrowth"/.{opt}/.{"IsotropicGrowth"-> True}; 
IsotropicSprings="IsotropicSprings"/.{opt}/.{"IsotropicSprings"-> True}; 


haswalls = "Walls"/.{opt}/.{"Walls"-> False}; 
internal="Internal"/.{opt}/.{"Internal"-> False}; 
save = "Save"/.{opt}/.{"Save"-> True};
dump="Dump"/.{opt}/.{"Dump"-> True};
dump = dump \[And] save;   
SaveEquations="SaveEquations"/.{opt}/.{"SaveEquations"-> False}; 
SaveODES="SaveODES"/.{opt}/.{"SaveODES"-> False}; 
SaveNet="SaveNet"/.{opt}/.{"SaveNet"-> True}; 
show = "Show"/.{opt}/.{"Show"-> True};
showoptions = "ShowOptions"/.{opt}/.{"ShowOptions"-> {Frame-> True, "CellNumbers"-> True, ImageSize-> 200, "EdgeNumbers"-> False}}; 
maxdivs = "MaxDivisions"/.{opt}/.{"MaxDivisions"-> \[Infinity]};
ndivs = 0; 
maxradius="MaxRadius"/.{opt}/.{"MaxRadius"-> \[Infinity]}; 
continuationnote = "Continuation"/.{opt}/.{"Continuation"-> ""}; 
continuation = StringLength[continuationnote]>0; 
TestCase="TestCase"/.{opt}/.{"TestCase"-> "Growzilla"}; 
TestCase=ToString[TestCase]<>"-"; 
growing = "Growing"/.{opt}/.{"Growing"-> True}; 

dPrint["Initializing."]; 

lineage = Rule[0,#]&/@(First/@TissueCells[DT1]);
ne=NTissueEdges[DT1]; 
edgeLineage = Rule[0,#]&/@Range[ne]; 

initialize$olutions[];

If[internal, 
save=False, save=True];
stepcounter=1; 
If[save, 
CellzillaHome=CreateHomeFolder[]; 
tdir = createTodaysFolder[ToFileName[CellzillaHome,"Simulations-"]];
simdir=createUniqueFolder[ToFileName[tdir,TestCase]];
$SIMDIR = simdir; 
Print["simdir = ", simdir]; 
stepcounter = "StepCounter"/.{opt}/.{"StepCounter"-> 1}; 
stepstring = IntegerString[stepcounter,10,stepdigits]; 

$TISSUEFILE=UniqueFileName[simdir,"DTissue"<>stepstring,"nb"]; 

SaveFile[$TISSUEFILE,ToString[InputForm[DT1]]];
$OPTIONFILE=UniqueFileName[simdir,"Simulation-Options","nb"];
SaveFile[$OPTIONFILE,{opt}]; 
If[continuation,
SaveFile[UniqueFileName[simdir,"continuation", "txt"], continuationnote];
]; 
]; 
dPrint["Getting options."]; 
ell = "EdgeVariable"/.{opt}/.{"EdgeVariable"-> Global`ell}; 
area = "CellVariable"/.{opt}/.{"CellVariable"-> Global`cell}; 
restlength="Restlength"/.{opt}/.{"Restlength"-> Global`resting}; 
IC = "IC"/.{opt}/.{"IC"-> {}}; 
k = "k"/.{opt}/.{"k"-> Global`k}; 
mu = "mu"/.{opt}/.{"mu"-> Global`\[Mu]}; 
P = "P"/.{opt}/.{"P"-> Global`P}; 
xy = "xy"/.{opt}/.{"xy"-> True}; 
x = "x"/.{opt}/.{"x"-> Global`x}; 
y="y"/.{opt}/.{"y"-> Global`y}; 
If[!xy, x=y=False]; 

tip="tip"/.{opt}/.{"tip"-> Global`tip}; 
center="center"/.{opt}/.{"center"-> False}; 
perim="perimeter"/.{opt}/.{"perimeter"-> False}; 
tipdist = "tipDistance"/.{opt}/.{"tipDistance"-> False}; 

extension = "extension"/.{opt}/.{"extension"-> 1.0}; 
rmin = "RandomMin"/.{opt}/.{"RandomMin"-> 0.0}; 
rmax = "RandomMax"/.{opt}/.{"RandomMax"-> 0.05}; 
weights = "Weights"/.{opt}/.{"Weights"-> {1.,1.,1., 0.}}; 
divisionModel="DivisionModel"/.{opt}/.{"DivisionModel"-> "Potential"}; 
DivThresh = "DivisionThreshold"/.{opt}/.{"DivisionThreshold"-> \[Infinity]};
DivSigma="DivisionSigma"/.{opt}/.{"DivisionSigma"-> 0.1}; 
DivSigma=DivSigma*DivThresh;
L1Anticlinal = "L1Anticlinal"/.{opt}/.{"L1Anticlinal"-> True};
L2Anticlinal = "L2Anticlinal"/.{opt}/.{"L2Anticlinal"-> False};
L2AnticlinalRatio= "L2AnticlinalRatio"/.{opt}/.{"L2AnticlinalRatio"-> 1.0*GoldenRatio};
PD = "PrincipalDirection"/.{opt}/.{"PrincipalDirection"-> False}; 

 
L1 ="L1"/.{opt}/.{"L1"-> False}; 
L2= "L2"/.{opt}/.{"L2"-> False}; 
TIPF="TipFlag"/.{opt}/.{"TipFlag"-> False}; 



IgnoreDivisionBeyondThisRadius="IgnoreDivisionRadius"/.{opt}/.{"IgnoreDivisionRadius"-> \[Infinity]}; 
 
DivVar = "DivisionVariable"/.{opt}/.{"DivisionVariable"->area}; 
ThreshVar="DivisionThresholdVariable"/.{opt}/.{"DivisionThresholdVariable"-> Global`CellDivisionThreshold};
$DivisionThresholds={}; 
BC = "BoundaryConditions"/.{opt}/.{"BoundaryConditions"-> {}}; 


MinAngleSpread="MinAngleSpread"/.{opt}/.{"MinAngleSpread"-> 135.0};   
dPrint["MinAngleSpread: ", MinAngleSpread]; 
origin= "Origin"/.{opt}/.{"Origin"-> {0.0,0.0}}; 
Virtual = "Virtual"/.{opt}/.{"Virtual"-> False}; 
MaxMemAllowed = "MaxMemAllowed"/.{opt}/.{"MaxMemAllowed"-> .9}; 
MaxMemAllowed=Max[Min[MaxMemAllowed,1.0],0.0]; 

parameters ="Parameters"/.{opt}/.{"Parameters"-> {}}; 

DT = DT1;
tbegin=tstart;
initial = True; 
done=False; 
MemPrint["Getting options"]; 
dPrint["Starting While loop."]; 



If[show,
snapshot=ShowTissue[DT,PlotLabel-> "Initial Tissue", Sequence@@showoptions, "CellNumbers"-> True,"EdgeStyles"-> Brown, PlotRange-> All, Frame-> True];

If[save, 
$SNAPSHOTFILE=UniqueFileName[simdir,"Snapshot"<>stepstring,"png"];
Export[$SNAPSHOTFILE,snapshot]; 
Print["Tissue snapshot written to ", $SNAPSHOTFILE]; 
]; 
Print[
TableForm[{
{"Actual Clock Time: ", now[]}, 
{"Memory in Use (GB): ", MemoryInUse[]/GB},
{"Max Memory Used (GB): ", MaxMemoryUsed[]/GB},
{"Free Memory (GB): ", MemoryFree[]/GB}
}]]; 
]; 

While[Not[done], 
$Tissue=DT; 

dPrint["Generating Network."]; 
dPrint["haswalls=", haswalls]; 
If[haswalls,
{Network, Equations}=WalledNetwork[DT,"EdgeVariable"-> ell, "CellVariable"-> area,"Restlength"-> restlength,"k"-> k,  "mu"-> mu,"P"-> P,"x"-> x, "y"-> y, opt]; ,
{Network, Equations}=UnwalledNetwork[DT,"EdgeVariable"-> ell, "CellVariable"-> area,"Restlength"-> restlength,"k"-> k,  "mu"-> mu,"P"-> P,"x"-> x, "y"-> y, opt]; 
]; 
dPrint["newtwork:", Short[Network,5]]; 

MemPrint["Generating Network."]; 

If[save,
If[SaveNet,
$NETFILE=UniqueFileName[simdir,"Network"<>stepstring,"nb"];
SaveFile[$NETFILE,Network]];

];
MemPrint["Saving Network & Equations."]; 


dPrint["Generaing ICs"]; 


If[initial,
IC = SetRandomizedIC[IC, DT,Network, Equations,  ell,area,restlength,x,y,extension,rmin,rmax, IsotropicGrowth, mu, IsotropicSprings, k, tip,center,tipdist,perim, P, growing, L1, L2, TIPF, PD, parameters];
initial=False;
,
IC=SetNextIC[DT,DTOLD, S,Network,Equations,  ell,area,restlength,x,y, IsotropicGrowth, mu, IsotropicSprings,k, tip,center,tipdist, perim,P, L1,L2,TIPF, PD, parameters, "ICDebug"/.{opt}/.{"ICDebug"-> False}];
];
MemPrint["Generating ICs"]; 


dPrint["Running simulation."]; 

S = go[DT, Network,tbegin,tend,"Lineage"-> lineage,"EdgeLineage"-> edgeLineage,  "IC"-> IC,"Parameters"-> parameters, "Equations"-> Equations, 
"DivisionModel"-> divisionModel,
"L1Anticlinal"->  L1Anticlinal, 
"L2Anticlinal"-> L2Anticlinal,
"L2AnticlinalRatio"-> L2AnticlinalRatio,
"Weights"-> weights, "DivisionThreshold"-> DivThresh,
"DivisionSigma"-> DivSigma,
"IgnoreDivisionRadius"-> IgnoreDivisionBeyondThisRadius, 
"DivisionVariable"-> DivVar,
"DivisionThresholdVariable"-> ThreshVar,
"MinAngleSpread"-> MinAngleSpread, "Save"-> save,"Dump"-> dump,  "StepString"-> stepstring,"SimDir"-> simdir, "GoDebug"-> dbg, "DivideDebug"-> ("DivideDebug"/.{opt}), "MemTrace"-> memtrace, "CPU0"-> cpu0,"EdgeVariable"-> ell,"CellVariable"-> area, "MaxRadius"-> maxradius, "Origin"-> origin, "SaveODES"-> SaveODES,
"SaveEquations"-> SaveEquations,
"Upwards"-> ("Upwards"/.{opt}/.{"Upwards"-> False}),
"x"-> x, "y"-> y, "Growing"-> growing]; 
MemPrint["Simulation"]; 

dPrint["Saving results."]; 
Block[{TNext,t1,t2,TheseTimes,n,div,divl,colors,dynamicc,staticc,dynamnic2Static,MostRecentChild,nvars},
TNext = "Tissue"/.S; 
Global`$$SOLUTION = "Solution"/.S;

nvars = Length[Global`$$SOLUTION]; 
TheseTimes = "TimeSpan"/.S;
{t1,t2}=TheseTimes; 
$TimeSpans = Append[$TimeSpans,{t1,t2}]; 
lineage = "Lineage"/.S;
edgeLineage="EdgeLineage"/.S; 
If[save , (* don't save end of static simulation if x&y turned off!! *)
If[dump,
$SOLUTIONFILE=UniqueFileName[simdir,"Solution"<>stepstring,"mx"];
DumpSave[$SOLUTIONFILE,Global`$$SOLUTION];
,
$SOLUTIONFILE=UniqueFileName[simdir,"Solution"<>stepstring,"nb"];
SaveFile[$SOLUTIONFILE,Global`$$SOLUTION];
];
$LINEAGEFILE=ToFileName[simdir,"Lineage.nb"];
SaveFile[$LINEAGEFILE,lineage];
$EDGELINEAGEFILE=ToFileName[simdir,"EdgeLineage.nb"];
SaveFile[$EDGELINEAGEFILE,edgeLineage];
$TIMESPANFILE=ToFileName[simdir,"TimeSpans.nb"];
SaveFile[$TIMESPANFILE, $TimeSpans]; 
stepcounter = stepcounter+1;
stepstring = IntegerString[stepcounter,10,stepdigits]; 
If[xy, $TISSUEFILE = UniqueFileName[simdir,"DTissue"<>stepstring,"nb"];
SaveFile[$TISSUEFILE,ToString[InputForm[TNext]]]
];
];
MemPrint["Saving Files"];
ndivs = ndivs + Length[ "Divide"/.S/.{"Divide"-> {}}]; 
 

dPrint["**** tissue: ", TNext]; 

If[show,
n=NTissueCells[TNext]; 
div = "Divide"/.S/.{"Divide"-> {}};

(* In Most Cases the following will be the same as Reverse[lineage] *)
(* But not if the numbers are out of order *)

MostRecentChild=Reverse/@Reverse[Sort[Reverse/@lineage]];
divl = div/.MostRecentChild; 
div = Join[div,divl]; 
dynamicc=First/@TissueCells[TNext];
colors=If[MemberQ[div,#],{LightPink},{LightGreen}]&/@dynamicc;snapshot=ShowTissue[TNext,PlotLabel-> ToString[InputForm[t2]],"CellStyles"-> colors, Sequence@@showoptions, "CellNumbers"-> True,"EdgeStyles"-> Brown];

If[xy,
If[save, 
$SNAPSHOTFILE=UniqueFileName[simdir,"Snapshot"<>stepstring,"png"];
Export[$SNAPSHOTFILE,snapshot]; 
Print["Tissue snapshot written to ", $SNAPSHOTFILE]; 
,
If[show,Print[snapshot]]
]; 
]; 

Print[
TableForm[{
{"Actual Clock Time: ", now[]}, 
{"Memory in Use (GB): ", MemoryInUse[]/GB},
{"Max Memory Used (GB): ", MaxMemoryUsed[]/GB},
{"Free Memory (GB): ", MemoryFree[]/GB}, 
{"CPU Used(seconds): ", TimeUsed[]-cpu0}, 
{"Number of Cells: ", n},
{"Cell Divisions: ", ndivs}, 
{"Simulator Steps: ", stepcounter}, 
{"Number of Variables: ", nvars}}]]; 
]; 

tbegin = t2;
If[tbegin>= tend,done=True]; 
If[ndivs>= maxdivs, done=True]; 

If[done \[And] xy\[And]show, Print[snapshot]]; 

If[Not[Virtual],
If[MemoryInUse[]>MaxMemAllowed*MemoryInstalled[],Print["Usage exceeds ", Round[MaxMemAllowed*100.0],  " percent of installed memory. Set flag \"Virtual\"\[Rule]True to allow use of virual memory (will run much more slowly) or the parameter \"MaxMemAllowed\" to a number between 0 and 1 to allow use of more memory. "]; 
done=True]
];

DTOLD = DT; 
DT = TNext;
If[done, tstopped=t2]; 

If[memtrace ,
Print[TableForm[MemTable["Cellzilla2D`Private`",10000]]];
Print[TableForm[MemTable["xlr8r`Private`",10000]]]; 
];

]; (* End Block *)

]; (* End While[Not[done]... *)

MemPrint["End of Run."]; 
Print["Simulation Completed at t = ", tstopped," after ", ndivs," cell divisions; Normal Exit. CPU: ", (TimeUsed[]-cpu0)];  
If[Not[internal], 
Return[simdir];
]; 
Return["Solution"/.S]
];




(* ::Input::Initialization:: *)
grow[opt___?OptionQ]:= Module[{GetTimeDomainFromFile, d, TFiles,nT,SFiles, dPrint, dbg, nS,nN,  n, NFiles, TSFile, tended, tstart, tend, oldopts, options, DT, DTOLD, S, Network, ell, area, x, y,restlength,IC, thetimespan,sim, lineage, edgelineage,cells, edges,note},

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[u___]:= If[dbg, Print["grow (continuation):", u]]; 

GetTimeDomainFromFile[f_]:= CommonTimeDomain[Get[f]]; 
tend = "Tend"/.{opt}/.{"Tend"-> \[Infinity]}; 

d=SystemDialogInput["Directory", ToFileName[HomeDirectory[]], WindowTitle-> "Please select the folder that contains the results of the previous part of the simulation, e.g., the DTissue*.nb, Solution*.nb, IC*.nb, TimeSpans.nb, Simulation-Options.nb):"];
dPrint["d: ", d]; 

Print["Initializing continuation mode. Reading files from " <>d]; 


TFiles = FileNames[ToFileName[d,"DTissue*.nb"]];
nT=Length[TFiles]; 
SFiles=FileNames[ToFileName[d,"Solution*.nb"]]; 
dPrint["SFiles:", Short[SFiles,5]]; 
nS=Length[SFiles]; 
NFiles = FileNames[ToFileName[d, "Network*.nb"]]; 
nN=Length[NFiles]; 
dPrint["nT,nS, nN:", {nT, nS, nN}]; 
If[nT==0, Print["No Tissues found in "<>d]; Return[{}]]; 
If[nS==0, Print["No Simulation results found in "<>d]; Return[{}]]; 
If[nN==0, Print["No Network files found in "<>d]; Return[{}]]; 

n=Min[{nT,nS, nN}]; 
dPrint["n: ", n, " simulation sets."]; 

TSFile = FileNames[ToFileName[d,"TimeSpans.nb"]]; 
If[Length[TSFile]>0, 

TSFile=First[TSFile];
thetimespan = Last[Get[TSFile]]; 
tended = thetimespan[[2]]; 
,
Print["File "<>ToFileName[d,"TimeSpans.nb"]<>"Attempting to determine timespan manually from file set ", n]; 
thetimespan=GetTimeDomainFromFile[SFiles[[i]]];
tended = thetimespan[[2]]; 
];
tstart = tended; 

dPrint["{start, tend}: ", {tstart, tend}]; 

oldopts = getOldSimFile[d, "Simulation-Options.nb"]; 
oldopts=Flatten[{oldopts}];  
options = Join[{opt}, oldopts]; 
dPrint["options:", options]; 



(* Calculate parameter "IC" from solution*)

If[n<2, Print["There must be at least two tissues to run in continuation mode."]; Return[{}]]; 

DT = ToExpression[Get[TFiles[[n]]]]; 
dPrint["DT: ", ShowTissue[DT]]; 
lineage = getOldSimFile[d, "Lineage.nb"]; 
If[lineage =={}, 
cells = First/@TissueCells[DT]; 
lineage = (Rule[0,#]&/@cells);
]; 
dPrint["lineage: ", Short[lineage,3]]; 

edgelineage = getOldSimFile[d, "EdgeLineage.nb"]; 
If[edgelineage=={},
edges = Range[NTissueEdges[DT]]; 
edgelineage = (Rule[0,#]&/@edges); 
];

dPrint["edgelineage: ", Short[edgelineage, 3]]; 



DTOLD=ToExpression[Get[TFiles[[n-1]]]]; 
dPrint["DTOLD: ", ShowTissue[DTOLD]]; 
S = Get[SFiles[[n]]]; 
dPrint["S: ", Short[S, 5]]; 
Network =Get[NFiles[[n]]]; 

dPrint["Network: ", Short[Network,5]]; 

ell = "EdgeVariable"/.oldopts/.{"EdgeVariable"-> Global`ell}; 
area = "CellVariable"/.oldopts/.{"CellVariable"-> Global`cell}; 
restlength="Restlength"/.oldopts/.{"Restlength"-> Global`resting}; 
x = "x"/.oldopts/.{"x"-> Global`x}; 
y="y"/.oldopts/.{"y"-> Global`y}; 

sim = {"TimeSpan"-> thetimespan, "Lineage"-> lineage, "EdgeLineage"-> edgelineage, "Solution"-> S}; 

IC=SetNextIC[DT,DTOLD, sim,Network,ell,area,restlength,x,y, "ICDebug"/.options/.{"ICDebug"-> False}];

options = Select[options, (First[#]!= "IC")&]; 

dPrint["IC: ", Short[IC,5]]; 

Print["Continuation mode successfully initialized."]; 

note = "This is a continuation of "<>d; 
grow[DT, tstart, tend,"StepCounter"-> (n+1), "IC"-> IC, "Continuation"-> note, Sequence@@options]
];

getOldSimFile[dir_,filename_]:= Module[{handle,result},
handle = FileNames[ToFileName[dir,filename]];
result={}; 
If[Length[handle]>0, 
handle=First[handle]; 
result = Get[handle],

Print["Waring: No previous file "<>filename<>" was found."]; 
];
Return[result]
]


(* ::Input::Initialization:: *)
grow[somethingElse___]:= (Print["Unexpected Input to grow."];Abort[]; );


(* ::Input::Initialization:: *)
SaveFile[filename_, object_]:= Module[{symbol,f},
f=filename;
symbol=object;
Save[filename,symbol]];


(* ::Input::Initialization:: *)
MemTable[context_,xmin_]:=Module[{names, sizes},
names=Names[context<>"*"];
sizes=ByteCount/@ToExpression/@names;Select[Transpose[{sizes,names}],#[[1]]>xmin&]//Sort//Reverse
]


(* ::Input::Initialization:: *)
initialize$olutions[]:= Module[{},
$Tissues={};
$Solutions={};
$Networks = {};
$Lineage={};
$EdgeLineage={}; 
$TimeSpans={}; 
]


(* ::Input::Initialization:: *)
identifyReasonForHalt[s_, DT_,eventequations_,normalstop_,   opt___?OptionQ]:= Module[{divisionthreshold, divisionvariable,ss, tstop,vals,vars,readyToDivide, ctd, IgnoreDivisionBeyondThisRadius, dPrint,ThreshVar,dbg=False, threshvars,threshvals, index, varrules,threshrules, test},
dPrint[x___]:= If[dbg, Print["identifyReasonForHalt: ", x]]; 
index[x_[i_]]:= i; 

(* normalstop =Last[Flatten[{ xlr8r`timeSpan/.{opt}}]]; *)

dPrint["eventequations: ", eventequations]; 



(* check for division *)
divisionthreshold = "DivisionThreshold"/.{opt}/.{"DivisionThreshold"-> \[Infinity]};
dPrint["divisionthreshold: ", divisionthreshold]; 
divisionvariable="DivisionVariable"/.{opt}/.{"DivisionVariable"-> "Unknown"};
IgnoreDivisionBeyondThisRadius="IgnoreDivisionRadius"/.{opt}/.{"IgnoreDivisionRadius"-> \[Infinity]};
ThreshVar="DivisionThresholdVariable"/.{opt}/.{"DivisionThresholdVariable"-> "Unknown"}; 



ctd = CommonTimeDomain[s];
tstop=Last[ctd];
vals= Select[Flatten[s],Head[First[#]]==divisionvariable&];
vars = First/@vals;
vals = #[tstop]&/@Last/@vals;
varrules = MapThread[Rule, {index/@vars, vals}]; 
dPrint["vars: ", vars];
dPrint["vals: ", vals]; 
dPrint["varrules: ", varrules]; 

threshvals= Select[Flatten[s],Head[First[#]]==ThreshVar&];
threshvars = First/@threshvals;
threshvals = #[tstop]&/@Last/@threshvals;
threshrules=MapThread[Rule, {index/@threshvars, threshvals}]; 

dPrint["threshvars: ", threshvars];
dPrint["threshvals: ", threshvals]; 
dPrint["threshrules: ", threshrules]; 

readyToDivide={};
If[divisionthreshold<Infinity,
test=MapThread[Rule[First[#1], {First[#1]/.#2, First[#1]/.#1}]&,{threshrules, varrules}]; 
dPrint["test: ", test]; 
test=Rule[#[[1]], GreaterEqual@@#[[2]]]&/@test;
If[Length[test]>0, 
test=Transpose[test/.{Rule-> List}];
dPrint["test: ", test]; 
readyToDivide=Pick@@test;
]; 
]; 
dPrint["readyToDivide (1): ", readyToDivide]; 


If[IgnoreDivisionBeyondThisRadius < \[Infinity], 
Block[{Origin, centroids, radii, divisible,cellnumbers}, 
Origin =  "Origin"/.{opt};
(* Use Centeroid because its faster, and in bizzare cases we could get Folding which gives wrong answer with Centroid *)
centroids=Centeroid[DT];
centroids = (#-Origin)&/@centroids; 
radii = Norm/@centroids;
dPrint["radii: ", radii]; 
divisible = (#<IgnoreDivisionBeyondThisRadius)&/@radii ; 
cellnumbers = First/@TissueCells[DT]; 
divisible=Pick[cellnumbers,divisible];
readyToDivide=Select[readyToDivide, MemberQ[divisible,#]&];
dPrint["readyToDivide (2): ", readyToDivide]; 
]; 


]; 

dPrint["Finished: ", (tstop >= normalstop)]; 

Return[{
"Divide"-> readyToDivide,
"TimeSpan"-> ctd,
"Finished"-> (tstop >= normalstop)
}]; 
]


(* ::Input::Initialization:: *)
setDivision[allvars_, DT_, opt___?OptionQ]:= Module[{divisionthreshold,divisionvariable,vars,div,smallarea, IgnoreDivisionBeyondThisRadius,centroids, Origin, radii, cellnumbers,divisible,dPrint, sigma,thresholds,  dbg=False, dbgDivide, index,indices,heads, ThreshVar,threshequations,thresholdIC,test, setprecision, areas, oldICRules,GetDivisionThreshold},
dbgDivide="DivideDebug"/.{opt}/.{"DivideDebug"-> False};
dPrint[x___]:= If[dbg \[Or] dbgDivide, Print["setDivision: ", x]]; 


setprecision[x_,y_]:= Round[x,10.^Round[Log[10,y*x]]];

index[x_[i_]]:= i; 
divisionthreshold = "DivisionThreshold"/.{opt}/.{"DivisionThreshold"-> \[Infinity]};
dPrint["divisionthreshold: ", divisionthreshold]; 
smallarea="SmallArea"/.{opt}/.{"SmallArea"-> divisionthreshold/100};
sigma="DivisionSigma"/.{opt};
dPrint["sigma=", sigma]; 

divisionvariable="DivisionVariable"/.{opt}/.{"DivisionVariable"-> "Unknown"};
ThreshVar="DivisionThresholdVariable"/.{opt}/.{"DivisionThresholdVariable"-> "Unknown"}; 
dPrint["divisionvariable: ", divisionvariable, " threshold variable: ", ThreshVar]; 
 If[divisionthreshold==Infinity, 
dPrint["division is inhibited: infinite threshold"]; 
Return[{0, {}, {}}]]; 

dPrint["$DivisionThresholds: ", $DivisionThresholds]; 


vars = Select[allvars, Head[#]==divisionvariable&];
IgnoreDivisionBeyondThisRadius="IgnoreDivisionRadius"/.{opt}/.{"IgnoreDivisionRadius"-> \[Infinity]};
If[IgnoreDivisionBeyondThisRadius<\[Infinity],
Origin =  "Origin"/.{opt};
(* Use Centeroid instead of Centroid because funny tings can happen on the outer edge*)
centroids=Centeroid[DT];
centroids = (#-Origin)&/@centroids; 
radii = Norm/@centroids;
divisible = (#<IgnoreDivisionBeyondThisRadius)&/@radii ; 
cellnumbers = First/@TissueCells[DT]; 
divisible=Pick[cellnumbers,divisible];
(* select rather than just pick because vars might not be in order *)
(* why can't just do divisionvariable/@visible ? *)
vars = Select[vars, MemberQ[divisible, Last[#]]&] ;
dPrint["vars: ", vars]
];

dPrint["vars: ", vars];
heads = Head/@vars;
indices = index/@vars;
dPrint["heads: ", heads]; 
dPrint["indices: ", indices]; 

thresholds =Table[
RandomVariate[NormalDistribution[divisionthreshold, sigma]], {Length[vars]}];thresholds = setprecision[#,.001]&/@thresholds; 


(* Make sure new thresholds exceed current areas *)

dPrint["thresholds (before cap): ", thresholds];
thresholds = MapThread[Max[1.001*areafunction[DT,#1],#2]&,{indices, thresholds}];

dPrint["thresholds (after cap): ", thresholds];


GetDivisionThreshold[i_,v_]:= ThreshVar[i]/.$DivisionThresholds/.(ThreshVar[i]-> v); 

threshequations=MapThread[(ThreshVar[#1][Global`t]==GetDivisionThreshold[#1,#2])&, {indices, thresholds}];
dPrint["threshequations: ", threshequations]; 

thresholdIC=MapThread[Rule[ThreshVar[#1],GetDivisionThreshold[#1,#2]]&, {indices,thresholds}]; 
dPrint["theIC: ", thresholdIC]; 

(* save for next time *)

$DivisionThresholds=thresholdIC;  

div=\[CapitalPsi]/@(( divisionvariable[#][Global`t]-ThreshVar[#][Global`t])&/@indices);
div = -smallarea+Plus@@Abs/@div; 


Block[{Ident},
Ident[x_][t_]:= divisionthreshold; 
dPrint["test/.stuf ", test/.(ThreshVar-> Ident)]; 
]; 

(* div =-smallarea+ Plus@@Abs/@(\[CapitalPsi]/@( #[Global`t]-divisionthreshold&/@vars)); *)

dPrint["div: ", div]; 

(* div=test;*)

Return[{div,threshequations, thresholdIC}]; 

]; 


(* ::Input::Initialization:: *)
performAllNecessaryCellDivisions[sim_, DTSTART_,opt___?OptionQ]:= Module[{TFinal, cells,cell,celldivstuff,DT,c,cellnumbers,dbg, dPrint,done, tstart,tend,s,angles,p1,p2,T1,T2,nmax,toDynamicNumberRules,toStaticNumberRules, staticcell, newlineage,edgechanges,newedgelineage,MinAngleSpread,x,y, lineage, edgelineage,weights, divisionmodel,method, L1Anticlinal,L2Anticlinal, L2AnticlinalRatio,upwards},
dbg = "DivideDebug"/.{opt}/.{"DivideDebug"-> False};
upwards="Upwards"/.{opt}/.{"Upwards"-> False}; 

divisionmodel="DivisionModel"/.{opt}/.{"DivisionModel"-> "Potential"};
L1Anticlinal = "L1Anticlinal"/.{opt}; 
L2Anticlinal = "L2Anticlinal"/.{opt}; 
L2AnticlinalRatio = "L2AnticlinalRatio"/.{opt}/.{"L2AnticlinalRatio"-> 1.0*GoldenRatio};

(* Print["performAllNecessaryCellDivisions: opt: ", {opt}]; *)

dPrint["performAllNecessaryCellDivisions: L1Anticlinal: ", L1Anticlinal]; 
dPrint["performAllNecessaryCellDivisions: L2Anticlinal: ", L2Anticlinal]; 

Switch[divisionmodel,
"Potential",method=1,
"Errera", method=2,
_, AbortIf[True, "Invalid division model = '"<>ToString[divisionmodel]<>"' Expecting \"Potential\" or \"Errera\"."]
]; 


dPrint[u___]:= If[dbg, Print["performAllNecessaryCellDivisions: ", u]];

s="Solution"/.sim;
done = "Finished"/.sim;

dPrint["done: ", done]; 

x = "x"/.{opt}/.{"x"-> Global`x}; 
y="y"/.{opt}/.{"y"-> Global`y}; 
lineage = "Lineage"/.{opt}/.{"Lineage"-> {}};
edgelineage="EdgeLineage"/.{opt}/.{"EdgeLineage"-> {}};  

dPrint["lineage: ", lineage];
dPrint["edgelineage: ", edgelineage]; 

weights="Weights"/.{opt}/.{"Weights"-> {1,1,1}};

MinAngleSpread="MinAngleSpread"/.{opt}/.{"MinAngleSpread"-> 135.0};   
{tstart,tend}="TimeSpan"/.sim;

c=TissueCells[DTSTART]; 
cellnumbers=First/@c;
dPrint["cellnumbers: ", cellnumbers]; 
toDynamicNumberRules=MapThread[Rule,{Range[Length[c]],cellnumbers}];toStaticNumberRules=Reverse/@toDynamicNumberRules;
dPrint["toStaticNumberRules: ", toStaticNumberRules]; 

TFinal = DTissue2Tissue[DTSTART, s,tend];

If[done,
dPrint["performAllNecessaryCellDivisions called with Finished = True; div = ","Divide"/.sim]; 
dPrint["Simulation completed normally at t = ", tend];
dPrint[TFinal]; 
dPrint[Tissue2DTissue[TFinal,"Numbers"-> cellnumbers]]; 
Return[{"Tissue"-> Tissue2DTissue[TFinal,"Numbers"-> cellnumbers], "Lineage"-> lineage, "EdgeLineage"-> edgelineage}];
];

dPrint["TFinal: ", TFinal];  
cells="Divide"/.sim;
DT=Tissue2DTissue[TFinal,"Numbers"-> cellnumbers];
$Tissue=DT; 
dPrint["DT = ", DT]; 
celldivstuff=DetermineCellDivisionPoints[sim,DT,L1Anticlinal,L2Anticlinal, L2AnticlinalRatio, upwards, weights,x,y,method, MinAngleSpread ]; 

T1=TFinal; 
nmax = Max[Max[cellnumbers],Length[cellnumbers]];
newlineage = lineage;
dPrint["lineage=", lineage];  
dPrint["edgelineage=", edgelineage];
newedgelineage=edgelineage; 
While[Length[cells]>0,
{angles,p1,p2}=First[celldivstuff]; celldivstuff=Rest[celldivstuff]; 
cell=First[cells]; cells=Rest[cells];
staticcell = cell/.toStaticNumberRules; 
dPrint["cell = ", cell, " staticcell = ", staticcell, " points = ", p1, " and ", p2]; 
Print["Cell ", cell, " (static cell ", staticcell,") divides at t = ",tend]; 
{edgechanges,T1}= DivideCell[T1,staticcell,{p1,p2}, "Changes"-> True];
If[edgechanges==$Failed, Abort[]]; 
edgechanges = edgechanges/.{{}-> 0}; 
newedgelineage = Join[newedgelineage, Select[edgechanges,First[#]!= Last[#]&]]; 
nmax = nmax+1;  
AppendTo[newlineage,cell-> nmax];
];
dPrint["newlineage: ", newlineage]; 
dPrint["newedgelineage: ", newedgelineage]; 
T2=Tissue2DTissue[T1,"Numbers"-> cellnumbers];
{"Tissue"-> T2, "Lineage"-> newlineage, "EdgeLineage"-> newedgelineage}
]



(* ::Input::Initialization:: *)
ShowSavedFiles[]:= FileNames[ToFileName[$SIMDIR,#]&/@{"*.nb", "*.mx"}];
ShowSavedFiles[type_]:= Module[{Type,f},
Type=ToString[type]; 
f=Switch[Type,
"IC", {"IC*.nb"}, 
"ODE",{"ODE*.nb"},
"Options",{"Simulation-Options.nb"},
"Tissue",{"DTissue*.nb"},
"Net",{"Network*.nb"},
"Equations",{"Equations*.nb"},
"Solutions",{"Solution*.mx", "Solution*.nb"},
"Lineage",{"Lineage.nb"},
"EdgeLineage",{"EdgeLineage.nb"},
_, {Type<>"*.nb", Type<>"*.mx"}
];
f=ToFileName[$SIMDIR, #]&/@f; 
FileNames[f]
];
GetSavedFile[type_]:= Module[{Type,f, str,object,dumped,objname},
Type=ToString[type]; 
str=False; 
f=Switch[Type,
"IC", $ICFILE,
"ODE", str=True; $ODEFILE, 
"Options", $OPTIONFILE,
"Tissue", str=True; $TISSUEFILE,
"Net", $NETFILE,
"Equation", $EQNFILE,
"Solution",$SOLUTIONFILE,
"Lineage", $LINEAGEFILE,
"EdgeLineage",$EDGELINEAGEFILE,
_,ToFileName[$SIMDIR, Type]
];
f=FileNames[f]; 
If[Length[f]<1, Return[$Failed]]; 
f=First[f];
object=Get[f];
If[str, object=ToExpression[object]]; 
If[Type=="Solution",
If[FileExtension[$SOLUTIONFILE]=="mx",
Return[Global`$$SOLUTION]
];
];
Return[object];
];
GetSavedFile[folder_,type_,n_, quiet_:False]:= Module[{num,numx, Type,str,f,object},
num=IntegerString[n,10,4]<>".nb"; 
numx=IntegerString[n,10,4]<>".mx"; 

Type=ToString[type]; 
str=False; 
f=Switch[Type,
"IC", "IC"<>num,
"ODE", str=True; "ODES"<>num, 
"Options", "Simulation-Options.nb",
"Tissue", str=True; "DTissue"<>num,
"Net", "Network"<>num,
"Equation", "Equations"<>num,
"Solution", {"Solution"<>num,"Solution"<>numx},
"Lineage", "Lineage.nb",
"EdgeLineage","EdgeLineage.nb",
_,AbortIf[True,"Unknown file type: "<>Type]; 
];

f=ToFileName[folder, #]&/@Flatten[{f}]; 
f=FileNames[f];  
If[Length[f]<1, Return[$Failed]]; 
f=First[f]; 
If[Not[quiet], Print[f]];

object=Get[f];
If[str, object=ToExpression[object]]; 
If[Type=="Solution",
If[FileExtension[f]=="mx",
Return[Global`$$SOLUTION]
];
];
Return[object];
];
GetSavedFile[f_, type_]:= Module[{Type, str,object},
Type=ToString[type]; 
str=False; 
Switch[Type,
"ODE", str=True,
"Tissue", str=True
];
object=Get[f];
If[str, object=ToExpression[object]]; 
If[Type=="Solution",
If[FileExtension[f]=="mx",
Return[Global`$$SOLUTION]
];
];
Return[object]
]




(* ::Input::Initialization:: *)
GetODES[odes_?ListQ, vars_?ListQ]:= Pick[odes, MemberQ[vars,#]&/@Head/@First/@Head/@First/@odes];
GetODES[odes_?ListQ, var_]:= GetODES[odes, {var}]; 


(* ::Input::Initialization:: *)
BalanceLineage[linput_]:=Module[{newlineage,next,parent,child,newnode,rule,l},l=linput;
newlineage={};
While[Length[l]>0,next=First[l];
l=Rest[l];
parent=First[next];
child=Last[next];
If[parent>0,newnode=ToString[parent]<>"+"<>ToString[child];
rule=(parent->newnode);
newlineage=newlineage/.rule;
newlineage=Join[newlineage,{newnode->parent,newnode->child}];,newlineage=Join[newlineage,{parent->ToString[child],ToString[child]->child}]];];
Return[newlineage];]


(* ::Input::Initialization:: *)
ShowBalancedLineage[l_,position_,label_:True]:= Module[{pstring,new,okpositions={Top,Bottom,Left,Right,Center}},
If[Not[MemberQ[okpositions,position]], Print["Error: ShowBalancedLineage: position must be one of ", okpositions]; Return[Graphics[]]];
pstring[s_]:=Module[{p,str},str=If[StringQ[s],s,ToString[s]];
p=StringPosition[str,"+"];
If[Length[p]<1,Return[str]];
p=First/@p;
p=Min[p];
StringTake[str,p-1]];
new = BalanceLineage[l]; 
If[label,
TreePlot[new,position,0,"VertexLabeling"->True,"VertexRenderingFunction"->(Text[pstring[#2],#1,Background->White]&)],
TreePlot[new,position,0]
]
]


(* ::Input::Initialization:: *)
SetNextIC[Tnew_,Told_, Sim_,NewNet_, equations_, ell_,area_,resting_,x_,y_, IsotropicGrowth_, mu_,IsotropicSprings_,k_, tip_,  center_,tipdist_, perim_,P_, L1_, L2_, TIPF_, PD_,parameters_,  dbg_]:=Module[{species, eused,ne,eflags,eneeded,lvalsneeded,icell,cellnumbers,icarea,nv,vflags,vused,vneeded,xyused,vall,icx,icy,s,values,tbegin,tend, dPrint,icfromsim,icallsim,icneeded, lineage, firstArg, restingneeded,redge,icrnew,elengthrules, lastdivision,parent, child, icchild,icchildp, replaceFirstArg,ic, edgelineage,edgeparents,secondArg, cellparents,replaceSecondArg,nargs,cc,incell,redgecell,redgeparents,redgeparentvalues,parentelextensions,parentallengths,icrok, icstillneeded,adjacentedges, adjacentresting, adjacentlengths,adjacentextensions,lengths,restingAppliedErroneouslyNums, restingAppliedErroneously,restingApplied,restingAppliedNums,muic,kic,tic,ticrules,kvar,muvar,centerIC,perimIC, tipdistIC, PressureIC,Pvar, L1IC, L2IC, TIPFIC, PDIC, EVIC},
dPrint[u___]:= If[dbg, Print["SetNextIC: ", u]]; 
nargs[afunction_[u___]]:= Length[{u}]; 
firstArg[somefunction_[u_,v___]]:= u; 
secondArg[someFunction_[u_,v_,w___]]:= v; 
replaceFirstArg[somefunction_[u_,v___],unew_]:= somefunction[unew,v]; 
replaceSecondArg[someFunction_[u_,v_,w___],vnew_]:= someFunction[u,vnew,w]; 


(* Actual lengths of edges used *)
eused=EdgesUsed[Tnew]; 
ne=NTissueEdges[Tnew]; 
eflags = MemberQ[eused,#]&/@Range[ne];
eneeded = Pick[Range[ne],eflags]; 
lvalsneeded = Pick[EdgeLengths[Tnew],eflags]; 
elengthrules=MapThread[Rule,{eneeded,lvalsneeded}]; 
dPrint["elengthrules:",Short[elengthrules,5]];

(* Actual (dynamic) cell numbers *)
cc=TissueCells[Tnew];
cellnumbers=First/@cc;
incell[edgeNumber_]:= First/@Select[cc, MemberQ[Last[#],edgeNumber]&];

(* Actual vertices used *)
nv=NTissueVertices[Tnew];
vused = VerticesUsed[Tnew]; 
vall = TissueVertices[Tnew];  
vflags=MemberQ[vused,#]&/@Range[nv]; 
vneeded=Pick[Range[nv],vflags]; 
xyused=Pick[vall,vflags]; 


species=Select[interpret[NewNet][[2]],Not[MemberQ[{ell,area,x,y},Head[#]]]&];

(* Find Values in Solution *)
s = "Solution"/.Sim;
{tbegin,tend}="TimeSpan"/.Sim;
values = ((#[Global`t]/.s)&/@species)/.{Global`t->tend};
dPrint["values: ", Short[values,5]]; 
icallsim = MapThread[Rule,{species,values}]; 
icfromsim = Pick[icallsim, NumberQ/@values];
dPrint["icfromsim: ", Short[icfromsim,5]];  
icneeded = First/@Pick[icallsim, Not/@NumberQ/@values]; 

(* NOTE: SOME OF THE resting VALUES were just ERRONEOUSLY REPLACED with their PARENT VALUES! NEED TO REMOVE THOSE! THESE ARE RESTINGS FOR EDGES THAT JUST DIVIDED. BUT THESE WILL BE PARENTS OF REMAING EDGES *)

restingApplied = Select[icfromsim,Head[First[#]]==resting&]; 
restingAppliedNums = firstArg/@(First/@restingApplied); 
dPrint["restingApplied: ", Short[restingApplied,5], "\nEdgeNumbers: ", Short[restingAppliedNums,5]]; 

(* To determine new edge tension: 
(1) For edges that divide in 2, use same compression (rest/length) ratio as parent:
      rest(new) = (rest(parent)/length(parent))* length(extension)
      where parent is the original edge prior to divisions
(2) For edges formed de-novo, after all the other edges are formed, 
		determine the averge compression/tension of the intersecting edges,
		and use that to determine the new resting length.
Note: This idea actually doesn't work, because the average of the intersecting edges can produce a significant bias if one of the neighboring edges is significantly compressed or extended.
 *) 
lineage = "Lineage"/.Sim;
cellparents = Reverse/@lineage;
dPrint["cellparents: ", Short[cellparents,5]]; 
edgelineage = "EdgeLineage"/.Sim;
edgeparents = Reverse/@edgelineage;
dPrint["edgeparents: ", Short[edgeparents,5]]; 

restingneeded =Select[icneeded,Head[#]==resting&];
redge = firstArg/@restingneeded; 
redgeparents = redge/.edgeparents;
dPrint["redge:", Short[redge,5]]; 
dPrint["redgeparents:", Short[redgeparents,5]]; 

restingAppliedErroneouslyNums=Intersection[restingAppliedNums,redgeparents]; 
dPrint["restingAppliedErroneousyNums:", Short[restingAppliedErroneouslyNums,5]]; 
restingAppliedErroneously=resting/@restingAppliedErroneouslyNums;
dPrint["restingApplieErroneously: ",Short[ restingAppliedErroneously,5]]; 
icfromsim=Select[icfromsim, Not[MemberQ[restingAppliedErroneously,First[#]]]&];
dPrint["icfromsim (corrected):", Short[icfromsim,5]]; 

(* Don't use parents of erroneous edges for parents, because they really were the parents! *)
redge = Join[redge, restingAppliedErroneouslyNums]; 
redgeparents = If[MemberQ[restingAppliedErroneouslyNums,#],#, #/.edgeparents]&/@redge; 
restingneeded = resting/@redge; 

dPrint["redge (revised):", Short[redge,5]]; 
dPrint["redgeparents (revised):", Short[redgeparents,5]]; 

redgecell = incell/@redge;
dPrint["redge:", Short[redge,5]]; 
lengths = redge/.elengthrules; 
dPrint["redgecell:", Short[redgecell,5]];
dPrint["redgeparents:", Short[redgeparents,5]]; 
redgeparentvalues =  ((#[Global`t]/.s)&/@(resting/@redgeparents))/.{Global`t->tend};
redgeparentvalues =If[NumberQ[#],#,Indeterminate]&/@redgeparentvalues; 


(* get parental lengths from solution, not tissue *)
parentallengths = ((ell[#][Global`t]/.s)&/@redgeparents)/.{Global`t-> tend}; 
parentallengths = If[NumberQ[#],#,Indeterminate]&/@parentallengths; 
dPrint["Parental Resting: ", Short[redgeparentvalues,5]]; 
dPrint["Parentel Lengths:", Short[parentallengths,5]]; 

parentelextensions = parentallengths/redgeparentvalues;
dPrint["parentelextensions:", Short[parentelextensions,5]]; 
icrnew = MapThread[Rule,{restingneeded, lengths/parentelextensions}];
icrok = Select[icrnew, NumberQ[Last[#]]&]; 
icstillneeded = First/@Complement[icrnew, icrok]; 

redge = firstArg/@icstillneeded; 
lengths = redge/.elengthrules; 

icrnew = icrok; 
adjacentedges = IntersectingEdges[Tnew,#]&/@redge; 
dPrint["icrnew: ",Short[icrnew,5]];

(* finally, the ones that need to be fround from averages *)
adjacentresting=Map[resting,adjacentedges,{2}]/.icrnew/.icfromsim;
dPrint["icstillneeded:", icstillneeded, " redge: ", redge," actual lengths: ", lengths,  " adjacentedges: ", adjacentedges, "adjacentretsing: ", adjacentresting]; 

(* Some of the adjacentedges may be next to each other! *)
If[False, (* Use average of neighbors, but this potentially gives a disastorous bias! *)
adjacentedges = Select[#,Not[MemberQ[redge,#]]&]&/@adjacentedges;
adjacentresting=Map[resting,adjacentedges,{2}]/.icrnew/.icfromsim;
dPrint["icstillneeded (revised):", icstillneeded, " redge: ", redge, " adjacentedges: ", adjacentedges, "adjacentretsing: ", adjacentresting]; 

adjacentlengths=adjacentedges/.elengthrules;
adjacentextensions = Mean/@(adjacentlengths/adjacentresting); 
dPrint["adjacentresting: ", adjacentresting," adjacentlengths: ",  adjacentlengths, " adjacentextensions: ", adjacentextensions]; 
icstillneeded = MapThread[Rule,{icstillneeded,lengths/adjacentextensions}]; 
]; 


icstillneeded = MapThread[Rule,{icstillneeded,lengths}]; 
dPrint["icstillneeded: (set equal to length): ", icstillneeded]; 


icrnew = Join[icstillneeded,icrnew]; 
dPrint["icrnew: ",icrnew];


icneeded=Complement[icneeded,restingneeded];
dPrint["icneeded: ", icneeded]; 

(* Get remaining IC from pre-division *)

lastdivision = Last[lineage]; 
parent = First[lastdivision]; child=Last[lastdivision]; 

Block[{NEEDIC,nextvar,cellParent,edgeParent},
NEEDIC=icneeded; 
values={}; 
While[Length[NEEDIC]>0,
nextvar = First[NEEDIC];
NEEDIC = Rest[NEEDIC]; 
cellParent = firstArg[nextvar]/.cellparents;
edgeParent = If[nargs[nextvar]>1,secondArg[nextvar],0]/.edgeparents;
If[cellParent!= 0, nextvar = replaceFirstArg[nextvar,cellParent]]; 
If[edgeParent!= 0, nextvar = replaceSecondArg[nextvar, edgeParent]]; 
AppendTo[values, nextvar]; 
]; 
]; 
dPrint["values from (using parent cells and edges): ", values]; 
values = ((#[Global`t]/.s)&/@values)/.{Global`t->tend};
dPrint["values (mostly almost numerical): ", values]; 
values = If[NumberQ[#],#,0.0]&/@values;
(* only entirely de-novo edges should be non-numerical at this point *)
dPrint["values (entirely numerical): ", values]; 
icneeded = MapThread[Rule, {icneeded, values}]; 
dPrint["icneeded: ", icneeded]; 

icell=MapThread[Rule,{ell/@eneeded,lvalsneeded}];
icarea=MapThread[Rule,{area/@cellnumbers,areafunction[Tnew]}];

icx=MapThread[Rule,{x/@vneeded,First/@xyused}];
icy=MapThread[Rule,{y/@vneeded,Last/@xyused}];

ic = Join[icfromsim,icrnew,  icneeded, icell, icarea, icx,icy];


(* IC for ell added separately *)
If[ToString[ell]!= "False",
EVIC=ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
EVIC=Select[EVIC, Or[ThingEndsWith[#,ell,"X"], ThingEndsWith[#,ell,"Y"]]&];
EVIC = EVIC/.icx/.icy;
ic = Join[ic, EVIC]; 
]; 


If[ToString[center]==  "False",
centerIC={},
centerIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
centerIC = Select[centerIC, ToString[Head[First[#]]]==ToString[center]&]; 
centerIC = (centerIC/.ic);
ic=Join[ic,centerIC];
];

If[ToString[PD]=="False", 
PDIC={},
PDIC=ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule};

(*PDIC=Select[PDIC, Or[ThingEndsWith[#,PD,"A"], ThingEndsWith[#,PD,"B"], ThingEndsWith[#, PD,"D"], ThingEndsWith[#,PD,"X"], ThingEndsWith[#, PD ,"Y"], ThingEndsWith[#, PD, "EV1"], ThingEndsWith[#, PD, "EV2"], ThingEndsWith[#, PD, "MAXEV"], ThingEndsWith[#,PD,"NORM"], ThingEndsWith[#, PD, "UNITX"], ThingEndsWith[#, PD, "UNITY"]]&]; *)

PDIC=Select[PDIC, ThingsStartWith[#,PD]&];

Block[{LHS, RHS}, 
PDIC = PDIC/.centerIC/.icx/.icy; 
RHS = Last/@PDIC;
LHS = First/@PDIC; 
PDIC = MapThread[#1-> #2&, {LHS, RHS}]; 

RHS = RHS//.PDIC;
PDIC = MapThread[#1-> #2&, {LHS, RHS}]; 
ic = Join[ic, PDIC]; 
];
];

 


ticrules = equations/.{Equal-> Rule};
tic={tip[1][Global`t],tip[2][Global`t]}/.ticrules;
tic=1.0*ToExpression[StringReplace[ToString[InputForm[tic]],"[t]"-> ""]];
tic=tic/.icx/.icy;
tic = MapThread[Rule,{{tip[1],tip[2]},tic}]; 


ic = Join[ic, tic]; 



If[ToString[perim]==  "False",
perimIC={},
perimIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
perimIC = Select[perimIC, ToString[Head[First[#]]]==ToString[perim]&]; 
perimIC = (perimIC/.ic);
ic=Join[ic, perimIC];
];

If[ToString[tipdist]==  "False",
tipdistIC={},
tipdistIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
tipdistIC = Select[tipdistIC, ToString[Head[First[#]]]==ToString[tipdist]&]; 
tipdistIC = (tipdistIC/.ic);
ic=Join[ic,tipdistIC]; 
];



muvar = mu; 
If[ListQ[muvar], muvar=First[muvar]]; 
If[IsotropicGrowth,
muic={},
muic =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
muic = Select[muic, ToString[Head[First[#]]]==ToString[muvar]&]; 
muic = (muic/.ic);
ic=Join[ic,muic];
];


kvar = k; 
If[ListQ[kvar], kvar=First[kvar]]; 
If[IsotropicSprings,
kic={},
kic =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
kic = Select[kic, ToString[Head[First[#]]]==ToString[kvar]&]; 
kic = (kic/.ic);
ic=Join[ic,kic]; 
];

Pvar = P; 
If[ListQ[Pvar], Pvar=First[Pvar]]; 
If[IsotropicGrowth,
PressureIC={},
PressureIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
PressureIC = Select[PressureIC, ToString[Head[First[#]]]==ToString[Pvar]&]; 
PressureIC = (PressureIC/.ic);

ic=Join[ic,PressureIC];
];

dPrint["PressureIC=", PressureIC]; 


If[ToString[L1]!=   "False",
L1IC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
L1IC = Select[L1IC, ToString[Head[First[#]]]==ToString[L1]&]; 
ic=Join[ic, L1IC]; 
];

If[ToString[L2]!=   "False",
L2IC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
L2IC = Select[L2IC, ToString[Head[First[#]]]==ToString[L2]&]; 
ic=Join[ic, L2IC]; 
]; 

If[ToString[TIPF]!=   "False",
TIPFIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
TIPFIC = Select[TIPFIC, ToString[Head[First[#]]]==ToString[TIPF]&]; 
ic = Join[ic, TIPFIC]; 
];








Return[ic/.parameters]; 

]


(* ::Input::Initialization:: *)
DEBUG$IC=False; 
ThingIs[thing_, val_]:= ToString[Head[First[thing]]]==ToString[val]; 
ThingEndsWith[thing_,val_,end_]:= ThingIs[thing, ToString[val]<>end]; 
ThingsStartWith[thing_, val_]:= Module[{n,v,hft},
v=ToString[val]; 
n=StringLength[v];
hft=ToString[Head[First[thing]]]; 
If[StringLength[hft]<n, Return[False]]; 
Return[StringTake[hft,n]==v]
];
SetRandomizedIC[INPUTIC_, tissue_?DTissueQ,network_, equations_, ell_,area_,resting_,x_,y_,extension_,rmin_,rmax_, IsotropicGrowth_, mu_, IsotropicSprings_, k_, tip_,center_, tipdist_, perim_, P_, growing_, L1_, L2_, TIPF_, PD_, parameters_] :=Module[{species,r,ic,v,vall,e,ne,nv,eused,vused, eflags,vflags,xyused,vneeded,lvalsneeded,eneeded, cellnumbers, icout,dbg=False, dPrint,el,restingic,ARandomValue, muic,ineeded, ellic, xic, yic,kic, kvar, speciesIC,tic,ticrules,muvar, areaic,centerIC, perimIC, tipdistIC, PressureIC, Pvar, L1IC, L2IC, TIPFIC, PDIC, EVIC},
dPrint[u___]:= If[dbg, Print["SetRandomizedIC: ", u]]; 

If[DEBUG$IC, dbg=True];

eused=EdgesUsed[tissue]; 
vused = VerticesUsed[tissue]; 
ne=NTissueEdges[tissue]; 
nv=NTissueVertices[tissue];
eflags = MemberQ[eused,#]&/@Range[ne];
vflags=MemberQ[vused,#]&/@Range[nv]; 
cellnumbers=First/@TissueCells[tissue];

eneeded = Pick[Range[ne],eflags];
dPrint["eneeded:", eneeded];  

el  =EdgeLengths[tissue]; 
lvalsneeded = Pick[el,eflags]; 

(* the user may have supplied some resting lengths, rev 9.15.12 *)
restingic =Map[ (resting[#]-> (resting[#]/.INPUTIC/.{resting[#]-> el[[#]]/extension}))&, eneeded]; 


dPrint["restingic: ", restingic]; 

vall = TissueVertices[tissue];  
vneeded=Pick[Range[nv],vflags]; 
xyused=Pick[vall,vflags]; 

ineeded=interpret[network][[2]]; 
species=Select[interpret[network][[2]],Not[MemberQ[{ell,area,resting,x,y,mu},Head[#]]]&];

(* r:=Random[Real,{rmin,rmax}];*)
If[rmax>rmin, 
ARandomValue:= Random[Real,{rmin,rmax}],
ARandomValue:= rmin;
];
r[s_]:= s/.INPUTIC/.{s-> ARandomValue}; 

speciesIC = (#->r[#])&/@species; 

ellic=MapThread[Rule,{ell/@eneeded,lvalsneeded}];

xic=yic={}; 
If[ToString[x]!= "False" \[And] ToString[y]!= "False", 
xic=MapThread[Rule,{x/@vneeded,First/@xyused}];
yic=MapThread[Rule,{y/@vneeded,Last/@xyused}];
xic = xic/.speciesIC;
yic = yic/.speciesIC;
]; 

EVIC={}; 
If[ToString[ell]!= "False",
EVIC=ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
EVIC=Select[EVIC, Or[ThingEndsWith[#,ell,"X"], ThingEndsWith[#,ell,"Y"]]&];
EVIC = EVIC/.xic/.yic;
]; 


dPrint["ellic=", ellic]; 
dPrint["xic=", xic];
dPrint["yic=", yic]; 


If[ToString[area]=="False", 
areaic={}, 
areaic = MapThread[Rule,{area/@cellnumbers,areafunction[tissue]}]
];
dPrint["areaic=", areaic];  



If[ToString[center]==  "False",
centerIC={},
centerIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
centerIC = Select[centerIC, ToString[Head[First[#]]]==ToString[center]&]; 
centerIC = (centerIC/.xic/.yic/.areaic);
];



If[ToString[PD]=="False", 
PDIC={},
PDIC=ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule};

dPrint["PDIC: ", Short[PDIC,10]]; 

PDIC=Select[PDIC, ThingsStartWith[#,PD]&];
dPrint["First/@PDIC: ", Short[First/@PDIC, 10]];  
Block[{LHS, RHS}, 
PDIC = PDIC/.centerIC/.xic/.yic; 
RHS = Last/@PDIC;
LHS = First/@PDIC; 
PDIC = MapThread[#1-> #2&, {LHS, RHS}]; 

RHS = RHS//.PDIC;
PDIC = MapThread[#1-> #2&, {LHS, RHS}]; 
dPrint["PDIC: ",Short[ PDIC,10]]; 
]
]; 

If[ToString[tip]=="False", 
tic={}, 
ticrules = equations/.{Equal-> Rule};
tic={tip[1][Global`t],tip[2][Global`t]}/.ticrules;
tic=1.0*ToExpression[StringReplace[ToString[InputForm[tic]],"[t]"-> ""]];

tic=tic/.xic/.yic;
tic = MapThread[Rule,{{tip[1],tip[2]},tic}]; 
]; 



If[ToString[perim]==  "False",
perimIC={},
perimIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
perimIC = Select[perimIC, ToString[Head[First[#]]]==ToString[perim]&]; 
perimIC = (perimIC/.ellic);
];

If[ToString[tipdist]==  "False",
tipdistIC={},
tipdistIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
tipdistIC = Select[tipdistIC, ToString[Head[First[#]]]==ToString[tipdist]&]; 
tipdistIC = (tipdistIC/.tic/.centerIC);
];

kvar = k; 
If[ListQ[kvar], kvar=First[kvar]]; 
If[IsotropicSprings,
kic={},
kic =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
kic = Select[kic, ToString[Head[First[#]]]==ToString[kvar]&]; 
kic = (kic/.ellic/.xic/.yic/.speciesIC/.centerIC/.perimIC/.tipdistIC/.areaic/.EVIC/.PDIC)
];
dPrint["kic=", kic]; 

muvar = mu; 
If[ListQ[muvar], muvar=First[muvar]]; 
If[IsotropicGrowth,
muic={},
muic =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 

(* dPrint["muic: ", muic]; *)

muic = Select[muic, ToString[Head[First[#]]]==ToString[muvar]&]; 
muic = (muic/.ellic/.xic/.yic/.speciesIC/.centerIC/.perimIC/.tipdistIC/.areaic/.EVIC/.PDIC);
];


Pvar = P; 
If[ListQ[Pvar], Pvar=First[Pvar]]; 
If[IsotropicGrowth,
PressureIC={},
PressureIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
PressureIC = Select[PressureIC, ToString[Head[First[#]]]==ToString[Pvar]&]; 
PressureIC = (PressureIC/.ellic/.xic/.yic/.speciesIC/.centerIC/.perimIC/.tipdistIC/.areaic);
];
dPrint["PressureIC=", PressureIC]; 

If[ToString[L1]==  "False",
L1IC={},
L1IC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
L1IC = Select[L1IC, ToString[Head[First[#]]]==ToString[L1]&]; 

];

If[ToString[L2]==  "False",
L2IC={},
L2IC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
L2IC = Select[L2IC, ToString[Head[First[#]]]==ToString[L2]&]; 
];

If[ToString[TIPF]==  "False",
TIPFIC={},
TIPFIC =ToExpression[StringReplace[ToString[InputForm[equations]],"[t]"-> ""]]/.{Equal-> Rule}; 
TIPFIC = Select[TIPFIC, ToString[Head[First[#]]]==ToString[TIPF]&]; 
];


ic = Join[speciesIC, xic, yic, areaic,  tic, centerIC, tipdistIC, L1IC, L2IC, TIPFIC, PDIC]; 

If[growing, 
ic = Join[ic, ellic, EVIC, restingic, muic,kic,perimIC, PressureIC]/.parameters]; 




Return[ic]
]


(* ::Input::Initialization:: *)
ShowInitialRates[eqs_, ic_, rates_, BoundaryConditions_]:= Module[{iclist, BC },
(* eqs=interpret[network][[1]]; J*)
iclist =ic/.{Rule-> List}; 
iclist =Rule[#[[1]][Global`t],#[[2]]]&/@iclist ;
BC = BoundaryConditions/.{Rule-> List}; 
BC = Rule[#[[1]][0][Global`t], #[[2]]]&/@BC;
eqs/.iclist/.rates/.BC
]


(* ::Input::Initialization:: *)
$DebugHasSufficientInfo=False; 
HasSufficientInfo[network_,equations_, ic_,parameters_,growing_, x_, y_, cell_, ReturnString_]:= Module[{eq,species}, 
{eq,species}=interpret[network];
HasSufficientInfo[eq,species,equations, ic,parameters,growing,x, y,  cell, ReturnString]
];
HasSufficientInfo[eq_,species_,equations_, ic_,parms_,growing_,x_, y_,  cell_, ReturnString_]:= Module[{speciesr1,icr1,vals,ok,okstring, problem,xsp,xspt,r1,xr1,xr2,eqlhs,eqrhs, ir,OK,rok,dbg=$DebugHasSufficientInfo,dPrint, parameters, APRATES},

parameters = parms;

dPrint[u___]:= If[dbg, Print["HasSufficientInfo: ", u]]; 

dPrint["eq: ", Short[eq,5]]; 
dPrint["parameters = ", parameters]; 
dPrint["species = ", Short[species,3]]; 
dPrint["equations = ", Short[equations,3]]; 

APRATES={}; 
If[growing,

Block[{APIC, APRHS,APLHS,myx, xir, yir, aprules},
APIC=Select[equations, ToString[Head[Head[First[#]]]]==ToString[cell]&]; 
APLHS = First/@APIC;
APRHS = InputForm[(Last/@APIC)]; 

APRHS=ToExpression[StringReplace[ToString[APRHS], {"[t]"-> "'[t]" }]]; 
dPrint["APRHS: ", Short[APRHS, 5]]; 


ir=ShowInitialRates[eq,ic,parameters,{}]; 
xir = Select[ir, ToString[Head[First[Head[First[#]]]]]==ToString[x]&];
yir = Select[ir, ToString[Head[First[Head[First[#]]]]]==ToString[y]&];
xir = (xir/.{Equal-> Rule}); 
yir = (yir /. {Equal -> Rule}); 
 
dPrint["xir=", Short[xir,5]]; 
dPrint["yir=", Short[yir, 5]]; 

APRHS = (APRHS/.xir/.yir); 
dPrint["APRHS: ", Short[APRHS, 5]]; 


APLHS=ToExpression[StringReplace[ToString[APLHS], {"[t]"-> "'[t]" }]];
dPrint["APLHS: ", Short[APLHS, 5]]; 

APRATES = MapThread[Equal, {APLHS, APRHS}]; 
dPrint["APRATES: ", Short[APRATES, 5]]; 

aprules = APRATES/.{Equal-> Rule}; 
dPrint["aprules: ", Short[aprules, 5]]; 

parameters = Join[parameters, aprules]; 

];
]; 


xspt = First/@equations; 
xsp= Head/@xspt;
xr1 = MapThread[Rule,{xsp,xspt}]; 

r1=(#-> #[Global`t])&/@species;
r1=Join[r1,xr1]; 

icr1=ic/.r1;
dPrint["ic: ", Short[ic,3]]; 
dPrint["icr1: ", Short[icr1,3]]; 

(* if variables in equations have ic this won't be necessary to check but it shouldn't hurt *)
eqlhs = First/@equations;
dPrint["eqlhs: ", Short[eqlhs,3]]; 

eqrhs =( Last/@equations)/.icr1/.parameters;
dPrint["eqrhs: ", Short[eqrhs,3]]; 

xr2 = MapThread[Rule,{eqlhs,eqrhs}]; 

dPrint["xr2: ", Short[xr2,3]]; 

vals=Last/@((eq/.(icr1))/.parameters);
dPrint["vals: ", Short[vals,3]]; 
vals = 1.0*vals/.xr2; 
dPrint["vals/.xr2: ", Short[vals,3]];
(* Complex Infinity Might Arise *)
vals = Quiet[vals/.{Global`t-> 1}];  
vals = Complement[vals, {Infinity, -Infinity, ComplexInfinity}]; 
ok=And@@NumericQ/@vals;
OK = ok; 
dPrint["ok=", ok]; 
problem=Select[
Union[Flatten[vals/.{Plus-> List,Times-> List,Abs-> List,  Power-> List}]], 
Not[NumericQ[#]]&]; 

(* Block[{derivatives}, 
derivatives= Select[problem, StringMatchQ[ToString[FullForm[#]], "Derivative*"]&]; 
problem=Complement[problem, derivatives]; 
If[Length[problem]<1, OK=ok=True]; 
]; *)


dPrint["problem=", problem];
If[ReturnString,
problem=If[ok,""," because of "<>ToString[InputForm[problem]]]; 
ok = If[ok,""," not"]; 
ok="This simulation is"<>ok<>" complete and may"<>ok<>" be used to run a simulation."<>problem; 
];

ir=Indeterminate; 
If[OK,
ir=ShowInitialRates[eq,ic,parameters,{}]; 




vals =NumericQ/@(Last/@(ir));
problem=Pick[ir, Not/@vals]; 
rok = And@@vals
(* ir = If[ReturnString, 
If[Length[problem]\[Equal]0, "The initial rates are all numeric.", "The initial rates may have some issues: "<>ToString[InputForm[problem]]], 
rok]
*)

];


Return[{ok,Join[ir, APRATES]}]
]


(* ::Input::Initialization:: *)
X2SSANetwork[net_, diff_,  tissue_?TissueQ, verbose_:True]:= Module[{bignet},
bignet = CelleratorNetwork[tissue, "Reactions"-> net, "Diffusion"-> diff, "Verbose"-> verbose]; 
bignet=ToExpression[StringReplace[ToString[bignet],"[t]"->""]];
bignet=XLR8RtoSSA[bignet]; 
Return[bignet]; 
]


(* ::Input::Initialization:: *)
SSANetwork[net_, diff_,  tissue_?TissueQ, verbose_:True]:= Module[{bignet},
bignet = SSAtoXLR8R[net]; 
bignet = X2SSANetwork[bignet, diff, tissue, verbose]; 
Return[bignet]; 
]


(* ::Input::Initialization:: *)
indexify[{},index_]:= {}; 
indexify[net_,index_, opt___?OptionQ]:=Module[{species,reactions,rateRules,rules,indexedSpecies, mysub, mysup, myexpr, dbg=False, dPrint, lengths, extraSpecies, tipdist, xcenter, ycenter, center, myxcenter,myycenter, hasCEN,L1,L2,TIPFLAG, A, cellindex},



dPrint[x___]:= If[dbg, Print["indexify: ", x]]; 

cellindex="CellIndex"/.{opt}; (* don't specify a default and it should be OK*)


dPrint["options: ", {opt}]; 
dPrint["cellindex: ", cellindex]; 
dPrint["index: ", index]; 

tipdist = "tipDistance"/.{opt}/.{"tipDistance"-> False}; 
L1="L1"/.{opt}/.{L1-> False}; 
L2="L2"/.{opt}/.{L2-> False}; 
TIPFLAG="TipFlag"/.{opt}/.{"TipFlag"-> False}; 
A = "CellVariable"/.{opt}/.{"CellVariable"-> Global`cell}; 

extraSpecies={A}; 
If[ToString[tipdist]!= "False", AppendTo[extraSpecies, tipdist]]; 
If[ToString[L1]!= "False", AppendTo[extraSpecies, L1]]; 
If[ToString[L2]!= "False", AppendTo[extraSpecies, L2]]; 
If[ToString[TIPFLAG]!= "False", AppendTo[extraSpecies, TIPFLAG]]; 


center = "center"/.{opt}/.{"center"-> False}; 
hasCEN=False;
If[ToString[center]!= "False",
xcenter=ToExpression["x"<>ToString[center]];
ycenter=ToExpression["y"<>ToString[center]]; 
extraSpecies=Join[extraSpecies, {xcenter, ycenter}]; 
myxcenter[j_][t_]:= center[j,1][t];
myycenter[j_][t_]:= center[j,2][t];
hasCEN=True;
]; 

(*generate replacement rules x-->x[index],...*)


mysub[x__]:= stringify[InputForm[Subscript[x]]]; 
mysup[x__]:= stringify[InputForm[Superscript[x]]]; 


species=interpret[net][[2]];
species = Join[species, extraSpecies]; 
indexedSpecies=#[index]&/@species;
rules=MapThread[Rule,{species,indexedSpecies}];
(*separate rate rules from reactions:this is becasue we may have a rate constant like Subscript[k,CLV] where CLV is the name of a species*)reactions=First/@net;
rateRules=Rest/@net;

(* hide any super/subscripts in the rate constants *) 

rateRules = rateRules/.{Subscript-> mysub, Superscript-> mysup}; 
lengths = Length/@rateRules;

dPrint["rateRules (1):", rateRules]; 
dPrint["lengths: ", lengths]; 

(* apply the indices to the rate constants, just in case there is a species in there *)

rateRules=rateRules/.rules;
dPrint["rateRules (2):", rateRules]; 

(* recover any hidden superscrips/subscripts in the rate constants *)

(* rateRules=Flatten[rateRules]; 
dPrint["rateRules (3):", rateRules]; *)

rateRules = InputForm/@rateRules; 
dPrint["rateRules (4):", rateRules]; 

rateRules=stringify/@rateRules;
dPrint["rateRules (5):", rateRules]; 

rateRules = StringReplace[#, {"\""-> ""}]&/@rateRules; 
rateRules=ToExpression/@rateRules; 
(* rateRules=List/@rateRules; *)
dPrint["rateRules (6):", rateRules]; 


(*apply the indexing to the species*)reactions=reactions/.rules;
(*join the reactions back to the rate rules*)reactions=MapThread[Prepend[#1,#2]&,{rateRules,reactions}];


If[hasCEN,
reactions = (reactions/.{xcenter-> myxcenter, ycenter-> myycenter})
];

(* replace externally specified cell number with actual cell number *)
reactions = reactions/.{cellindex-> index};



Return[reactions]];


(* ::Input::Initialization:: *)
RunSim[bignet_, parameters_, ic_, {tstart_, tend_}, opt___?OptionQ]:= Module[{sim},
sim = run[bignet,{tstart, tend},  xlr8r`initialConditions-> ic, xlr8r`rates-> parameters, opt]; 
sim=Flatten[sim]; 
Return[sim]
]


(* ::Input::Initialization:: *)
Bins2Histogram[bins_,{binmin_,binmax_,bindelta_},opt___?OptionQ]:=Module[{g,nb,h,theHistogram,meanHistPlot,meanStyle,plotStyle, EB, sigmas, SD, xvals, yvals,BINS, TBINS, errorbars, means, plt ,scatter, normalize, totals,navg,savg, labels,meanarea, SDarea, rounding,plot,BINLHS, format,showStatistics,frameticks},

SD[{x__}]:= If[Length[{x}]<2,0.0, StandardDeviation[1.0*{x}]]; 
nb=Round[(binmax-binmin)/bindelta];
meanStyle="Mean"/.{opt}/.{"Mean"->{Thick,Red}};
plotStyle="Style"/.{opt}/.{"Style"->{Black}};
EB = "ErrorBars"/.{opt}/.{"ErrorBars"-> True}; 
scatter="Scatter"/.{opt}/.{"Scatter"-> True}; 
normalize="Normalize"/.{opt}/.{"Normalize"-> False}; 
rounding = "Rounding"/.{opt}/.{"Rounding"-> .1}; 
format = "Format"/.{opt}/.{"Format"-> "Plot"}; 
format=ToUpperCase[ToString[format]]; 
showStatistics="Statistics"/.{opt}/.{"Statistics"-> True}; 
 
BINLHS = Table[binmin+i*bindelta, {i,0, nb-1}]; 

g[h_]:=Join@@Table[{{binmin+(i-1)*bindelta,0},{binmin+(i-1)*bindelta,h[[i]]},{binmin+(i)*bindelta,h[[i]]},{binmin+bindelta*i,0}},{i,1,nb}];
(* get the actual BINS J*)
BINS=Last/@bins;

(* stats on total number of cells in analysis *)

totals = 1.0*Plus@@#&/@BINS;
navg=Mean[totals];
savg=If[Length[totals]>1, StandardDeviation[totals],0]; 
totals = 1.0/totals;

(* normalization sets total area to one *)
If[normalize,
BINS = MapThread[Times, {totals, BINS}]; 
]; 

(* generate plottable data set from bins *)
h=g/@BINS;

TBINS=Transpose[BINS]; 

(* statistics are y-values *) 

means=Mean/@(1.0*TBINS);
sigmas = SD/@TBINS; 
nb=Length[sigmas]; 
xvals = Table[binmin+(i+.5)*bindelta, {i,0,nb-1}]; 
yvals=means; 
meanarea=1.0*Plus@@(xvals*yvals);
If[Not[normalize], meanarea=meanarea/(1.0*Plus@@yvals)]; 
 
SDarea = Plus@@(yvals*(((#-meanarea)^2)&/@xvals));
SDarea = SDarea/(1.0*Plus@@yvals); 
SDarea = Sqrt[SDarea]; 

(* generate error bars for plot *)

errorbars=Graphics[{}];  
If[EB,
errorbars = ErrorListPlot[MapThread[{{#1,#2}, ErrorBar[#3]}&, {xvals, yvals, sigmas}], PlotStyle-> meanStyle];
]; 


With[{popt=MyFilterOptions[Plot,opt]}, 

theHistogram=Show[ListPlot[#,Joined->True,InterpolationOrder->0,PlotRange->All,PlotStyle->plotStyle]&/@h,FrameTicks->{{Automatic,None},{Range[binmin,binmax,bindelta],None}},Frame->True, popt];
meanHistPlot=ListPlot[g[means],Joined->True,FrameTicks->{{Automatic,None},{Range[binmin,binmax,bindelta],None}},Frame->True, PlotStyle->meanStyle, popt];
If[showStatistics,
labels=Graphics[{Text["n="<>ToString[Round[navg,.1]]<>"\[PlusMinus]"<>ToString[Round[savg,.1]]<>"\nvalue="<>ToString[Round[meanarea,rounding]]<>"\[PlusMinus]"<>ToString[Round[SDarea,rounding]], Scaled[{0.05,.9}], {-1,0}]}],
labels=Graphics[{}]
]; 
plot=If [scatter, 
Show[theHistogram,meanHistPlot, errorbars,labels, popt], 
Show[meanHistPlot,errorbars,labels, popt]
]];

Switch[format,
"PLOT", Return[plot],
"NUMERIC", Return[{BINLHS,means,sigmas}],
_ , Print["Unrecognized \"Format\"\[Rule] ", format]; Return[plot]
];

]


(* ::Input::Initialization:: *)
BinData[data_,{binmin_, binmax_, bindelta_}]:=Module[{nbins, WhichBin,bins,whichbin,sigma,mu},
nbins = (binmax-binmin)/bindelta; 
WhichBin[value_]:= Which[
value<binmin,1,
value >binmax,nbins,
True, Floor[(value-binmin)/bindelta]+1
];


bins=Table[0,{nbins}]; 
whichbin=WhichBin/@data;

For[i=1,i<=Length[whichbin],i++,bins[[whichbin[[i]]]]++];

If[Length[data]<2, sigma=0, sigma=StandardDeviation[data]]; 
mu=Mean[data];
Return[
{ mu, sigma, bins}
] 
]


(* ::Input::Initialization:: *)
SimBinData[var_, {binmin_, binmax_, bindelta_}, opt___?OptionQ]:= Module[{d,dPrint,SFiles,TFiles, nS,dbg,plots,f,plot,s,needed, solutionsneeded,solutionFiles,nFiles, nbins,bins, binspec, WhichBin,  samples, reallyneeded, results,reverseneeded, origin, rmax, times, tfile, arg},
dbg="Debug"/.{opt}/.{"Debug"-> False}; 
arg[a_[b_]]:= b; 
dPrint[u___]:= If[dbg, Print["SimBinData: ", u]]; 

nbins = (binmax-binmin)/bindelta; 
WhichBin[value_]:= Which[
value<binmin,1,
value >binmax,nbins,
True, Floor[(value-binmin)/bindelta]+1
];

(* Number of time points to sample *)
samples="Samples"/.{opt}/.{"Samples"-> 100}; 

origin="Origin"/.{opt}/.{"Origin"-> {0, 0}}; 
rmax = "MaxRadius"/.{opt}/.{"MaxRadius"-> \[Infinity]}; 

Block[{stuff}, 
stuff = GetSimulationPoints[ "Points"-> samples, opt]; 
If[SameQ[stuff, $Canceled], Return[$Canceled]]; 
needed = "needed"/.stuff;
SFiles="Solutions"/.stuff;
TFiles="Tissues"/.stuff; 
d="folder"/.stuff;
]; 

dPrint["d: ", d]; 
dPrint["needed: ", needed]; 
dPrint["SFiles: ", SFiles];
dPrint["TFiles: ", TFiles]; 

(* d=SystemDialogInput["Directory", ToFileName[HomeDirectory[]], WindowTitle\[Rule] "Please select the folder that contains Solution*.nb files.):"];*)

If[SameQ[d,$Canceled], Return[$Canceled]];
 
nS=Length[SFiles]; 
dPrint["nS:", nS]; 
If[nS==0, Print["No Simulation results found in "<>d]; Return[$Failed]]; 
plots={}; 


solutionsneeded = First/@needed; 
solutionFiles = SFiles[[solutionsneeded]]; 

nFiles=Length[needed]; 
dPrint["nFiles: ", nFiles]; 

dPrint[needed]; 
reverseneeded[flist_, Rule[A_, B_?ListQ]]:= {#,flist[[A]]}&/@B;
reallyneeded=Join@@(reverseneeded[SFiles,#]&/@needed); 
times =First/@reallyneeded; 
SFiles = Last/@reallyneeded; 
TFiles = Last/@(Join@@(reverseneeded[TFiles,#]&/@needed));
dPrint[times]; 
dPrint[SFiles]; 
dPrint[TFiles]; 


dPrint["reallyneeded: ", reallyneeded]; 


results={}; 
Block[{time,file,S, T,T1, R,CN,inside, variables,values, whichbin,i, sigma},
BINS={}; 
While[Length[SFiles]>0,
time = First[times]; times=Rest[times]; 
file=First[SFiles]; SFiles=Rest[SFiles]; 
tfile=First[TFiles]; TFiles=Rest[TFiles]; 
dPrint["=============================================\nt=",time, " ", file, " ", tfile]; 
S=Get[file]; 
T=ToExpression[Get[tfile]]; 
CN=First/@TissueCells[T];
T1=DTissue2Tissue[T,S,time]; 

R=Norm/@((#-origin)&/@Centeroid[T1]); 
 
R=Transpose[{CN,R}]; 
dPrint["R=",R]; 
R=Select[R, (Last[#]<rmax)&]; 
inside = First/@R;
dPrint["inside=",inside]; 


variables = Select[First/@S, Head[#]==var&]; 
(* Print[variables]; *)
variables=Select[variables, MemberQ[inside,arg[#]]&]; 
dPrint[variables]; 


values = ((#[time])&/@variables)/.S;
dPrint[values]; 
bins=Table[0,{nbins}]; 
whichbin=WhichBin/@values;
dPrint[whichbin]; 
For[i=1,i<=Length[whichbin],i++,bins[[whichbin[[i]]]]++];
If[Length[values]<2, sigma=0, sigma=StandardDeviation[values]]; 
AppendTo[results, {time, Mean[values], sigma, bins}]; 

];


]; 
Return[results]; 

]



(* ::Input::Initialization:: *)
SimBinSides[ opt___?OptionQ]:= Module[{d,dbg,dPrint,f,file,T,c,bins,i,ncells,sides,hbin,results, selected, first, last, j, rmax, origin, R},
dbg="Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[u___]:= If[dbg, Print["SimBinData: ", u]]; 

selected = "Select"/.{opt}/.{"Select"-> {1,Infinity}}; 
selected=Append[{selected}, Infinity]//Flatten;
first=selected[[1]]; 
last=selected[[2]]; 
rmax = "MaxRadius"/.{opt}/.{"MaxRadius"-> \[Infinity]}; 
origin="Origin"/.{opt}/.{"Origin"-> {0, 0}}; 

d=SystemDialogInput["Directory", ToFileName[HomeDirectory[]], WindowTitle-> "Please select the folder that contains Tissue*.nb files.):"];
f=FileNames[ToFileName[d,"DTissue*.nb"]]; 
dPrint["Tissues: ", f]; 

dPrint["d=",d];
dPrint["f=", Short[f,5]]; 
results={}; 
j=0; 
While[Length[f]>0,
j++; 
file=First[f];
f=Rest[f]; 

If[j<first, Continue[]]; 
If[j>last, Break[]]; 

T=ToExpression[Get[file]]; 

(* identify which cels have middles beyond the known universe*)
R=(#<rmax)&/@(Norm/@((#-origin)&/@Centeroid[T])); 
c=Length/@Last/@TissueCells[T];
(* only pick cells inside the known universe *)

c=Pick[c, R];


ncells=Length[c]; 
bins=Table[0,{15}]; 
For[i=1,i<= ncells, i++, 
sides=Min[c[[i]],15]; 
bins[[sides]]++
];
hbin={Mean[1.0*c], StandardDeviation[1.0*c], bins}; 
AppendTo[results,hbin];
];
Return[results]; 
]



(* ::Input::Initialization:: *)
SimPlot[solution_?ListQ, var_, {tbegin_, tend_}, opt___?OptionQ]:= Module[{allvars, vars, s, n, timepoints, dt, fline, lines, colors, nvars},
n="Points"/.{opt}/.{"Points"-> 100};
dt=(tend-tbegin)/n;  
timepoints=1.0*Range[tbegin, tbegin+n*dt, dt]; 

s=Flatten[solution]; 
allvars = First/@s;
vars = Select[allvars, SameQ[#,var]\[Or]SameQ[Head[#], var]&];
nvars=Length[vars]; 
s=vars/.s;

fline [if_]:=Line[{#, if[#]}&/@timepoints]; 
lines = fline/@s;

colors = Hue/@((1.0/(nvars+1))*Range[0,nvars-1]);
{Length[colors], Length[lines]};

lines = MapThread[Graphics[{#1, #2}]&, {colors, lines}]; 
If[Length[lines]<1, lines={Graphics[]}]; 

With[{sopt=MyFilterOptions[Plot,opt]}, 
Show[lines, sopt, Frame-> True, 
AspectRatio-> 1, PlotLabel-> ToString[var]]
]
];


(* ::Input::Initialization:: *)
SimPlot[solution_?ListQ, {var__}, {tbegin_, tend_}, opt___?OptionQ]:= Module[{ plots, columns}, 
(* make the plots *)
plots = SimPlot[solution, #, {tbegin, tend}, opt]&/@{var};
If["Grid"/.{opt}/.{"Grid"-> False},
columns = "Columns"/.{opt}/.{"Columns"-> 3}; 
While[Mod[Length[plots], columns]!= 0,
AppendTo[plots, Graphics[{}]]
];
plots = Partition[plots, columns]; 
plots=GraphicsGrid[plots];
]; 
plots

]


(* ::Input::Initialization:: *)
SimPlot[solution_?ListQ, var_, opt___?OptionQ]:= Module[{ plot, columns, tbegin, tend}, 
(* make the plots *)
{tbegin,tend}=CommonTimeDomain[solution]; 
plot = SimPlot[solution, var, {tbegin, tend}, opt];
Return[plot];
]


(* ::Input::Initialization:: *)
SimPlot[solution_?ListQ, {tbegin_, tend_}, opt___?OptionQ]:= Module[{allvars,  plots, columns},
allvars = IndexedVarsInSolution[solution]; 
plots = SimPlot[solution, #, {tbegin, tend}, opt]&/@allvars;
If["Grid"/.{opt}/.{"Grid"-> False},
columns = "Columns"/.{opt}/.{"Columns"-> 3}; 
While[Mod[Length[plots], columns]!= 0,
AppendTo[plots, Graphics[{}]]
];
plots = Partition[plots, columns]; 
plots=GraphicsGrid[plots];
]; 
plots
]


(* ::Input::Initialization:: *)
SimPlot[solution_?ListQ, opt___?OptionQ]:= Module[{start, stop, times,p},

(* determine common time domain *)
times=CommonTimeDomain[solution];  
If[SameQ[times, $Failed], Print["Error: SimPlot: No common time domain."]; Return[$Failed]]; 
{start, stop}=times; 

p=SimPlot[solution, {start, stop}, opt]; 
Return[p]; 

];


(* ::Input::Initialization:: *)
MultiSimPlot[{solutions__?ListQ}, var_, opt___?OptionQ]:= Show[SimPlot[#,var, opt]&/@{solutions}]


(* ::Input::Initialization:: *)
SimPlot[var_Symbol, f_?StringQ, opt___?OptionQ]:= SimPlot[var, "InputFolder"-> f, opt]; 
SimPlot[var_Symbol, opt___?OptionQ]:= Module[{d,dPrint,SFiles,nS,dbg,plots,f,plot,s,needed, solutionsneeded,solutionFiles,nFiles},
dbg="Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[u___]:= If[dbg, Print["SimPlot: ", u]]; 

Block[{stuff}, 
d="InputFolder"/.{opt}/.{"InputFolder"-> "Unknown"}; 
If[ToString[d]=="Unknown", 
stuff = GetSimulationPoints[ opt]; 
If[SameQ[stuff, $Canceled], Return[$Canceled]]; 
,
stuff=GetSimulationPoints[d, opt];
]; 
needed = "needed"/.stuff;
SFiles="Solutions"/.stuff;
d="folder"/.stuff;
]; 


(* d=SystemDialogInput["Directory", ToFileName[HomeDirectory[]], WindowTitle\[Rule] "Please select the folder that contains Solution*.nb files.):"];*)

If[SameQ[d,$Canceled], Return[$Canceled]];
 
nS=Length[SFiles]; 
dPrint["nS:", nS]; 
If[nS==0, Print["No Simulation results found in "<>d]; Return[$Failed]]; 
plots={}; 

dPrint["needed: ", needed]; 

solutionsneeded = First/@needed; 
solutionFiles = SFiles[[solutionsneeded]]; 

nFiles=Length[needed]; 

Block[{i, fileName,times,solution, variables, VarNames, vofts, varvals, allvars,allvarvals},

vofts[v_,listOfTimes_]:= {#,v[#]}&/@times;

allvars={}; 
allvarvals={}; 

For[i=1,i<= nFiles, i++, 
fileName=solutionFiles[[i]];
times = Last[needed[[i]]]; 
dPrint[i," ", times, " ", fileName];

solution = GetSavedFile[fileName, "Solution"]; 
dPrint["solution: ", Short[solution, 5]]; 
variables = Select[First/@solution, Head[#]==var&]; 
VarNames = variables; 
allvars = Union[Join[allvars,VarNames]]; 

dPrint[Length[variables], " variables"];


varvals = (vofts[#,times]&/@VarNames)/.solution;

varvals = MapThread[Rule,{VarNames, varvals}]; 
dPrint[varvals];
AppendTo[allvarvals, varvals]; 

]; 
(*
Print[allvars];
Print[allvarvals]; 
*)

nvars = Length[allvars]; 
colors = Range[nvars]/(1.0*nvars+1); 

lines={}; 
For[i=1,i<= nvars, i++,
variable = allvars[[i]]; 
dPrint["variable = ", variable];
values = Join@@(variable/.allvarvals/.{variable-> {}});
dPrint["values=", values]; 
If[Length[values]>0, 
line = Graphics[{Hue[colors[[i]]], Line[values]}];
AppendTo[lines, line];
]
];
]; 


With[{sopt=MyFilterOptions[Plot,opt]}, 
g = Show[lines, sopt, Frame-> True,  PlotLabel-> ToString[var]]
];


Return[g]; 

While[Length[SFiles]>0,
f=First[SFiles];SFiles=Rest[SFiles]; 
dPrint["f: ", Short[f]]; 
s=GetSavedFile[f, "Solution"]; 
plot=SimPlot[s, var,opt, AspectRatio-> 1/GoldenRatio]; 
AppendTo[plots, plot]; 
]; 
Show[plots]
]



(* ::Input::Initialization:: *)
IndexedVarsInSolution[solution_]:= Module[{s, allvars, indexed, nonindexed},
s=Flatten[solution]; 
allvars = First/@s;
indexed = Select[allvars, IndexedQ]; 
nonindexed=Complement[allvars, indexed]; 
indexed = Union[Head/@indexed]; 
allvars = Flatten[{indexed, nonindexed}];
Return[allvars]; 
];


(* ::Input::Initialization:: *)
CommonTimeDomain[solution_]:= 
Module[{s, domains, maxs, mins, start, stop}, 
s=Last/@Flatten[solution];
domains = InterpolatingFunctionDomain/@s;
domains=Flatten/@domains;
domains=Union[domains]; 
domains = Transpose[domains];
{mins, maxs}=domains; 
start = Max[mins]; 
stop = Min[maxs]; 
If[start > stop, Return[$Failed]]; 
Return[{start, stop}];
]


(* ::Input::Initialization:: *)
IndexedQ[var_?AtomQ]:= False; 
IndexedQ[var_[index__]]:= True; 
IndexedQ[x___]:= False;


(* ::Input::Initialization:: *)
ShowResults[d_,n_, specs_, opt___?OptionQ]:=Module[{s,spec,g,SPECS,time, var,vmin,vmax,cmin,cmax, p,plabel,f,S, T},
s=IntegerString[n,10,4];
f=ToFileName[d,"DTissue"<>s<>".nb"];
AbortIf[Not[FileExistsQ[f]], "Tissue file "<>f<>" not found."];

T=ToExpression[Get[f]];
AbortIf[Not[DTissueQ[T]],f<>" is not a valid tissue file."];

S=ToFileName[d,"Solution"<>s<>".nb"]; 
AbortIf[Not[FileExistsQ[S]], "Solution file "<>S<>" not found."];
S=Get[S]; 
g={};
SPECS=specs;
time=Last[CommonTimeDomain[S]]; 

While[Length[SPECS]>0,
spec=First[SPECS];
SPECS=Rest[SPECS]; 
AbortIf[!ListQ[spec], "spec must be a list"]; 
AbortIf[Length[spec]!= 3, "spec must have length 3"]; 
AbortIf[!ListQ[spec[[2]]], "spec[[2]] (colors) must be a list"]; 
AbortIf[!ListQ[spec[[3]]], "spec[[3]] (values) must be a list"]; 
AbortIf[Length[spec[[2]]]!= 2, "spec[[2]] (colors) must be a list of length 2"]; 
AbortIf[Length[spec[[3]]]!= 2, "spec[[2]] (values) must be a list of length 2"]; 

{var, {cmin, cmax}, {vmin,vmax}}=spec;
plabel = ToString[var]<>"("<>ToString[time]<>") in ["<>ToString[vmin]<>","<>ToString[vmax]<>"]";
p=SimShow[S, var, time, T, {cmin,cmax}, {vmin,vmax}, PlotLabel-> plabel, opt]; 
AppendTo[g,p];

];
g
]



(* ::Input::Initialization:: *)
SimShow[solution_,time_,tissue_?DTissueQ,opt___?OptionQ]:=Module[{numbers,T,c,toDynamicNumberRules, toStaticNumberRules},
T=DTissue2Tissue[tissue,solution,time];

numbers="CellNumbers"/.{opt}/.{"CellNumbers"->False};


c=First/@TissueCells[tissue]; 
toDynamicNumberRules=MapThread[Rule,{Range[Length[c]],c}];toStaticNumberRules=Reverse/@toDynamicNumberRules;

If[numbers,
numbers=First/@TissueCells[tissue];
ShowTissue[T, "CellNumbers"->numbers, "ToStatic"->toStaticNumberRules, "ToDynamic"->toDynamicNumberRules,   opt];
,
ShowTissue[T, "ToStatic"->toStaticNumberRules, "ToDynamic"->toDynamicNumberRules,opt]
]
];


(* ::Input::Initialization:: *)
SimShow[solution_,variable_,time_,tissue_?DTissueQ,{rgbfrom_RGBColor,rgbto_RGBColor},{vmin_,vmax_},opt___?OptionQ]:=Module[{numbers,T,c,toDynamicNumberRules, toStaticNumberRules},
T=DTissue2Tissue[tissue,solution,time];
numbers="CellNumbers"/.{opt}/.{"CellNumbers"->False};

c=First/@TissueCells[tissue]; toDynamicNumberRules=MapThread[Rule,{Range[Length[c]],c}];toStaticNumberRules=Reverse/@toDynamicNumberRules;

If[numbers,
numbers=First/@TissueCells[tissue];
SimShow[solution,variable,time,T,{rgbfrom,rgbto},{vmin,vmax},"CellNumbers"->numbers, "ToStatic"->toStaticNumberRules, "ToDynamic"->toDynamicNumberRules,opt],
SimShow[solution,variable,time,T,{rgbfrom,rgbto},{vmin,vmax}, "ToStatic"->toStaticNumberRules, "ToDynamic"->toDynamicNumberRules,opt]
]
];


(* ::Input::Initialization:: *)
SimShow[solution_,variable_, time_,  tissue_?TissueQ, {rgbfrom_RGBColor, rgbto_RGBColor}, {vmin_, vmax_}, opt___?OptionQ]:= Module[{allvars, s, n, colors, g, dbg, dprint, cellstyles, arglists, cellvars, cellnums, edgevars, celledgepairs,cellif, edgeif,cellcolors,edgecolors,cellvals,edgevals,ced,nextdata, hue,huefrom,hueto},

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dprint[x___]:= If[dbg, Print["SimShow(1): ", x]]; 
dprint["**NEW*** SimShow(1)"]; 

n=NTissueCells[tissue]; 
s=Flatten[solution];  

(* get all indexed variables of specified name *)
allvars = First/@s;
allvars = Select[allvars, SameQ[Head[#], variable]&];
dprint["allvars: ", Short[allvars]]; 
If[Length[allvars]<1, Print["Error: SimShow: ", variable, " not found."]; Return[$Failed]]; 
arglists = allvars/.{variable-> List};
dprint["arglists:", arglists]; 
cellvars=Pick[allvars, Length[#]==1&/@arglists];
cellnums=First/@Select[arglists, Length[#]==1&];  
edgevars=Pick[allvars, Length[#]==2&/@arglists];
celledgepairs=Select[arglists, Length[#]==2&]; 
dprint["cellvars=", cellvars, " nums=", cellnums];
dprint ["edgevars=",edgevars, " nums=", celledgepairs]; 

cellif =cellvars/.s;
edgeif = edgevars/.s;
cellvals = #[time]&/@cellif; 
edgevals=#[time]&/@edgeif;
dprint["cellvals: ", cellvals]; 
dprint["edgevals: ", edgevals]; 



dprint["Length[s]:", Length[s]]; 
dprint["s: ", Short[s]]; 
dprint["{vmin, vmax}:", {vmin, vmax}]; 
dprint["{rgbfrom,rgbto}:", {rgbfrom, rgbto}]; 

hue = "Hues"/.{opt}/.{"Hue"-> False};
If[ListQ[hue],
If[Length[hue]==2,
{huefrom, hueto}=hue;
hue=True;,
hue=False
],
hue=False
];
If[hue,
cellcolors = HueInterpolate[#, {vmin, vmax}, {huefrom, hueto}]&/@cellvals;
edgecolors = HueInterpolate[#, {vmin, vmax}, {huefrom, hueto}]&/@edgevals;
,
cellcolors = RGBInterpolate[#, {vmin, vmax}, {rgbfrom, rgbto}]&/@cellvals;
edgecolors = RGBInterpolate[#, {vmin, vmax}, {rgbfrom, rgbto}]&/@edgevals;
];

ced={}; 
For[i=1,i<=Length[celledgepairs],i++,
nextdata=Append[celledgepairs[[i]],edgecolors[[i]]]; 
AppendTo[ced, nextdata]; 
];
dprint["ced:", ced]; 



dprint["cellcolors: ", cellcolors];
dprint["edgecolors: ", edgecolors];  
dprint["opt: ", opt]; 

cellstyles = "CellStyle"/.{opt}/.{"CellStyle"-> {}}; 
dprint["Additional input cell styles: ", cellstyles]; 
If[!ListQ[cellstyles], cellstyles={cellstyles}]; 

(* additional user specified cell styles *)

If[Length[cellstyles]>0,  

If[Length[cellstyles]==n, 
(* a separate style for each cell *) 
cellstyles = List/@cellstyles;
cellcolors = List/@cellcolors; 
cellcolors = {cellcolors, cellstyles}//Transpose; 
cellcolors = Flatten/@cellcolors
,
(* or a global style to be applied to each cell *)
dprint["Global style"]; 
cellcolors = List/@cellcolors; 
cellcolors = Append[cellstyles, #]&/@colors
];
cellcolors = Flatten/@colors

];

dprint["CellColors: ", cellcolors];

dprint["tissue: ", tissue];


g=ShowTissue[tissue, "CellStyles"-> cellcolors,"EdgeCellPairs"-> ced,  opt];

dprint["g:", g]; 

Return[g]; 

]; 




(* ::Input::Initialization:: *)
SimShow[solution_,variable_, time_,  tissue_?ISTissue, {gfrom_GrayLevel, rgbto_RGBColor}, {vmin_, vmax_}, opt___?OptionQ]:=SimShow[solution,variable,time,tissue, {ColorConvert[gfrom,"RGB"],rgbto},{vmin,vmax},opt];
SimShow[solution_,variable_, time_,  tissue_?ISTissue, {rgbfrom_RGBColor, gto_GrayLevel}, {vmin_, vmax_}, opt___?OptionQ]:=SimShow[solution,variable,time,tissue,{rgbfrom,ColorConvert[gto,"RGB"]},{vmin,vmax},opt];
SimShow[solution_,variable_, time_,  tissue_?ISTissue, {gfrom_GrayLevel, gto_GrayLevel}, {vmin_, vmax_}, opt___?OptionQ]:=SimShow[solution,variable,time,tissue,{ColorConvert[gfrom,"RGB"],ColorConvert[gto,"RGB"]},{vmin,vmax},opt];


(* ::Input::Initialization:: *)
SimShow[solution_,variable_,time_,tissue_?DTissueQ,{rgbfrom_RGBColor,rgbto_RGBColor},{vmin_,vmax_},{xmin_,xmax_},{ymin_,ymax_},opt___?OptionQ]:=Module[
{numbers,T, toDynamicNumberRules, toStaticNumberRules},
T=DTissue2Tissue[tissue,solution,time];
numbers="CellNumbers"/.{opt}/.{"CellNumbers"-> False}; 

c=First/@TissueCells[tissue];toDynamicNumberRules=MapThread[Rule,{Range[Length[c]],c}];toStaticNumberRules=Reverse/@toDynamicNumberRules;


If[numbers,
numbers=First/@TissueCells[tissue];
SimShow[solution,variable,time,T,{rgbfrom,rgbto},{vmin,vmax},{xmin,xmax},{ymin,ymax},"CellNumbers"-> numbers,"ToStatic"->toStaticNumberRules,"ToDynamic"->toDynamicNumberRules, opt]
,
SimShow[solution,variable,time,T,{rgbfrom,rgbto},{vmin,vmax},{xmin,xmax},{ymin,ymax},"ToStatic"->toStaticNumberRules,"ToDynamic"->toDynamicNumberRules,opt]
]
]; 


(* ::Input::Initialization:: *)
SimShow[solution_,variable_, time_,  tissue_?TissueQ, {rgbfrom_RGBColor, rgbto_RGBColor}, {vmin_, vmax_}, 
{xmin_, xmax_}, {ymin_, ymax_}, 
opt___?OptionQ]:= Module[
{title, xxmax, legend, legendstyle, g, lxmin, lxmax, lymin, lymax, lbox, lboxcolo ,dbg, dprint, lboxcolor},



dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dprint[x___]:= If[dbg, Print["SimShow(2): ", x]]; 

dprint["SimShow(2)"]; 

 title="Title"/.{opt}/.{"Title"-> 
ToString[variable]<>"["<>ToString[NumberForm[time,{10,2}]]<>"]"};


xxmax = xmax + .2*(xmax-xmin); 

legendstyle = "LegendStyle"/.{opt}/.{"LegendStyle"-> {}}; 

lxmin = xmax+ .05(xmax-xmin); 
lxmax =xmax+.15(xmax-xmin);
lymin=ymin+.25(ymax-ymin); 
lymax = ymin +.75(ymax-ymin); 

legend = ColorBlendRectangle[
{lxmin,lymin}, {lxmax,lymax }, {rgbfrom, rgbto}, {NumberForm[vmin,3], NumberForm[vmax,3]}, legendstyle]; 

(* box the legend, the same color as the Cell Boundary if not specified*)

lbox = Line[{{lxmin, lymin}, {lxmax, lymin}, {lxmax, lymax}, {lxmin, lymax}, {lxmin, lymin}}]; 
lboxcolor="LegendBoundary"/.{opt}/.{"LegendBoundary"-> "BoundaryStyle"};
lboxcolor =lboxcolor/.{opt}/.{"BoundaryStyle"-> Black}; 
If[ToString[lboxcolor]=="None", lboxcolor=Black]; 
lbox = Graphics[{lboxcolor, lbox}//Flatten]; 
dprint["lboxcolor: ", lboxcolor]; 

g= SimShow[solution, variable, time, tissue, {rgbfrom, rgbto}, {vmin, vmax}, 
opt, 
PlotRange-> {{xmin, xxmax}, {ymin, ymax}}
(* , PlotLabel\[Rule] title *)
];
g=Show[g]; 
dprint[g]; 
dprint[legend];
dprint[lbox]; 
g= Show[g, legend, lbox];
dprint[g]; 
Return[g]; 
]


(* ::Input::Initialization:: *)
SimShow[solution_,variable_, time_,  tissue_?ISTissue, {gfrom_GrayLevel, rgbto_RGBColor}, {vmin_, vmax_},{xmin_, xmax_}, {ymin_, ymax_}, opt___?OptionQ]:=SimShow[solution,variable,time,tissue, {ColorConvert[gfrom,"RGB"],rgbto},{vmin,vmax},{xmin,xmax}, {ymin,ymax}, opt];
SimShow[solution_,variable_, time_,  tissue_?ISTissue, {rgbfrom_RGBColor, gto_GrayLevel}, {vmin_, vmax_},{xmin_, xmax_}, {ymin_, ymax_},  opt___?OptionQ]:=SimShow[solution,variable,time,tissue,{rgbfrom,ColorConvert[gto,"RGB"]},{vmin,vmax},{xmin,xmax}, {ymin,ymax},opt];
SimShow[solution_,variable_, time_,  tissue_?ISTissue, {gfrom_GrayLevel, gto_GrayLevel}, {vmin_, vmax_}, {xmin_, xmax_}, {ymin_, ymax_}, opt___?OptionQ]:=SimShow[solution,variable,time,tissue,{ColorConvert[gfrom,"RGB"],ColorConvert[gto,"RGB"]},{vmin,vmax},{xmin,xmax}, {ymin,ymax},opt];


(* ::Input::Initialization:: *)
SimShow[solution_,variable_,time_,tissue_?DTissueQ,{rgbfrom_RGBColor,rgbto_RGBColor},threshold_,opt___?OptionQ]:=Module[{numbers,T},T=DTissue2Tissue[tissue,solution,time];
numbers="CellNumbers"/.{opt}/.{"CellNumbers"->False};
If[numbers,numbers=First/@TissueCells[tissue];
SimShow[solution,variable,time,T,{rgbfrom,rgbto},threshold,"CellNumbers"->numbers,opt],SimShow[solution,variable,time,T,{rgbfrom,rgbto},threshold,opt]]];


(* ::Input::Initialization:: *)
SimShow[opt___?OptionQ]:=Module[{T,TS,S,SS,f,folder, solution,sequence, tissue,time, ctd,
DefaultMinColor=Purple,
DefaultMaxColor=Orange,
DefaultColors, colors,range, var, 
xrange, yrange, legend, hassolution, hastissue, havefiles
},
DefaultColors={DefaultMinColor,DefaultMaxColor}; 


(* options *)
legend = "Legend"/.{opt}/.{"Legend"-> True}; 
var="Variable"/.{opt}/.{"Variable"-> None};
AbortIf[ToString[var]=="None", "A Variable must be specified."];  
time ="Time"/.{opt}/.{"Time"-> 0};
range="Values"/.{opt}/.{"Values"-> {}}; 
solution = "Solution"/.{opt}/.{"Solution"-> "Unknown"}; 

hassolution=False;
If[FileExistsQ[solution],
folder=FileNameDrop[solution,-1];
S=GetSavedFile[solution,"Solution"];
hassolution=True;
,
AbortIf[solution != "Unknown", "Unable to find the file "<>ToString[solution]]; 
];

tissue = "Tissue"/.{opt}/.{"Tissue"-> "Unknown"};
hastissue=False;
If[FileExistsQ[tissue],
T=ToExpression[Get[tissue]];
hastissue=True;
,
AbortIf[tissue != "Unknown", "Unable to find the file "<>ToString[solution]]; 
]; 


havefiles = hassolution \[And] hastissue;
AbortIf[hassolution \[And]Not[hastissue], "Tissue File must be specified when the solution is specified."];
AbortIf[hastissue \[And] Not[hassolution], "Solution File must be specified when the tissue is specified."]; 

colors = "Colors"/.{opt}/.{"Colors"-> DefaultColors}; 
colors = Flatten[{colors}]; 
Switch[Length[colors],
0, colors = DefaultColors,
1, colors = Append[colors, DefaultMaxColor], 
2, True,
_ , colors=Take[colors, 2]
]; 


(* find a folder *)

If[Not[havefiles], 
f=If[ToString[$SIMDIR]=="$SIMDIR",  
Quiet[NotebookDirectory[]], $SIMDIR]; 
If[ToString[f]=="$Failed", f=""]; 
f=ToFileName[f, "Solution*.*"];
S=SystemDialogInput["FileOpen", f,WindowTitle-> "Select a Solution"];
AbortIf[ToString[S]=="$Canceled", "$Canceled"]; 
solution=FileNameTake[S,-1];
folder=FileNameDrop[S,-1];

(* check to make sure a solution file was selected *)

AbortIf[StringTake[solution,-3]!= ".nb" \[And]StringTake[solution,-3]!= ".mx", "Solution must have the form Solutionjjjj.nb and not '"<>solution<>"'"];
AbortIf[StringTake[solution,8]!= "Solution", "Solution must have the form Solutionjjjj.nb or .mx and not "<>solution<>"'"];

(* locate the appropriate tissue file *)

sequence=StringDrop[StringDrop[solution,-3],8];
tissue=ToFileName[folder, "DTissue"<>sequence<>".nb"]; 
AbortIf[Not[FileExistsQ[tissue]], "Unable to find tissue file '"<>tissue<>"'"];
solution=S; 

(* import the data *)

T=GetSavedFile[folder,"Tissue",ToExpression[sequence], True]; 
S=GetSavedFile[folder, "Solution", ToExpression[sequence], True];
]; 

(* determine the simulation time *)

ctd = CommonTimeDomain[S]; 
If[Not[IntervalMemberQ[Interval[ctd],time]], time=ctd[[2]]];  

If[Length[range]!= 2, range=SimRange[S,var,time]]; 
AbortIf[ToString[range]=="$Failed", "Variable "<>ToString[var]<>" not found."]; 

{xrange, yrange} = AutoScaleTemplate[DTissue2Tissue[T]]; 


If[legend, 
SimShow[S, var, time,T,colors,range, xrange, yrange, opt],
SimShow[S, var, time, T, colors, range, opt]
]
];

SimShow[variable_, opt___?OptionQ]:= SimShow["Variable"-> variable, opt]


(* ::Input::Initialization:: *)
SimShow[anythingElse___]:= (Print["Unexpected Input for SimShow:",Short[{anythingElse}, 5]]); 


(* ::Input::Initialization:: *)
HueInterpolate[x_, {xmin_, xmax_}, {hue1_, hue2_}]:= Module[{h1, h2, tmp,m},
(* limit to [0, 1] *)
If[xmin>= xmax, Return[Hue[(hue1+hue2)/2.0]]]; 

h1=Max[0.0, Min[hue1,hue2]];
h2=Min[1.0, Max[hue1,hue2]];
(* Make sure slope is as requested! *)
If[hue2< hue1, 
tmp=h1; h1=h2; h2=tmp]; 

m=(h2-h1)/(xmax-xmin); 

Return[Hue[h1+m*(x-h1)]]

]


(* ::Input::Initialization:: *)
RGBInterpolate[x_, {xmin_, xmax_}, {RGB1_, RGB2_, RGBS__}]:= Module[{colors, nc, y,r1, r2, X, X1, X2, C1, C2},
colors={RGB1, RGB2, RGBS};
nc = Length[colors];  
X=Min[Max[x, xmin], xmax]; 
y=1+Round[(X-xmin)*(nc-2)/(xmax-xmin)]; 
r1 = y; 
r2=r1+1;
C1=colors[[r1]]; 
C2=colors[[r2]]; 

X1 = ((r1-1)xmax + (nc-r1-1)*xmin)/(nc-2);
X2 = ((r2-1)xmax + (nc-r2-1)*xmin)/(nc-2);
RGBInterpolate[x, {X1, X2}, {C1,C2}]
]


(* ::Input::Initialization:: *)
RGBErr=0; 
RGBInterpolate[x_, {xmin_, xmax_}, {RGBmin_RGBColor, RGBmax_RGBColor}]:=Module[{X, y, RGB, y1, y2, RGBMax=3},
RGB[RGBColor[r_, g_, b_]]:= {r, g, b};
RGB[q___]:= (Print["Error: RGBInterpolate: Not an RGBColor: ", q, " Using Black."];{0,0,0} ); 
y1=RGB[RGBmin]; y2=RGB[RGBmax]; 
{y1, y2};

If[xmin>= xmax, 
y=RGBColor@@((y1+y2)/2);
RGBErr++; 
If[RGBErr<= RGBMax,
Print["Warning: RGBInterpolate: xmax = ", xmax, ", must be < xmin = ", xmin, ": using median value of ", y]; 
If[RGBEr>= RGBMax, Print["Further messages will be suppressed."]]; 
]; 
Return[y];  
]; 

X=Min[Max[x, xmin], xmax]; 

y = y1 +(X-xmin)/(xmax-xmin) (y2-y1);
Return[RGBColor@@y]; 

];
RGBInterpolate[x___]:= (Print["Error: Expecting RGBInterpolate[x, {xmin, xmax}, {rgbmin, rgbmax}], not ", x]; $Failed); 


(* ::Input::Initialization:: *)
RGBThreshold[x_,  threshold_, {RGBmin_RGBColor, RGBmax_RGBColor}] := If[x>= threshold, RGBmax, RGBmin];

RGBThreshold[x__]:= (Print["Error: Expecting RGBThreshold[x, {xmin, xmax}, {rgbmin, rgbmax}], not ", x]; $Failed); 


(* ::Input::Initialization:: *)
ColorBlendRectangle[{xmin_, ymin_}, {xmax_, ymax_}, {rgbfrom_, rgbto_, rgbs__}, {textmin_:"Min", textmax_:"Max"}, textstyle_:{}]:= Module[
{n, rect, colors, ncolors, deltay,htotal, h, y1s, y2s, boxes, tmin, tmax, r}, 
colors={rgbfrom, rgbto, rgbs};
ncolors=Length[colors]; 
htotal = ymax - ymin;
h = htotal/(ncolors-1); 
n=100/(1+ncolors) + 1;

rect[{x1_,y1_}, {x2_,y2_}, {C1_, C2_}]:= Module[{rnext,y, r, c},
deltay=1.0*(y2-y1)/n; 
y=y1;
r={}; 
While[y<ymax, 
rnext = Rectangle[{x1, y}, {x2, y+deltay}]; 
c=RGBInterpolate[y, {y1, y2} ,{C1, C2}]; 
rnext = Graphics[{c, rnext}]; 
AppendTo[r, rnext]; 
y=y+deltay;
]; 
r
]; 

colors = Partition[colors, 2, 1]; 
y1s = Table[ymin+i*h, {i, 0, ncolors-2}]; 
y2s = Table[ymin+i*h, {i, 1, ncolors-1}]; 
boxes = MapThread[rect[{xmin, #1}, {xmax, #2}, #3]&, {y1s, y2s, colors}]; 

tmin = Style[textmin, textstyle]; 
tmax = Style[textmax, textstyle]; 
AppendTo[boxes, Graphics[Text[tmin, {0.5(xmin+xmax), ymin}, {0,1}]]]; 
AppendTo[boxes, Graphics[Text[tmax, {0.5(xmin+xmax), ymax}, {0,-1}]]]; 
r=Show[boxes]; 
Return[r]; 

];



(* ::Input::Initialization:: *)
ColorBlendRectangle[{xmin_, ymin_}, {xmax_, ymax_}, {rgbfrom_, rgbto_}, {textmin_:"Min", textmax_:"Max"}, textstyle_:{}]:= Module[{n, deltay, y, r, rnext, color, tmin, tmax}, 
n=100;
deltay=1.0*(ymax-ymin)/n; 
r={}; 
y=ymin; 
While[y<ymax,
rnext = Rectangle[{xmin, y}, {xmax, y+deltay}]; 
color =RGBInterpolate[y, {ymin, ymax}, {rgbfrom, rgbto}]; 
rnext = Graphics[{color, rnext}]; 
AppendTo[r, rnext]; 
y=y+deltay;
]; 
tmin = Style[textmin, textstyle]; 
tmax = Style[textmax, textstyle]; 
AppendTo[r, Graphics[Text[tmin, {0.5(xmin+xmax), ymin}, {0,1}]]]; 
AppendTo[r, Graphics[Text[tmax, {0.5(xmin+xmax), ymax}, {0,-1}]]]; 
r=Show[r]; 
Return[r]; 
];



(* ::Input::Initialization:: *)
SimShowFinal[solution_,variable_,tissue_?DTissueQ,{mincolor_,maxcolor_},opt___?OptionQ]:=Module[{numbers,T,time,times},
times=CommonTimeDomain[solution];
time=Last[times];
T=DTissue2Tissue[tissue,solution,time];

numbers="CellNumbers"/.{opt}/.{"CellNumbers"->False};
If[numbers,numbers=First/@TissueCells[tissue];
SimShowFinal[solution,variable,T,{mincolor,maxcolor},"CellNumbers"->numbers,opt],SimShowFinal[solution,variable,T,{mincolor,maxcolor},opt]]];


(* ::Input::Initialization:: *)
SimShowFinal[solution_,variable_,tissue_?DTissueQ,{mincolor_,maxcolor_},threshold_, opt___?OptionQ]:=Module[{numbers,T,time,times},
times=CommonTimeDomain[solution];
time=Last[times];
T=DTissue2Tissue[tissue,solution,time];
numbers="CellNumbers"/.{opt}/.{"CellNumbers"->False};
If[numbers,numbers=First/@TissueCells[tissue];
SimShowFinal[solution,variable,T,{mincolor,maxcolor},threshold, "CellNumbers"->numbers,opt],SimShowFinal[solution,variable,T,{mincolor,maxcolor},threshold, opt]]];


(* ::Input::Initialization:: *)
SimShowFinal[sim_, variable_, template_, {mincolor_, maxcolor_},  
 opt___?OptionQ]:= Module[
{times, xrange, yrange, varmin, varmax, tmax, p, dbg, dprint}, 

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dprint[x___]:= If[dbg, Print["SimShowFinal: ", x]]; 

times = CommonTimeDomain[sim];
dprint["times: ", times]; 

tmax = Last[times]; 
dprint["tmax: ", tmax]; 

{xrange, yrange} = AutoScaleTemplate[template];
dprint["spatial range: ", {xrange, yrange}]; 

{varmin, varmax}=SimRange[sim, variable, tmax]; 
dprint["Variable Range: ", {varmin, varmax}]; 

p=SimShow[sim, variable, tmax, template, {mincolor, maxcolor}, {varmin, varmax}, xrange, yrange, opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Gray}]; 

Return[p]; 
];

SimShowFinal[sim_, variable_, template_, {mincolor_, maxcolor_},  
threshold_?NumericQ, opt___?OptionQ]:= Module[
{times, xrange, yrange, varmin, varmax, tmax, p, dbg, dprint}, 

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dprint[x___]:= If[dbg, Print["SimShowFinal: ", x]]; 

times = CommonTimeDomain[sim];
dprint["times: ", times]; 

tmax = Last[times]; 
dprint["tmax: ", tmax]; 

{xrange, yrange} = AutoScaleTemplate[template];
dprint["spatial range: ", {xrange, yrange}]; 

p=SimShow[sim, variable, tmax, template, {mincolor, maxcolor}, threshold,  opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Gray}]; 

Return[p]; 
];



(* ::Input::Initialization:: *)
SimShowAt[solution_,variable_,time_,tissue_?DTissueQ,{mincolor_,maxcolor_},{vmin_,vmax_},opt___?OptionQ]:=Module[{numbers,T},T=DTissue2Tissue[tissue,solution,time];
numbers="CellNumbers"/.{opt}/.{"CellNumbers"->False};
If[numbers,numbers=First/@TissueCells[tissue];
SimShowAt[solution,variable,time,T,{mincolor,maxcolor},{vmin,vmax},"CellNumbers"->numbers,opt],SimShowAt[solution,variable,time,T,{mincolor,maxcolor},{vmin,vmax},opt]]];


(* ::Input::Initialization:: *)
SimShowAt[sim_, variable_,time_,  template_, {mincolor_, maxcolor_},{varmin_, varmax_},   opt___?OptionQ]:= Module[
{times, xrange, yrange,   p, dbg, dprint}, 

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dprint[x___]:= If[dbg, Print["SimShowFinal: ", x]]; 

times = CommonTimeDomain[sim];
dprint["times: ", times]; 

If[time > times[[2]] \[Or] time <times[[1]], Print["Error: SimShowAt: time ", time, " not in range ", times]; 
Return[$Failed]]; 

{xrange, yrange} = AutoScaleTemplate[template];
dprint["spatial range: ", {xrange, yrange}]; 

p=SimShow[sim, variable, time, template, {mincolor, maxcolor}, {varmin, varmax}, xrange, yrange, opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Gray}]; 

Return[p]; 
]



(* ::Input::Initialization:: *)
SimShowAt[solution_,variable_,time_,tissue_?DTissueQ,{mincolor_,maxcolor_},opt___?OptionQ]:=Module[{numbers,T},T=DTissue2Tissue[tissue,solution,time];
numbers="CellNumbers"/.{opt}/.{"CellNumbers"->False};
If[numbers,numbers=First/@TissueCells[tissue];
SimShowAt[solution,variable,time,T,{mincolor,maxcolor},"CellNumbers"->numbers,opt],SimShowAt[solution,variable,time,T,{mincolor,maxcolor},opt]]];


(* ::Input::Initialization:: *)
SimShowAt[sim_, variable_,time_,  template_, {mincolor_, maxcolor_},  opt___?OptionQ]:= Module[
{times,  varmin, varmax,  p}, 

times = CommonTimeDomain[sim]; 

If[time > times[[2]] \[Or] time <times[[1]], Print["Error: SimShowAt: time ", time, " not in range ", times]; 
Return[$Failed]]; 

{varmin, varmax}=SimRange[sim, variable, time];

p=SimShowAt[sim, variable,time,  template, {mincolor, maxcolor},{varmin, varmax},   opt]; 

Return[p]; 
]



(* ::Input::Initialization:: *)
ShowCellExtensions[S_, DT_DTissue, PD_, t_, opt___?OptionQ]:= Module[{n, T1,vals, PDUNITX, PDUNITY,cellcenters},
n=NTissueCells[DT]; 
T1=DTissue2Tissue[DT,S,t];
PDUNITX=ToExpression[ToString[PD]<>"X"];
PDUNITY=ToExpression[ToString[PD]<>"Y"];
vals=({PDUNITX[#][t],PDUNITY[#][t]}&/@Range[n])/.S/.{t->50};
AbortIf[Length[vals]<1, "Error: ShowCellExtensions: Values for Principal Direction Unit Vectors Not Found in Solution."]; 
cellcenters=Centroid[T1];
With[{gopt=MyFilterOptions[Graphics,opt]},
Show[ShowTissue[T1,opt],Graphics[MapThread[Line[{#1,#2}]&,{cellcenters-.5 vals,cellcenters+.5 vals}]],
gopt]
]
]


(* ::Input::Initialization:: *)
SimInterpolate[sim_, var_, time_]:= Module[{allvars, s, vals, timerange},
timeRange=CommonTimeDomain[sim]; 
If[time>timeRange[[2]] \[Or] time<timeRange[[1]], Print["Error: SimRange: requested time ", time, " is not in the data range of ", timeRange]; Return[$Failed]]; 

s=Flatten[sim]; 
(* get all indexed variables of specified name *)
allvars = First/@s;
allvars = Select[allvars, SameQ[Head[#], var]&];
If[Length[allvars]<1, Print["Error: SimInterpolate: ", var, " not found."]; Return[$Failed]]; 
vals=(#[time]&)/@(allvars/.s)
]


(* ::Input::Initialization:: *)
SimRange[sim_, var_, time_?NumericQ]:= Module[{vals, range},
vals = SimInterpolate[sim, var, time]; 
If[SameQ[vals, $Failed], Return[$Failed]]; 
range={Min[vals], Max[vals]};
Return[range]; 
]


(* ::Input::Initialization:: *)
SimRange[sim_, var_, {tstart_?NumericQ, tend_?NumericQ, tdelta_?NumericQ}]:= Module[{s},
s=SimRange[sim, var, #]&/@Range[tstart, tend, tdelta]; 
s=Transpose[s]; 
s={Min[s[[1]]], Max[s[[2]]]}; 
Return[s]; 
];

SimRange[x___]:= (Print["Error: Expecting SimRange[sim, var, time] or SimRange[sim, var, {tstart, tend, tdelta}"]; $Failed); 


(* ::Input::Initialization:: *)
WTAAnimate[vars_?ListQ, varcolors_?ListQ, opt___?OptionQ]:= Module[{d,dbg=False, dPrint,TFiles,SFiles, nT,nS,n,GetTimeDomainFromFile, timespans,i,dt, TSFile, nTimespans,plottimes,frames,interval,tstart,tend,times, tstarts,whichinterval,whichtime,jnext,timespan,timeshere,j,needed, colors,values,pix,need,T,S,dmovie,iframe,time,pixfile,type,runstring,error,rate,imagetype,label,showtime,framelabel,isize, cwd,themovie,TheMovieFile, TNOW},

dbg = "debug"/.{opt}/.{"debug"-> False}; 
dPrint[u___]:= If[dbg, Print["SimMaxAnimate: ", u]]; 


dPrint["vars: ", vars];
dPrint["colors:", varcolors]; 
AbortIf[Length[vars]!= Length[varcolors], "SimMaxAnimate: Number of colors is different from number of variables."]; 


cwd = Directory[]; 
label = "Label"/.{opt}/.{"Label"-> ""};

Block[{stuff}, 
stuff = GetSimulationPoints[ opt]; 
If[SameQ[stuff, $Canceled], Return[$Canceled]]; 
needed = "needed"/.stuff;
TFiles = "Tissues"/.stuff;
SFiles="Solutions"/.stuff;
d="folder"/.stuff;
]; 

dPrint["TFiles: ", Short[TFiles,3]]; 
dPrint["SFiles: ", Short[SFiles,3]]; 
dPrint["needed: ", needed];



showtime="ShowTime"/.{opt}/.{"ShowTime"-> True};
isize = "ImageSize"/.{opt}/.{"ImageSize"-> 1024};  
(* movie type *)
type = "Type"/.{opt}/.{"Type"-> ".mov"}; 
If[Not[StringQ[type]], type=ToString[type]]; 
If[StringTake[type,1]!= ".", type="."<>type]; 
(* image type *)
imagetype = "ImageType"/.{opt}/.{"ImageType"-> ".jpg"}; 
If[Not[StringQ[imagetype]], imagetype=ToString[imagetype]]; 
If[StringTake[imagetype,1]!= ".", imagetype="."<>imagetype]; 

(* frame rate *) 
rate = "FrameRate"/.{opt}/.{"FrameRate"-> 4}; 
If[Not[IntegerQ[rate]], Print["FrameRate must be an integer."]; rate=4]; 
rate = ToString[rate]; 
dmovie=ToFileName[d,"Movie-WTA-"];
dmovie=createUniqueFolder[dmovie]; 
Print["Saving files to ",dmovie]; 

iframe=1; 
While[Length[needed]>0,
need = First[needed]; 
needed=Rest[needed]; 
i = First[need];
timeshere = i/.need; 
dPrint["getting ", TFiles[[i]]]; 
T =ToExpression[Get[ TFiles[[i]]]]; 

dPrint["getting: ", SFiles[[i]]]; 
S = Get[SFiles[[i]]]; 

While[Length[timeshere]>0,
time = First[timeshere]; 
timeshere = Rest[timeshere]; 
framelabel = label;
If[showtime,
framelabel = framelabel <>" ("<>ToString[time]<>")";
]; 

dPrint["... insert code to handle solution at time ",time ]; 

TNOW=DTissue2Tissue[T,S,time];

pix=WTAShow[TNOW,  S,time,  vars, varcolors,opt];
 
pixfile = ToFileName[dmovie,"FRAME"<>IntegerString[iframe,10,4]<>imagetype];
Export[pixfile,pix,ImageSize-> {isize,isize}]; 

iframe = iframe+1; 
];
];

SetDirectory[dmovie]; 
themovie = "Movie"<>type;
runstring="ffmpeg -sameq -r "<>rate<>" -i 'FRAME%4d"<>imagetype<>"' '"<>themovie<>"'";
Print[runstring]; 
error=Run[runstring]; 
If[error!= 0, Print["ffmpeg return code is: ", error]]; 
TheMovieFile=FileNames[ToFileName[dmovie,themovie]];

SetDirectory[cwd];
Return[TheMovieFile]
]; 



(* ::Input::Initialization:: *)
WTASHOW[DT_DTissue, S_, time_, x___]:=Module[{T}, 
T= DTissue2Tissue[DT,S,time];
WTAShow[T, S, time, x]
]; 

WTAShow[T_Tissue,S_,time_,vars_?ListQ,varcolors_?ListQ,opt___?OptionQ]:=Module[{VariableValues,dbg=False,dPrint,IndexOfMaximumValue,colors,pix},dPrint[x___]:=
If[dbg,Print["WTAShow: ",x]];
(*the following will be dynamic variable names,not static*)(*for each variable,find its value at time*)

VariableValues=SimInterpolate[S,#,time]&/@vars;

dPrint["VariableValues: ",Short[VariableValues,3]];

(*group by cell*)
VariableValues=Transpose[VariableValues];
dPrint["VariableValues: ",Short[VariableValues,3]];

(*determine which cell has the maximum value*)IndexOfMaximumValue=Ordering[#,-1][[1]]&/@VariableValues;
dPrint["IndexOfMaximumValue: ",Short[IndexOfMaximumValue,3]];

(*use the color assigned to the maximum value*)
colors=varcolors[[#]]&/@IndexOfMaximumValue;
dPrint["Colors: ",Short[colors,3]];
ShowTissue[T,"CellStyles"->colors,opt]];

WTAShow[T_Tissue,  S_,time_,  vars_?ListQ, varcolors_?ListQ, backgroundColor_, {minval_, maxval_},  opt___?OptionQ]:= Module[{VariableValues, dbg=False, dPrint,IndexOfMaximumValue, color,colors, pix, value, values,n},
dPrint[x___]:= If[dbg, Print["WTAShow: ", x]]; 


n = NTissueCells[T]; 
colors={}; 
dPrint["n=", n];
VariableValues=SimInterpolate[S,#,time]&/@vars;
VariableValues=Transpose[VariableValues]; 

For[i=1, i<= n, i= i+1,
values=VariableValues[[i]];

IndexOfMaximumValue=Ordering[values,-1][[-1]]; 

value=values[[IndexOfMaximumValue]];
color=varcolors[[IndexOfMaximumValue]]; 
color = RGBInterpolate[value, {minval, maxval}, {backgroundColor, color}]; 
AppendTo[colors, color]; 
]; 


dPrint["Colors: ", colors]; 
ShowTissue[T, "CellStyles"-> colors, opt]
];
WTAShow[x___]:= AbortIf[True, "WTAShow: Unexpected input."]; 



(* ::Input::Initialization:: *)
UniqueRandomColors[n_]:= Module[{r, rl,j},
r=Range[n]; 
rl={}; 
While[Length[r]>0,
j=RandomChoice[r];
AppendTo[rl,j];
r=Complement[r, {j}];
];
Hue/@((rl-1.)/n)
]


(* ::Input::Initialization:: *)
LineageAnimate[f_?StringQ, opt___?OptionQ]:= LineageAnimate["InputFolder"-> f, opt]; 
LineageAnimate[opt___?OptionQ]:= Module[{d,dbg, dPrint,TFiles,SFiles, nT,nS,n,GetTimeDomainFromFile, timespans,i,dt, TSFile, nTimespans,plottimes,frames,interval,tstart,tend,times, tstarts,whichinterval,whichtime,jnext,timespan,timeshere,j,needed, colors,values,pix,need,T,S,dmovie,iframe,time,pixfile,type,runstring,error,rate,imagetype,label,showtime,framelabel,isize, cwd,themovie,TheMovieFile, TNOW, L, nAncestralCells, autoscale},

dbg = "debug"/.{opt}/.{"debug"-> False}; 
dPrint[u___]:= If[dbg, Print["LineageAnimate: ", u]]; 

cwd = Directory[]; 
label = "Label"/.{opt}/.{"Label"-> ""};

dPrint["stuff"]; 

d="InputFolder"/.{opt}/.{"InputFolder"-> "Unknown"}; 

Block[{stuff}, 
If[d=="Unknown", 
stuff = GetSimulationPoints[ opt],
stuff=GetSimulationPoints[d,opt]
]; 
If[SameQ[stuff, $Canceled], Return[$Canceled]]; 
needed = "needed"/.stuff;
TFiles = "Tissues"/.stuff;
SFiles="Solutions"/.stuff;
d="folder"/.stuff;
]; 

dPrint["TFiles: ", Short[TFiles,3]]; 
dPrint["SFiles: ", Short[SFiles,3]]; 
dPrint["needed: ", needed];
dPrint["d: ", d]; 
L=GetSavedFile[d, "Lineage",1];
dPrint["L: ", Short[L, 5]];

nAncestralCells=Length[Select[L, First[#]==0&]];
dPrint["nAncestralCells: ", nAncestralCells];

 

(*colors=Table[Hue[RandomReal[{0,.9}]], {nAncestralCells}]; *)

colors = UniqueRandomColors[nAncestralCells]; 

dPrint["colors: ", Short[colors]];  

(* Autoscaling is based on the final time point *)
autoscale=AutoScaleTemplate[ToExpression[Get[Last[TFiles]]]];

showtime="ShowTime"/.{opt}/.{"ShowTime"-> True};
isize = "ImageSize"/.{opt}/.{"ImageSize"-> 1024};  
(* movie type *)
type = "Type"/.{opt}/.{"Type"-> ".mov"}; 
If[Not[StringQ[type]], type=ToString[type]]; 
If[StringTake[type,1]!= ".", type="."<>type]; 
(* image type *)
imagetype = "ImageType"/.{opt}/.{"ImageType"-> ".jpg"}; 
If[Not[StringQ[imagetype]], imagetype=ToString[imagetype]]; 
If[StringTake[imagetype,1]!= ".", imagetype="."<>imagetype]; 

(* frame rate *) 
rate = "FrameRate"/.{opt}/.{"FrameRate"-> 4}; 
If[Not[IntegerQ[rate]], Print["FrameRate must be an integer."]; rate=4]; 
rate = ToString[rate]; 
dmovie=ToFileName[d,"Movie-Lineage-"];
dmovie=createUniqueFolder[dmovie]; 
Print["Saving files to ",dmovie]; 

iframe=1; 
While[Length[needed]>0,
need = First[needed]; 
needed=Rest[needed]; 
i = First[need];
timeshere = i/.need; 
dPrint["getting ", TFiles[[i]]]; 
T =ToExpression[Get[ TFiles[[i]]]]; 

dPrint["getting: ", SFiles[[i]]]; 
S = GetSavedFile[SFiles[[i]], "Solution"]; 

While[Length[timeshere]>0,
time = First[timeshere]; 
timeshere = Rest[timeshere]; 
framelabel = label;
If[showtime,
framelabel = framelabel <>" ("<>ToString[time]<>")";
]; 

dPrint["... insert code to handle solution at time ",time ]; 
dPrint["T: ", Short[T,10]]; 
dPrint["S: ", Short[S,10]]; 
(* If[time>0,
TNOW=DTissue2Tissue[T,S,time],
TNOW=DTissue2Tissue[T]
]; 
dPrint["TNOW: ", Short[TNOW, 10]]; 
*)

 pix = LineageShow[T, S, time, L,  opt, "Colors"-> colors, PlotRange-> autoscale]; 
(* pix = LineageShow[TNOW,  L,  opt, "Colors"\[Rule] colors, PlotRange\[Rule] autoscale]; *)

 
pixfile = ToFileName[dmovie,"FRAME"<>IntegerString[iframe,10,4]<>imagetype];
Export[pixfile,pix,ImageSize-> {isize,isize}]; 

iframe = iframe+1; 
];
];

SetDirectory[dmovie]; 
themovie = "Movie"<>type;
runstring="ffmpeg -sameq -r "<>rate<>" -i 'FRAME%4d"<>imagetype<>"' '"<>themovie<>"'";
Print[runstring]; 
error=Run[runstring]; 
If[error!= 0, Print["ffmpeg return code is: ", error]]; 
TheMovieFile=FileNames[ToFileName[dmovie,themovie]];

SetDirectory[cwd];
Return[TheMovieFile]
]; 



(* ::Input::Initialization:: *)
LineageShow[DT_DTissue, S_, time_, L_, opt___?OptionQ]:= Module[{T},
T= DTissue2Tissue[DT,S,time];
LineageShow[T, L, opt]
]


(* ::Input::Initialization:: *)
LineageShow[T_Tissue, L_, opt___?OptionQ]:= Module[{n, ancestors, originals, cn, AMap, rr,rh, colors, colormap},
originals=Select[L,First[#]==0&];
n = Length[originals]; 
rr:= RandomReal[{0,.9}]; 
rh := Hue[rr]; 
colors=Flatten["Colors"/.{opt}/.{"Colors"-> {}}]; 
While[Length[colors]<n, AppendTo[colors, rh]]; 
colors = Take[colors, n]; 


ancestors[cellNumbers_]:=Module[{LL,rules,theAncestors},
LL=Complement[L,originals];
rules=Reverse/@LL;
theAncestors=(#//.rules)&/@cellNumbers
];

cn = Range[NTissueCells[T]]; 
AMap=ancestors[cn];
colormap=colors[[#]]&/@AMap;
ShowTissue[T, opt, "CellStyles"-> colormap]

]


(* ::Input::Initialization:: *)
SimAnimate[variable_Symbol, d_?StringQ, opt___?OptionQ]:= SimAnimate[variable, "InputFolder"-> d, opt];  
SimAnimate[variable_Symbol, opt___?OptionQ]:= Module[{d,dbg=True, dPrint,TFiles,SFiles, nT,nS,n,GetTimeDomainFromFile, timespans,i,dt, TSFile, nTimespans,plottimes,frames,interval,tstart,tend,times, tstarts,whichinterval,whichtime,jnext,timespan,timeshere,j,needed, colors,values,pix,need,T,S,dmovie,iframe,time,pixfile,type,runstring,error,rate,imagetype,label, none,showtime,framelabel,isize, cwd,themovie,TheMovieFile, autoscale},

dPrint[u___]:= If[dbg, Print["SimAnimate: ", u]]; 

cwd = Directory[]; 

none = SameQ[variable, None] \[Or] MemberQ[{"None",{},False}, variable]; 
d="InputFolder"/.{opt}/.{"InputFolder"-> "Unknown"}; 

Block[{stuff}, 
If[ToString[d]=="Unknown", 
stuff = GetSimulationPoints[opt], 
stuff = GetSimulationPoints[d, opt]
]
If[SameQ[stuff, $Canceled], Return[$Canceled]]; 
needed = "needed"/.stuff;
TFiles = "Tissues"/.stuff;
SFiles="Solutions"/.stuff;
d="folder"/.stuff;
]; 


autoscale=AutoScaleTemplate[ToExpression[Get[Last[TFiles]]]];

colors = "Colors"/.{opt}/.{"Colors"-> {LightGreen,Pink}}; 
values = "Values"/.{opt}/.{"Values"-> {0.0, 1.0}}; 
label = "Label"/.{opt}/.{"Label"-> ToString[variable]<>" "};
If[ToString[label]=="None", label=""]; 
showtime="ShowTime"/.{opt}/.{"ShowTime"-> True};
isize = "ImageSize"/.{opt}/.{"ImageSize"-> 1024};  
(* movie type *)
type = "Type"/.{opt}/.{"Type"-> ".mov"}; 
If[Not[StringQ[type]], type=ToString[type]]; 
If[StringTake[type,1]!= ".", type="."<>type]; 
(* image type *)
imagetype = "ImageType"/.{opt}/.{"ImageType"-> ".jpg"}; 
If[Not[StringQ[imagetype]], imagetype=ToString[imagetype]]; 
If[StringTake[imagetype,1]!= ".", imagetype="."<>imagetype]; 

(* frame rate *) 
rate = "FrameRate"/.{opt}/.{"FrameRate"-> 4}; 
If[Not[IntegerQ[rate]], Print["FrameRate must be an integer."]; rate=4]; 
rate = ToString[rate]; 

If[Not[none],
If[Length[values]!= 2, Print["\"Values\" must be a list of length 2."]; Return[{}]]];  


If[none,
dmovie=ToFileName[d,"Movie-"],
dmovie=ToFileName[d,"Movie-"<>ToString[variable]<>"-"]
];
dmovie=createUniqueFolder[dmovie]; 
Print["Saving files to ",dmovie]; 
iframe=1; 
While[Length[needed]>0,
need = First[needed]; 
needed=Rest[needed]; 
i = First[need];
timeshere = i/.need; 
T =GetSavedFile[ TFiles[[i]], "Tissue"]; 
S = GetSavedFile[SFiles[[i]], "Solution"]; 
 

While[Length[timeshere]>0,
time = First[timeshere]; 
timeshere = Rest[timeshere]; 
If[ToString[label]!= "None", 
framelabel = label;
If[showtime,
framelabel = framelabel <>" ("<>ToString[InputForm[1.0*time]]<>")";
]; 
]; 
If[none,
pix=SimShow[S,time,T,opt,PlotRange-> autoscale, PlotLabel-> framelabel]
,
pix=SimShow[S,variable,time,T,colors,values,opt,PlotRange-> autoscale, PlotLabel-> framelabel]
]; 


pixfile = ToFileName[dmovie,"FRAME"<>IntegerString[iframe,10,4]<>imagetype];
Export[pixfile,pix,ImageSize-> {isize,isize}]; 
iframe = iframe+1; 
];
];
SetDirectory[dmovie]; 
themovie = "Movie"<>type;
runstring="ffmpeg -sameq -r "<>rate<>" -i 'FRAME%4d"<>imagetype<>"' '"<>themovie<>"'";
Print[runstring]; 
error=Run[runstring]; 
If[error!= 0, Print["ffmpeg return code is: ", error]]; 
TheMovieFile=FileNames[ToFileName[dmovie,themovie]];

SetDirectory[cwd];
Return[TheMovieFile]
]; 



(* ::Input::Initialization:: *)
SimAnimate[sim_, variable_, template_, {tstart_, tend_, tdelta_},
{minColor_, maxColor_}, {minVal_, maxVal_}, {xmin_, xmax_}, {ymin_, ymax_}, opt___?OptionQ]:= Module[{s},
RGBErr=0; 

s=SimShow[sim, variable, #, template, {minColor, maxColor}, {minVal, maxVal}, 
{xmin, xmax}, {ymin, ymax}, opt, "CellNumbers"-> False, "BoundaryStyle"-> {Thin, Black}]&/@Range[tstart, tend, tdelta];
Return[s];
];

SimAnimate[sim_, variable_, template_, {tstart_, tend_, tdelta_},
{minColor_, maxColor_}, {minVal_, maxVal_},  opt___?OptionQ]:=SimAnimate[sim, variable, template, {tstart, tend, tdelta}, {minColor, maxColor}, {minVal, maxVal}, Sequence@@AutoScaleTemplate[template], opt]; 

SimAnimate[sim_, variable_, template_, {tstart_, tend_, tdelta_},
{minColor_, maxColor_},   opt___?OptionQ]:= Module[{minVal, maxVal},
{minVal, maxVal}=SimRange[sim, variable, {tstart, tend, tdelta}]; 
SimAnimate[sim, variable, template, {tstart, tend, tdelta}, {minColor, maxColor}, {minVal, maxVal}, Sequence@@AutoScaleTemplate[template], opt]]; 



(* ::Input::Initialization:: *)
GetSimulationPoints[opt___?OptionQ]:= Module[{d}, 
d=SystemDialogInput["Directory",ToFileName[NotebookDirectory[]],WindowTitle->"Please select the folder that contains DTissue*.nb, Solution*.nb,etc.):"];
If[SameQ[d,$Canceled], Return[$Canceled]]; 
GetSimulationPoints[d, opt]
]; 


(* ::Input::Initialization:: *)
GetSimulationPoints[d_, opt___?OptionQ]:=Module[{GetTimeDomainFromFile, TFiles,nT,SFiles,nS,n, TSFile,i,dt,timespans,nTimespans,plottimes, tstart,tend,frames, interval,tstarts,times,whichtime,needed,j,jnext,timespan,timeshere, dbg, dPrint},
dbg = "Debug"/.{opt}/.{"Debug"-> False}; 
dPrint[x___]:= If[dbg, Print["GetSimulationPoints: ", x]]; 

GetTimeDomainFromFile[f_]:=CommonTimeDomain[Get[f]];


(* d=SystemDialogInput["Directory",ToFileName[HomeDirectory[]],WindowTitle\[Rule]"Please select the folder that contains DTissue*.nb, Solution*.nb,etc.):"];
If[SameQ[d,$Canceled], Return[$Canceled]]; 
*)

TFiles=FileNames[ToFileName[d,"DTissue*.nb"]];
nT=Length[TFiles];
SFiles=FileNames[ToFileName[d,"Solution*.nb"]];
nS=Length[SFiles];
If[nS==0, 
SFiles=FileNames[ToFileName[d,"Solution*.mx"]];
nS=Length[SFiles]
]; 


If[nT==0,Print["No Tissues found in "<>d];Return[$Failed]];
If[nS==0,Print["No Simulation results found in "<>d];
Return[$Failed]];
n=Min[{nT,nS}];
If[n<1,Print["Insufficient data found in "<>d<>" to generate an animation."];Return[$Failed]];
TSFile=FileNames[ToFileName[d,"TimeSpans.nb"]];

If[Length[TSFile]>0,
TSFile=First[TSFile];
dPrint["Reading TSFile ",TSFile]; 
timespans=Get[TSFile];
,
Print["File "<>ToFileName[d,"TimeSpans.nb"]<>" not found. Attempting to determine timespans manually. This could take a while ... "];
timespans={};
For[i=1,i<=n,i=i+1,
dt=GetTimeDomainFromFile[SFiles[[i]]];
AppendTo[timespans,dt];
];
];
dPrint["timespans: ", timespans]; 
nTimespans=Length[timespans];
If[nTimespans>n,timespans=Take[timespans,n]];
If[nTimespans<n,Print["Not enough timespans listed in timespan file; recovering by using only the data files that are listed."];
n=nTimespans];

plottimes="PlotTimes"/.{opt}/.{"PlotTimes"->{First[timespans][[1]],Last[timespans][[2]]}};

dPrint["plottimes: ", plottimes]; 
{tstart,tend}=plottimes;
frames="Frames"/.{opt}/.{"Frames"->101};
frames="Frames"/.{opt}/.{"Frames"-> Indeterminate}; 
If[SameQ[frames,Indeterminate], 
frames ="Points"/.{opt}/.{"Points"-> 101}; 
];
interval=(tend-tstart)/(frames-1);
tstarts=First/@timespans;
times=Table[tstart+i*interval,{i,0,frames}];
whichtime=(Floor[(#-tstart)/interval]+1)&/@Append[tstarts,tend];

needed={};
For[i=1,i<=nTimespans,i=i+1,
j=whichtime[[i]];
jnext=whichtime[[i+1]];
If[jnext<1,Continue[]];
j=Max[j,1];
If[j>Length[times],Break[]];
jnext = Min[jnext,Length[times]]; 
If[jnext <j, Break[]]; 
timespan=timespans[[i]];
timeshere=Take[times,{j,jnext}];
timeshere=Select[timeshere,((timespan[[1]]<=#)\[And](#<=timespan[[2]]))&];
If[Length[timeshere]>0,AppendTo[needed,i->timeshere]];
];
dPrint["Exiting"]; 
{"folder"-> d, "needed"-> needed,"Tissues"-> TFiles,"Solutions"-> SFiles}
];


(* ::Input::Initialization:: *)
GetSimulationTissuePoints[opt___?OptionQ]:=Module[{stuff,f,which,tissues,indices,times,solutions},
stuff=GetSimulationPoints[opt];
f="folder"/.stuff;
which="needed"/.stuff;
indices=First/@which;
times=Flatten[Last/@which];
tissues="Tissues"/.stuff;
tissues=tissues[[indices]];
solutions="Solutions"/.stuff;
solutions=solutions[[indices]];
{"folder"-> f,"indices"-> indices, "times"-> times,"Tissues"-> tissues, "Solutions"-> solutions}
]


(* ::Input::Initialization:: *)
AutoScaleTemplate[DT_DTissue, x___]:= AutoScaleTemplate[DTissue2Tissue[DT],x]
AutoScaleTemplate[template_?TissueQ, xpad_:10, ypad_:10]:= Module[{v, x,y, xmin, xmax, ymin, ymax, width, height, dx, dl, dy},
v=TissueVertices[template]; 
{x,y}=Transpose[v]; 
x=Complement[x, {-\[Infinity],\[Infinity]}]; 
y=Complement[y, {-\[Infinity], \[Infinity]}];  
{xmin, xmax}={Min[x], Max[x]}; 
{ymin, ymax}={Min[y], Max[y]}; 

width = xmax-xmin;
height = ymax-ymin; 
dx = (xpad/100.0)*width; 
dy = (ypad/100.0)*height;

xmin = xmin - dx; 
xmax = xmax + dx; 
ymin = ymin  - dy; 
ymax = ymax + dy; 

Return[{{xmin, xmax}, {ymin, ymax}}];

]


(* ::Input::Initialization:: *)
SaveFrames[pictures_?ListQ,type_, size_, movieType_:".avi",  label_:"MovieData-", framerate_:16]:= Module[{dir,cwd, labl,frnames, moviedir,framedir,  moviefile, runstring,typ,error, FrameName, FrameNames, dotavi, today, $TEMP, rate,CellzillaHome},


CellzillaHome=CreateHomeFolder[]; 

$TEMP = createTodaysFolder[ToFileName[CellzillaHome,"Simulations-"]];
 
(*
today=DateString[{"Day","-","MonthNameShort","-","YearShort"}]; 
$TEMP=ToFileName[$HomeDirectory, "Simulations-"<>today];
*)

dotavi = movieType; 
If[StringTake[dotavi, 1]!= ".", dotavi = "."<>dotavi]; 

FrameName[x_, type1_:"EPS"]:= Module[{y, ty},
ty = ToString[type1]; 
If[StringTake[ty, {1, 1}]!= ".", ty="."<>ty];  
y=ToString[x];
While[StringLength[y]<4, y="0"<>y]; 
Return[ToUpperCase["Frame"<>y<>ty]]
]; 
FrameNames[number_, type1_:"EPS"]:= FrameName[#, type1]&/@Range[number]; 

cwd = Directory[];  

(* 
If[Length[FileNames[$TEMP]]<1, 
Print["Creating new output directory ", $TEMP];
CreateDirectory[$TEMP]
]; 
*)

SetDirectory[$TEMP]; 


dir=createUniqueFolder[ToFileName[$TEMP,ToString[label]]];

Print["Created folder: ", dir]; 

moviefile=Last[FileNameSplit[dir]]<>dotavi;
moviefile=ToFileName[dir,moviefile];
Print["moviefile will be: ", moviefile]; 
SetDirectory[dir];

(*
dir=DateString[ {"Day", "-", "MonthNameShort", "-", "YearShort", "-", "Hour24","Minute"}]; 
labl=ToString[label]; 
If[StringLength[labl]>0, dir =labl<>"-"<> dir]; 
moviefile=dir<>dotavi; 
moviefile = ToFileName[Directory[], moviefile]; 
*)


framedir=CreateDirectory["Frames"]; 
Print["Created directory: ", framedir]; 

SetDirectory[framedir]; 

Print["Putting movie frames in  in " , framedir]; 
 

frnames=FrameNames[Length[pictures], ToString[type]]; 
MapThread[Export[#1, #2, ImageSize-> {size,size}]&, {frnames, pictures}]; 

typ=type; 
If[StringTake[typ, {1,1}]!= ".", typ = "."<>typ]; 

rate=ToString[Round[framerate]]; 

runstring="ffmpeg -sameq -r "<>rate<>" -i 'FRAME%4d"<>typ<>"' '"<>moviefile<>"'";
Print[runstring]; 
error=Run[runstring]; 
If[error!= 0, Print["ffmpeg return code is: ", error]]; 
Print["Created Movie: ", #]&/@FileNames[moviefile];

SetDirectory[cwd]; 

]; 


(* ::Input::Initialization:: *)
ToAVI[pics_?ListQ,title_:"MovieData",  size_:400, rate_:16]:= SaveFrames[pics, "JPG", size,".avi", title, rate];
ToMOV[pics_?ListQ,title_:"MovieData",  size_:400, rate_:16]:= SaveFrames[pics, "JPG", size,".mov", title, rate];

ToAVI[___]:= Print["Expecting[ToAVI[{picture, picture, ...}, title_:\"SomeTextLabel\", size_:400]"]; 
ToMOV[___]:= Print["Expecting[ToMOV[{picture, picture, ...}, title_:\"SomeTextLabel\", size_:400]"]; 



(* ::Input::Initialization:: *)
CSVFile[w_?TissueQ]:= Module[{nv,ne,nf,nc,v, e, f, output,dim=2},
v=TissueVertices[w];
dim=Length[v[[1]]]; 
e=TissueEdges[w];
f=TissueCells[w];
nv=Length[v];ne=Length[e]; nf=Length[f]; 
nc=0;
output={{dim,"dimensions"},{nv, "vertices"}, {ne,"edges"}, {nf, "faces"}};
output=Join[output,1.0*v];
output=Join[output,e];
output=Join[output,f]
];
CSVFile[w_?TissueQ, f_?StringQ, flat_:False]:= Module[{r, fname,n,output,actual},
fname=f;
n=0; 
r=FileExistsQ[fname]; 
While[r,
n = n+1; 
fname =  f<>ToString[n];
r=FileExistsQ[fname]; 
];
If[flat, 
output=CSVFlatFile[w],
output=CSVFile[w]
]; 
actual=Export[fname,output,"CSV"];
ExpandFileName[actual]
];
CSVFile[x___]:= Print["Expecting CSVFile[tissue] or CSVFile[tissue,filename]"];


(* ::Input::Initialization:: *)
CSVFlatFile[w_?TissueQ]:= Module[{nv,nf,nc,v,  f, output,dim=2, cvn},
v=TissueVertices[w];
cvn = CellVertexNumbers[w]; 
dim=Length[v[[1]]]; 
f=TissueCells[w];
nv=Length[v]; nf=Length[f]; 
nc=0;
output={{dim,"dimensions"},{nv, "vertices"}, {nf, "faces"}};
output=Join[output,1.0*v];

output=Join[output,cvn]
];



(* ::Input::Initialization:: *)
CSVToTissue[filename_]:= Module[{Q, lens, dim, nv,ne,nf, nlines, vertices, edges, vlens, faces, vmax, pvmax,vmin, pvmin, emin, emax, pemin, pemax, dPrint, dbg=False},
dPrint[x___]:=If[dbg, Print["CSVToTissue: ", x]]; 
AbortIf[Not[FileExistsQ[filename]], "Unable to locate "<>ToString[filename]];
Q=Import[filename];
lens = Length/@Q;
dim=Q[[1]];
AbortIf[dim[[2]]!= "dimensions", "The first line of the file is not n,dimensions"]; 
dim = dim[[1]]; 

nv=Q[[2]];
AbortIf[nv[[2]] != "vertices", "The second line of the file is not nv,vertices"];
nv = nv[[1]]; 

ne=Q[[3]]; 
If[ToUpperCase[ne[[2]]]=="FACES", Return[FlatCSVToTissue[filename]]];
AbortIf[ne[[2]] != "edges", "The third line of the file is not ne,edges"]; 
ne = ne[[1]]; 

nf=Q[[4]]; 
AbortIf[nf[[2]] != "faces", "The 4th line of the file is not nf,faces"]; 
nf = nf[[1]];

nlines = Length[lens]; 

(* get the vertices *)

Q=Drop[Q,4]; 
AbortIf[Length[Q]<nv, "Early end to file after "<>ToString[Length[Q]]<>" vertices, when "<>ToString[nv]<>" vertices were expected, followed by edges and faces."]; 
vertices = Take[Q,nv];
dPrint["vertices=", vertices];
vlens = Union[Length/@vertices]; 
AbortIf[vlens != {dim}, "Some of the vertices do not have dimension "<>ToString[dim]]; 

(* get the edges *)

Q=Drop[Q,nv]; 
AbortIf[Length[Q]<ne, "Early end to file after "<>ToString[Length[Q]]<>" edges, when "<>ToString[ne]<>" edges were expected, followed by faces."]; 
edges=Take[Q, ne];
dPrint["edges: ", edges];

(* make sure the edges only refer to allowed vertex numbers *)

vmax=Max[Flatten[edges]];
pvmax = Position[edges, vmax][[1,1]]; 
AbortIf[vmax>nv, "Edge "<>ToString[pvmax]<>" refers to vertex "<>ToString[vmax]<>" which is not defined."]; 
 
vmin=Min[Flatten[edges]]; 
pvmin = Position[edges, vmin][[1,1]]; 
AbortIf[vmin <1, "Edge "<>ToString[pvmin]<>" refers to vertex "<>ToString[vmin]<>" which is not a valid vertex number"]; 

(* Get the faces *)

Q=Drop[Q, ne]; 
AbortIf[Length[Q]<nf, "Early end to file after "<>ToString[Length[Q]]<>" faces, when "<>ToString[nf]<>" faces were expected."]; 
faces = Take[Q,nf]; 
dPrint["faces: ", faces]; 

(* Make sure the faces only refer to allowed edge numbers *)
emax = Max[Flatten[faces]]; 
pemax = Position[faces, emax][[1,1]]; 
AbortIf[emax>ne, "Face "<>ToString[pemax]<>" refers to edge "<>ToString[emax]<>" which is not defined."]; 

emin = Min[Flatten[faces]]; 
pemin = Position[faces, emin][[1,1]]; 
AbortIf[emin <1, "Face "<>ToString[pemin]<>" refers to edge "<>ToString[emin]<>" which is not a valid edge number"];


Tissue[vertices,edges, faces]

];


(* ::Input::Initialization:: *)
FlatCSVToTissue[filename_]:= Module[{Q, lens, dim, nv,nf, nlines, vertices, vlens, faces, vmax, pvmax,vmin, pvmin, emin, emax, pemin, pemax, dPrint, dbg=False},
dPrint[x___]:=If[dbg, Print["CSVToTissue: ", x]]; 
AbortIf[Not[FileExistsQ[filename]], "Unable to locate "<>ToString[filename]];
Q=Import[filename];
lens = Length/@Q;
dim=Q[[1]];
AbortIf[dim[[2]]!= "dimensions", "The first line of the file is not n,dimensions"]; 
dim = dim[[1]]; 

nv=Q[[2]];
AbortIf[nv[[2]] != "vertices", "The second line of the file is not nv,vertices"];
nv = nv[[1]]; 

nf=Q[[3]]; 
AbortIf[nf[[2]] != "faces", "The 3rd line of the file is not nf,faces, so this is not a flat file"]; 
nf = nf[[1]];

nlines = Length[lens]; 

(* get the vertices *)

Q=Drop[Q,3]; 
AbortIf[Length[Q]<nv, "Early end to file after "<>ToString[Length[Q]]<>" vertices, when "<>ToString[nv]<>" vertices were expected, followed by edges and faces."]; 
vertices = Take[Q,nv];
vlens = Union[Length/@vertices]; 
AbortIf[vlens != {dim}, "Some of the vertices do not have dimension "<>ToString[dim]]; 

(* get the edges *)

Q=Drop[Q,nv]; 

(* Get the faces *)

AbortIf[Length[Q]<nf, "Early end to file after "<>ToString[Length[Q]]<>" faces, when "<>ToString[nf]<>" faces were expected."]; 
faces = Take[Q,nf]; 
dPrint["faces: ", faces]; 

(* Make sure the faces only refer to allowed vertex numbers *)

vmax=Max[Flatten[faces]];
pvmax = Position[faces, vmax][[1,1]]; 
AbortIf[vmax>nv, "Face "<>ToString[pvmax]<>" refers to vertex "<>ToString[vmax]<>" which is not defined."]; 
 
vmin=Min[Flatten[faces]]; 
pvmin = Position[faces, vmin][[1,1]]; 
AbortIf[vmin <1, "Face "<>ToString[pvmin]<>" refers to vertex "<>ToString[vmin]<>" which is not a valid vertex number"]; 


FlatTissue2Tissue[FlatTissue[vertices, faces]]

]


(* ::Input::Initialization:: *)
FlatFile[w_?TissueQ]:= Module[{nv,ne,nf,nc,v, e, f, output,dim=2},
v=TissueVertices[w];
dim=Length[v[[1]]]; 
e=TissueEdges[w];
f=TissueCells[w];
nv=Length[v];ne=Length[e]; nf=Length[f]; 
nc=0;
output=Join[{{dim}}, {{nv,ne,nf,nc}},1.0*v,e,f]
];
FlatFile[w_?TissueQ, f_?StringQ]:= Module[{r, fname,n,output,actual},
fname=f;
n=0; 
r=FileExistsQ[fname]; 
While[r,
n = n+1; 
fname =  f<>ToString[n];
r=FileExistsQ[fname]; 
];
output=FlatFile[w]; 
actual=Export[fname,output,"Table"];
ExpandFileName[actual]
];
FlatFile[x___]:= Print["Expecting FlatFile[tissue] or FlatFile[tissue,filename]"];


(* ::Input::Initialization:: *)
TissueToPLY[w_?TissueQ]:=Module[{nv,nc,ne,v,c,e,efrom0,cfrom0,sub1,facelengths,faces,output,header, cvn,cvnfrom0, dim},v=TissueVertices[w];
e=TissueEdges[w];
c=TissueCells[w];
nv=Length[v];
ne=Length[e];
nc=Length[c];
cvn=CellVertexNumbers[w]; 
cvn=Append[#,First[#]]&/@cvn;

sub1[list_]:=(#-1)&/@list;
efrom0=sub1/@e;
cfrom0=sub1/@c;

cvnfrom0=sub1/@cvn;

dim=Length[v[[1]]];  

facelengths=Length/@cvnfrom0;

cvnfrom0=MapThread[Prepend[#1,#2]&,{cvnfrom0,facelengths}];

Which[dim==2,
header=List/@{"ply","format ascii 1.0",
"comment Generated by Cellzilla2D "<>$Cellzilla2DVersion,
"comment "<>DateString[],
"element vertex "<>ToString[nv],"property float x","property float y",(*"element edge "<>ToString[ne],"property int vertex1","property int vertex2",*)"element face "<>ToString[nc],"property list uchar int vertex_indices","end_header"},
dim==3,
header=List/@{"ply","format ascii 1.0",
"comment Generated by Cellzilla2D "<>$Cellzilla2DVersion,
"comment "<>DateString[],
"element vertex "<>ToString[nv],"property float x","property float y","property float z", "element face "<>ToString[nc],"property list uchar int vertex_indices","end_header"}
]; 
output=Join[header,v*1.0,(*efrom0,faces*) cvnfrom0]
];

TissueToPLY[w_?TissueQ, f_?StringQ]:= Module[{r, fname,n,output,actual},
fname=f;
n=0; 
r=FileExistsQ[fname]; 
While[r,
n = n+1; 
fname =  f<>ToString[n];
r=FileExistsQ[fname]; 
];
output=TissueToPLY[w]; 
actual=Export[fname,output,"Table"];
ExpandFileName[actual]
];

TissueToPLY[x___]:= Print["Expecting TissueToPLY[tissue] or TissueToPLY[tissue,filename]"];


(* ::Input::Initialization:: *)
PLYToTissue[filename_,maxedges_: 100]:=Module[{u,nv,nf,EH,vertices,cells,Cells,cell,edges,EdgePairsInThisCell,nextEdge,EdgesInThisCell,k,p,q,vcell,centroid},u=Import[filename,"table"];
nv=Flatten[Cases[u,{"element","vertex",_}]];
While[ListQ[nv],nv=Last[nv]];
nf=Flatten[Cases[u,{"element","face",_}]];
While[ListQ[nf],nf=Last[nf]];
EH=Flatten[Position[u,{"end_header"}]];
EH=EH[[1]];
u=Drop[u,EH];
vertices=Take[u,nv];
vertices=Map[Take[#,2]&,vertices];
cells=Drop[u,nv];
edges={};
Cells={};
For[c=1,c<=Length[cells],c++,cell=Rest[cells[[c]]];
(*add one to correct for zero-start in python*)cell=(#+1)&/@cell;
vcell=vertices[[#]]&/@cell;
centroid=Centroid[vertices];
EdgePairsInThisCell=Map[Sort,Partition[cell,2,1,1]];
ne=Length[EdgePairsInThisCell];
If[ne<maxedges,EdgesInThisCell={};
For[i=1,i<=ne,i++,nextEdge=EdgePairsInThisCell[[i]];
{p,q}=nextEdge;
If[p!=q,If[MemberQ[edges,nextEdge],k=Position[edges,nextEdge];While[ListQ[k],k=k[[1]]],edges=Append[edges,nextEdge];k=Length[edges];];
EdgesInThisCell=Append[EdgesInThisCell,k];];];
Cells=Append[Cells,EdgesInThisCell]];];

Cells = Select[Cells, Length[#]>2&]; 

Tissue[vertices,edges,Cells]]


(* ::Input::Initialization:: *)
PLYToTissue3D[filename_,maxedges_: 100]:=Module[{u,nv,nf,EH,vertices,cells,Cells,cell,edges,EdgePairsInThisCell,nextEdge,EdgesInThisCell,k,p,q,vcell,centroid, vertices3D},u=Import[filename,"table"];
nv=Flatten[Cases[u,{"element","vertex",_}]];
While[ListQ[nv],nv=Last[nv]];
nf=Flatten[Cases[u,{"element","face",_}]];
While[ListQ[nf],nf=Last[nf]];
EH=Flatten[Position[u,{"end_header"}]];
EH=EH[[1]];
u=Drop[u,EH];
vertices=Take[u,nv];
vertices3D=vertices; 
vertices=Map[Take[#,2]&,vertices];
cells=Drop[u,nv];
edges={};
Cells={};
For[c=1,c<=Length[cells],c++,cell=Rest[cells[[c]]];
(*add one to correct for zero-start in python*)cell=(#+1)&/@cell;
vcell=vertices[[#]]&/@cell;
centroid=Centroid[vertices];
EdgePairsInThisCell=Map[Sort,Partition[cell,2,1,1]];
ne=Length[EdgePairsInThisCell];
If[ne<maxedges,EdgesInThisCell={};
For[i=1,i<=ne,i++,nextEdge=EdgePairsInThisCell[[i]];
{p,q}=nextEdge;
If[p!=q,If[MemberQ[edges,nextEdge],k=Position[edges,nextEdge];While[ListQ[k],k=k[[1]]],edges=Append[edges,nextEdge];k=Length[edges];];
EdgesInThisCell=Append[EdgesInThisCell,k];];];
Cells=Append[Cells,EdgesInThisCell]];];

(* weed out spurious cells *)

Cells = Select[Cells, Length[#]>2&]; 

Tissue[vertices3D,edges,Cells]]


(* ::Input::Initialization:: *)
Help[]:= Module[{names, usagestrings, print}, 
names=decontextify/@Names["Cellzilla2D`*"];
usagestrings = ToExpression/@((ToString[#]<>"::usage")&/@names); 
print[a_, b_]:= Module[{}, 
If[StringLength[ToString[b]]>0, 
StylePrint[a, "Subsection"]; 
Print[b]; 
];
]; 
StylePrint["Cellzilla2D Help", "Section"]; 
Print["This is the Cellzilla2D Help file. It provides some reference information about each of the externally visible Cellzilla2D functions. It is not a users guide and does not provide any introduction to using Cellzilla2D. It also does not include plugin reference information. \nPlease note that Cellzilla2D is experimental software and as such many of the functions may only contain partial implementations. And like a lot of software documentation in the cybersphere it does not always keep up with the latest implementation. Please check with the developer if you have any questions."];
Print["This file was generated by CelleratorML version "<>$Cellzilla2DVersion<>" on "<>DateString[{"Day", " ", "MonthNameShort", " ", "Year", " at ", "Hour", ":", "Minute", ":", "Second", " (", "TimeZone",")"}]<>" using Mathematica "<>$Version<>" (Version "<>ToString[ $VersionNumber]<>", Release "<>ToString[ $ReleaseNumber]<> ")"];  
MapThread[print, {names, usagestrings}]; 
];


(* ::Input::Initialization:: *)
End[];
If[FLAGS`ECHOLOAD,

Print[
Style["Cellzilla2D", FontFamily-> "Ubuntu,Arial", FontSize-> 12, FontWeight-> "Bold"],Style[" ("<>$Cellzilla2DVersion<> ") loaded "<> DateString[]<>"\nusing ", FontSize->12,FontFamily-> "Ubuntu,Arial"],
Style["xCellerator ", FontSize-> 12, FontFamily-> "Ubuntu,Arial", FontWeight-> "Bold"], 
Style[$XLR8RLOAD<>" and ", FontSize->12,FontFamily-> "Ubuntu,Arial"],
Style["XSSA ", FontSize-> 12, FontFamily-> "Ubuntu,Arial", FontWeight-> "Bold"], 
Style[$XSSALOAD, FontSize->12,FontFamily-> "Ubuntu,Arial"], 
Style["\nGPL License Terms Apply", FontColor-> Red, FontSize-> 12, FontFamily-> "Ubuntu,Arial", FontWeight-> Bold]
];
]; 
EndPackage[]; 
