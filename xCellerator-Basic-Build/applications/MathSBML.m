(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["MathSBML`"];

If[$VersionNumer<6, 
Off[DiscreteMath`Combinatorica`Star]; 
]; 

If[$VersionNumber<6, 
Needs["Graphics`"];
Needs["Graphics`Legend`"];
Needs["LinearAlgebra`MatrixManipulation`"];
Needs["Utilities`"];
,
Needs["PlotLegends`"]; 
]; 

Needs["JLink`"];
If[$VersionNumber>= 6, Needs["XML`"]];  (* XML` is loaded automatically in versions 4 & 5 *)

If[$VersionNumber>5,
Needs["DifferentialEquations`NDSolveProblems`"];
Needs["DifferentialEquations`NDSolveUtilities`"]; 
Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"];
If[$VersionNumber<6, Needs["DiscreteMath`GraphPlot`"]]
];
If[$VersionNumber>5.3, Needs["GraphUtilities`"]]; 

If[$VersionNumber<6, 
On[DiscreteMath`Combinatorica`Star];
]; 

versions=Names["$MathSBML$Version"];
If[Length[versions]>0,
TEMP$OLDVERSION=$MathSBML$Version; 
TEMP$FIRST=False;,
TEMP$FIRST=True];
Remove[versions];


$MathSBML$Version = "2.12";


bulletize[mystring$$$_?StringQ,bullet$$$_?StringQ]:="\n\n"<>bullet$$$<>" "<>mystring$$$; 
numerize[mystring$$$_?StringQ, number$$$_?IntegerQ]:= bulletize[mystring$$$, "("<>ToString[number$$$]<>")"];
numerizedList[myzstring$$$_?ListQ]:=Apply[StringJoin, MapThread[numerize[#1, #2]&, {myzstring$$$, Range[Length[myzstring$$$]]}]];



sbmlReadLimitations = numerizedList[{
"\!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)does not perform XML or SBML validation.  If invalid SBML or XML is supplied, unexpected results can occur.  In general, incorrectly formatted XML will cause \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)'s \!\(\*
StyleBox[\"Import\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"[\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"..\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"]\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)function to print an error message indicating the line number for the first error and then \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)will terminate.",
"\!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)is currently only compatible with SBML Level 1 (versions 1 and 2) and Level 2 (version 1). Subsequent releases will support higher levels.",
"In SBML Level 1, all of the mathematical functions (e.g., \!\(\*
StyleBox[\"abs\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\), \!\(\*
StyleBox[\"acos\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\), etc.) are fully supported.  Thus \!\(\*
StyleBox[\"cos\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"(\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"x\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\")\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)becomes\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Cos\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"[\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"x\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"]\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\), etc.  Predefined rate law functions are recognized as functions but are not implemented. Thus,if the function \!\(\*
StyleBox[\"umr\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"(\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"argument\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"list\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\")\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)is specified in the SBML,it will be recognized as a predefined function and will be expanded in the \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)model as \!\(\*
StyleBox[\"umr\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"[\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"argument\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"list\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"]\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\).  However, unlike the mathematical functions,no implementation is provided.Thus if the model contains ths functions,the user must supply a \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)i mplementation for \!\(\*
StyleBox[\"umr\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\),etc.",
"By default, all parameters are replaced with their numerical values as specified in the model. This can be switched off using the option \!\(\*
StyleBox[\"evaluateParameters\",\nFontColor->RGBColor[0, 0, 1]]\), in which case \!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)will return a list of \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)replacement rules of the form \!\(\*
StyleBox[\"name\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"\[Rule]\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"value\",\nFontSlant->\"Italic\",\nFontColor->RGBColor[0, 0, 1]]\).",
"The topological relationship specified by the \!\(\*
StyleBox[\"outside\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)attribute in a compartment definition is ignored, although \!\(\*
StyleBox[\"SBMLRead\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)will display the relationship in the verbose listing.  If no outside component exists, the \!\(\*
StyleBox[\"Mathematica\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)variable \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)is displayed.",
"The \!\(\*
StyleBox[\"reversible\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameter of the \!\(\*
StyleBox[\"reaction\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)type is ignored with the following exception: reversible reactions in the list of reactions returned (SBMLReactions) will use the double arrow (\[RightArrowLeftArrow]) instead of the single forward arrow (\[Rule] or ->, same arrow used for rules).", 
"In SBML Level 1, Unspecified initial conditions and parameter values will be labeled as \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)if they are not specified,and a warning message will be printed. Models with \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameters and initial conditions will cause an error in\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"NDSolve\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\).  To prevent this from happening,the user can optionally specify the options \!\(\*
StyleBox[\"defaultParameterValue\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)and \!\(\*
StyleBox[\"defaultIC\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)to set all \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameter values and initial conditions.For example, \!\(\*
StyleBox[\"defaultParameterValue\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"->\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"1\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)will set all \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)parameters equal to 1. Unspecified units will be labeled as \!\(\*
StyleBox[\"Indeterminate\",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"Courier\",\nFontColor->RGBColor[0, 0, 1]]\)in the verbose listing,but no association will be returned for indeterminate units.","Annotations and notes are ignored."
}]; 

sbmlReadOptions = "\n\nOptions for SBMLRead are:\n"<>
"\n\!\(\*
StyleBox[\"align\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"Left\", alignment of verbose output on screen. Any valid values of TextAlignment may be used; since the value is passed directly to TextAlignment without error checking invalid values will result in the default value of TextAlignment (\"Left\"). This option is ignored unless verbose\[Rule]True."<>
"\n\!\(\*
StyleBox[\"concise\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False. When  True, overrides whatever values are set to verbose, warnings, and stats to set all of them to False. This option minimizes the written output."<>
"\n\!\(\*
StyleBox[\"context\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"Automatic\" (default), assign all global model variables to a context given by the model name; thus variables x,y,z in them SBML become modelname`x, modelname`y, modelname`z in the Mathematica representation.  Local parameters in reactions will be assigned a context modelname`reactionname, i.e., if reaction20 in model foo has a parameter k it will be called foo`reaction20`k. "<>
"\n\!\(\*
StyleBox[\"context\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]str, where str is any string.  All variables will be assigned to the context str` (reaction parameters to context str`reactioname`)  instead of modelname`. The terminating \"`\" character is optional."<>
"\n\!\(\*
StyleBox[\"context\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"None\", all model variables are placed in the Global` context. Be aware that this could be dangerous, as symbols in the model could collide with other variables previously defined in the Mathematica environment and lead to unexpected results. "<>
"\n\!\(\*
StyleBox[\"defaultIC\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]Indeterminate, if reassigned, then all unspecified initial conditions will be set to the value of defaultIC.  Otherwise they will remain Indeterminate."<>
"\n\!\(\*
StyleBox[\"defaultParameterValue\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]Indeterminate, if reassigned, then all unspecified parameter values will be set to the value of defaultIC.  Otherwise they will remain Indeterminate."<>
"\n\!\(\*
StyleBox[\"EchoLoad\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, if True, a message will be printed as each SBML object is loaded into the Model Builder. Ignored unlese LoadModelBuilder\[Rule]True"<>
"\n\!\(\*
StyleBox[\"evaluateParameters\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True, immediately evaluate parameters in reactions, otherwise return reactions with symbolic parameters.  "<>
"\nL\!\(\*
StyleBox[\"oadModelBuilder\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True, loads model into the Model Builder."<>
"\n\!\(\*
StyleBox[\"NDSolveOptions\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]{}, options to be passed to NDSolve; ignored unless SBMLNumericalSolution\[Rule]n, withing return, as in return\[Rule]{SBMLNumericalSolution\[Rule] 25, ...}, where n>0 is a number."<>
"\n\!\(\*
StyleBox[\"PlotOptions\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]{} contains a list of options to be passed to SBMLPlot, including any options to be passed to Plot.  If this option is omitted or a null list, no plot is generated. A warning message will be generated if the user does not also request a numerical solution by setting SBMLNumericalSolution to a positive value as part of the return options."<>
"\n\!\(\*
StyleBox[\"return\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]{SBMLODES\[Rule]True, SBMLIC\[Rule]True, SBMLConstants\[Rule]True, SBMLModelVariables\[Rule]True, SBMLAlgebraicRules\[Rule]True, SBMLUnitDefinitions\[Rule]True, SBMLUnitAssociations\[Rule]True, SBMLReactions\[Rule]True, SBMLFunctions\[Rule]True,  SBMLEvents\[Rule]True, SBMLNameIDAssociations\[Rule]True, SBMLModelName\[Rule]True, SBMLNumericalSolution\[Rule]0}; this option allows the user to control the return value of SBMLRead.  All boolean items are returned except for those set to False. A numerical solution is only returned if SBMLNumericalSolution evaluates to a positive number. Setting return\[Rule]None is equivalent to setting everything to False."<>
"\n\!\(\*
StyleBox[\"shortenODES\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, ignored unless verbose\[Rule]True and showKineticlaw\[Rule]True. If shortenODES\[Rule]False (default), then the entire differential equation will be displayed in the verbose listing; if shortenODES\[Rule]True then the Mathematica Short[..] version will be used."<>
"\n\!\(\*
StyleBox[\"showKineticLaw\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True, ignored unless verbose\[Rule]True; if showKineticLaw\[Rule]True(default), the SBML kinetic law is shown in the reaction-listing of the verbose display; otherwise  the kinetic laws are not displayed in the reactions table"<>
"\n\!\(\*
StyleBox[\"showReactionParameters\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]True,  ignored unless verbose\[Rule]True; if showReactionParameters\[Rule]True(default), the local parameters in each reaction are  shown in the reaction-listing of the verbose display; otherwise  the local parameters are not displayed in the reactions table"<>
"\n\!\(\*
StyleBox[\"stats\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, print a statistical summary of the file"<>
"\n\!\(\*
StyleBox[\"underscore\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\"\[UnderBracket]\", character (or string) that is used to replace the underscore (\"_\") charcter in SBML indentifiers."<>
"\n\!\(\*
StyleBox[\"verbose\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, if True, print an interpretive table of the SBML"<>
"\n\!\(\*
StyleBox[\"verbosecontext\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]False, if True, the context (scope) of all variables will be indicated in the verbose display. If False, only the pure model variable will be indicated. This option will be ignored unless verbose\[Rule]True."<>
"\n\!\(\*
StyleBox[\"warnings\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule] True, if False, warning messages will be suppressed."; 


SBMLRead::usage="SBMLRead[filename, options]"<>
" returns an option list of the form:\n\n{\nSBMLODES\[Rule]{v1'[t]==expression, v2'[t]==expression,...},\nSBMLConstants\[Rule]{k1\[Rule]value,k2\[Rule]value,...},\nSBMLIC\[Rule]{v1[0]==value,v2[0]==value,...},\nSBMLModelVariables\[Rule]{v1[t],v2[2],..},\nSBMLAlgebraicRules\[Rule]{expression1==0, expression2==0, ...},\nSBMLUnitDefinitions\[Rule]{unitName1\[Rule]unitDefinition1, unitName2\[Rule]unitDefinition2,...},\nSBMLUnitAssociations\[Rule]{var1\[Rule]units1,var2\[Rule]units2,...},\nSBMLReactions\[Rule]{reaction1, reaction2,...},\nSBMLModelName\[Rule]name,\nSBMLNameIDAssociations\[Rule]{id1\[Rule]name1,id2\[Rule]name2},\nSBMLFunctions\[Rule]{function1\[Rule]def, function2\[Rule]def,...},\nSBMLEvents\[Rule]{event1def1, eventdef2,,..},\nSBMLNumericalSolution\[Rule]numerical solution,\nSBMLCompartments\[Rule]{c1,c2,...}\n}\n\nwhere v1,v2,... give all of the species in the SBML file; c1,c2,... are the compartments in the model; the expression gives the derived differential equation for that species; value (following SBMLConstants or SBMLIC) is the SBML value of the associated parameter or initial condition; unitName1,... are user-defined units; unitDefinition1,... are expressions that give the unit definitions in terms of pre-defined units; units1,... are the units that correspond to variable var1,..., which can be either species, parameter, or compartment; reaction1,reaction2,... are the reactions in standard biochemical form \!\(\*SubscriptBox[\(\[CapitalSigma]\), \(i\)]\)\!\(\*SubscriptBox[\(R\), \(i\)]\)\[Rule]\!\(\*SubscriptBox[\(\[CapitalSigma]\), \(j\)]\)\!\(\*SubscriptBox[\(P\), \(j\)]\), where R and P are the reactants and products in each reaction.\nSBMLFunctions, SBMLEvents, and SBMLNameIDAssociations only apply for Level 2.\nEvent definitions have the form id\[Rule]{\"trigger\"\[Rule]expression,\"delay\"\[Rule]expression,\"events\"\[Rule]{var1\[Rule]exp1,var2\[Rule]exp2,...}} where id is the event id (assigned to Event\[UnderBracket]n if not provided); and expression, etc., are Mathematica expressions.\nSBMLFunctions have the form {id\[Rule]Function[...], id\[Rule]Function[...],..} where Function[...] gives a pure Mathematica Function definition and id is the corresponding SBML id for the function. \nAny portion of the returned option list may be turned off with the option return.\nSBMLNumericalSolution is the output of SBMLNDsolve, if a numerical solution is requested.\n\nThe intention is that this format contains all information necessary to pass the model to NDSolve in the following manner:\n\n"<>"r=SBMLRead[filename,options]\n"<>
"Apply[NDSolve,{Join[SBMLODES/.r, SBMLIC/.r]/.(SBMLConstants/.r), SBMLModelVariables/.r,{t,0,tmax},NDSolveOptions}]"<>
"\n\nwhere NDSolveOptions are any valid options for NDSolve and tmax is the duration of the NDSolve Rule."<>sbmlReadOptions<>
"\n\nAdditional Notes and Limitations of SBMLRead"<>sbmlReadLimitations


textODES::usage="textODES[model] returns the differential equations in a model as a list of strings that can be copied to a text file.\ntextODES[model,filename] writes the result to filename.\nmodel Should be the output of SBMLRead or loadSimulator."


SBMLNDSolve::usage="SBMLNDSolve[model, tmax,options]"<>
" evaluates NDSolve on an SBML model, where model is the ouptput of SBMLRead, tmax is the duration of the NDSolve run, and options are any valid options for NDSolve.\n\nAdditional Notes and Limitations:"<>numerizedList[{ "units are ignored by \!\(\*
StyleBox[\"SBMLNDSolve\",\nFontColor->RGBColor[0, 0, 1]]\)",
"The inclusion of algebraic constraints (rules) along with differential equations to produce a system of Differential-Algebraic Equations requires Mathematica Version \[GreaterEqual] 5.0; version checking is performed dynamically.",
"If the model does not contain any events then the return value of SBMLNDSolve is identical to the corresponding return value from NDSolve, notably, a list of InterpolatingFunctions's",
"If the model does contain events, a list of InterpolationSet's is returned",
"At the present time delay and timeUnits fields in events are not supported by SBMLNDSolve. It is anticipated that this functionality will be added in a later version."
}];


dataTable::usage="dataTable[variable,{t, t1, t2, dt}, solution, options] returns a table of data values for a given variable or set of variables from a solution set at times t=t1, t1+dt, t1+2dt,...,[t2]; a point at t2 will only be in the data if (t2-t1)/dt is an integer.\nsolution is the output of SBMLNDSolve\nvariable is the name of the variable, or a list of variables to be tabulated\nExample:\ncvsTable[{A,B,C},{t,0,1, 0.2}, r]\nwill list the variables A, B and C from the solution r\n\nOptions:\nfile\[Rule]output file name; write the output to the specified file instead of the screen. If the file already exists, an similar file name is used.\nformat\[Rule]output format to use. Allowed values are:\n\"CSV\", comma separated values\n\"HDF\",heirarchical data format (column headers deleted)\n\"LIST\",a text file containing Mathematica lists\n \"MAT\", MAT matrix file format (column headers deleted)\n\"NB\",as a Mathematica Notebook\n\"TSV\",tab separated values\n\"TABLE\",white-space separated values.\n";


conservationMatrix::usage="conservationMatrix[s] returns the conservation matrix, given the stoichiometry matrix s.";


SBMLPlot::usage="SBMLPlot[solution, {var1, var2,...}, {tbegin, tend}, options] plots the results of a simulation.\nsolution is either the output of SBMLNDSolve or the output of an SBMLRead run with numerical solution enabled.\nThe variables named var1, var2,.. are plotted from t=tbegin to t=tend on a single plot. The context of the variable name must be specified, i.e., if the model identifier is foo, to plot variables A and C only but not any other variable, one would invoke SBMLPlot[solution, {foo`A,foo`C}, {tbegin,tend}].\n"<>
"SBMLPlot[solution,{tbegin,tend}, options] plots all variables in the solution set for the specified time range.\n"<>
"SBMLPlot[solution,variable,options] and \nSBMLPlot[solution,variable,{tbegin,tend},options], where the context of the variable is omitted, will Plot a single variable in the solution.\n"<>
"SBMLPlot[solution,options] plots all variables for the entire duration of the run.\n"<>
"SBMLPLot[InterpolationSet[..], arguments] where any of the above formats for the arguments following solution is valid\n"<>"SBMLPlot[{InterpolationSet[..],InterpolationSet[...],...}] plots the solution of all variables across a set of sequential InterpolationSet's produced by SBMLNDSolve\n "<>"\nAny valid option for Plot may be used.\n\n\!\(\*
StyleBox[\"Additional\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"options\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\":\",\nFontVariations->{\"Underline\"->True}]\)\n"<>
"variables\[Rule] var or {var1, var2, ...} or \"All\"; gives the names of the variables to be plotted. If this option is omitted all variables are plotted. The context of the variable name must be specified, i.e., if the model identifier is foo, to plot variables A and C only but not any other variable, one would specify variables\[Rule]{foo`A,foo`C}. If any of the variable names is All then all variables will be plotted. Note: This option is only available in SBMLPlot[solution,options] form. \n"<>"holdLegend->False, if True, don't print the legend.\n"<>"PlotStyles->{styles1,styles2,...} where each of styles1,styles2,... is a list of styles (values for PlotStyle) for variable1, variable2,...,e.g., SBMLPlot[...,PlotStyles-> {{Green},{Blue,Dashing[{.02}]}},...] will plot the first variable as a solid green line, and the second variable as a dashed blue line. The length of the list given to PlotStyles must be the same as the number of variables being plotted."<>
"\ntype\[Rule]\"Log\", if specified, the y-axis is logarithmic. " ;
SBMLGridPlot::usage="SBMLGridPlot[solution,options]\nSBMLGridPlot[Solution,{var1,var2,...},options]\nSBMLGridPlot[solution,variable,{tbegin,tend},options]\nThese functions will plot each specified variable (or the entire solution set) for the specified times (or the entire time span) on a separate graph, with the top of the graph labeled with the variable name. The plots will be arranged on a grid with three plots per line. The context of the variables should not be included in the list of variable names. \nOptions include:\ncolumns->3, number of plots per line\nAny valid option for Plot may also be used.";
SBMLListPlot::usage="\[IndentingNewLine]SBMLListPlot[vars,{t,tmin,tmax, dt}, sol, opt] interpolates the output of SBMLNDSolve (with or without events) and generates a plot using Mathematica's ListPlot function rather than Plot.\nvars is a list of variables.\nt is the time variable\ntmin is the lower plot limit\ntmax is the upper plot limit\ndt is the interpolation interval\nsol is the the output of SBMLNDSolve\nopt is a sequence of options that may contain any valid options for ListPlot or Graphics. Since the default option of ListPlot is PlotJoined->False, the points will not be connected with a line unless PlotJoined->True.\nEach variable will be plotted a different color.\nIn the present version no legend is printed."


SBMLWrite::usage="SBMLWrite[optons] will write a model in a specified format as determined by the options. \n\nOptions are:\n"<>
"\n\!\(\*
StyleBox[\"inputfile\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\), name of SBML file that is to be converted (read).An inputfile is required. "<>
"\n\!\(\*
StyleBox[\"output\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"file\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\), name of file that output is written to. If not specified, the output is written to the screen"<>
"\n\!\(\*
StyleBox[\"format\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\), type of output to produce. If no format is specified or an invalid format is specified the original model will be returned. Valid formats are:\"BerkeleyMadonna\", \"Fortran\", \"HTML\", \"XPP\" (the value of format is case-insensitve). It is anticipated that other formats will be added in future releases."<>
"\nThere are additional options for some formats.\n"<>
"\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"for\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"BerkeleyMadonma\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"format\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)"<>
numerizedList[{"The following additional options are available:DT, METHOD,STARTIME, STOPTIME. These correspond to the values of the Berkeley Madonna control variables by the same name.",
"The output is a text file that contains text that can be pasted into a Berkeley Madonna Equation window. It is not a \"clickable\" Berkeley Madonna input file, which does not have text format.",
"All reactions are translated into differential equations and combined with rules, in the same manner that this is normally performed by SBMLRead. Only the resulting differential equations are written to the output file, and not the reactions.",
"Events and units are not processed in the current version.","Parameters or initial conditions that are not set in the model will be assigned a value of zero in the Berkeley Madonna file."}]<>
"\n\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"for\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"XPP\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"format\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)"<>numerizedList[{"XPP implmentation is limited to ODEs, parameters, and intial condtions. It is anticipated that more complex forms will be allowed in future release of MathSBML.",
"SBML functions are not implemented in XPP files. Instead, they are instantiated in place.","By default, assignment rules are not instantiated before evaluation. To force evaluate of assignment rules, use the option evaluateParameters\[Rule]True. This will also force evaluation of all parameters.","SBML events are not implemented in XPP files.","Parameters or initial conditions that are not set in the model will be assigned a value of Indeterminate in the XPP file, which is not a valid XPP value."}]<>"\n\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"for\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Fortran\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Format\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\":\",\nFontColor->RGBColor[0, 0, 1]]\)"<>numerizedList[{"Fortran format is developmental", 
"The output file will contain the three subroutines res, addp, and jac required by lsodi", "Documentation of lsodi can be found at http://netlib.org/alliant/ode/prog/lsodi.f","The output file will also contain a subroutine init that sets the initial condition.",
"The output file also contains two modules for each event in the file, a logical function trigger_\!\(\*
StyleBox[\"<\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"event\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\">\",\nFontSlant->\"Italic\"]\) that returns the boolean value of the event's trigger given the values of all the system's state variables, and a subroutine activate_\!\(\*
StyleBox[\"<\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"event\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\">\",\nFontSlant->\"Italic\"]\) that modifies the system's state variables as per the event.","The user is expected implement his/her own driver software that utilizes the event files and calls lsodi or some other solver as required. An example (without events) is provided in the lsodi documentation.","Because lsodi does not directly support events, if the model contains events the user will need to write wrappers for the subroutines provided that make them compatible with his/her chosen solver.",
"Parameters in the model such as foo`k and foo`r1`k will become fooxk and fooxr1xk"}]<>"\n\n\!\(\*
StyleBox[\"Notes\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"on\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"HTML\",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[0, 0, 1]]\)\!\(\*
StyleBox[\"Format\",\nFontColor->RGBColor[0, 0, 1]]\)"<>
"\nThe following addtional options is available:"<>"\n\!\(\*
StyleBox[\"stylesheet\",\nFontColor->RGBColor[0, 0, 1]]\)\[Rule]\!\(\*
StyleBox[\"string\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"(\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"only\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"when\",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Plain\"]\)\!\(\*
StyleBox[\"format\",\nFontSlant->\"Plain\"]\)\[Rule]\"HTML\"),Name of style sheet to reference for HTML output.\nstylesheet\[Rule]\"none\" do not include styles and do not refer to a style sheet\nstylesheet\[Rule]\"inline\" (default) means include the contents of a default style sheet within the file itself rather than referring to an external style sheet.\n"<>"The following styles are used and may be defined by the user in the user-defined style sheet: "<>"body,div,td.sbml-tag-title, td.sbml-model-notes,td.sbml-column-data,td.sbml-column-head, table.sbml-table,p.file-information, span.file-information-label. See the examples on the mathsbml web page for more details.";


SBMLCopy::usage="SBMLCopy[input, output, options] makes a copy of an SBML file to another SBML file, filtering the file through Mathematica's XML support to pretty-print the output in a more readable form.  The content of the XML is unchanged, but the formatting/indentation is standardized. The names of the file must be specified as strings.\nIf the output file already exists the output will be displayed on the screen. When checking for a pre-existing output file, the comparison is case-insensitive.\nSBMLCopy[input] will write the output to the screen instead of to a file.\n\n\!\(\*
StyleBox[\"Options\",\nFontVariations->{\"Underline\"->True}]\):\nExportOptions\[Rule]option list\nImportOptions\[Rule]option list\n\n\!\(\*
StyleBox[\"Example\",\nFontVariations->{\"Underline\"->True}]\):SBMLCopy[\"myfile.xml\", \"yourfile.xml\", ImportOptions\[Rule]{CharacterEncoding\[Rule] \"UTF8\", ExportOptions\[Rule]{CharacterEncoding-> \"PrintableASCII\"}]";

ImportOptions::usage="ImportOptions is an option for SBMLCopy, specifying a list of options that should be passed to Import";
ExportOptions::usage="ExportOptions is an option for SBMLCopy, specifying a list of options that should be passed to Export";


mass::usage="mass[\!\(\*SubscriptBox[\(S\), \(1\)]\),\!\(\*SubscriptBox[\(S\), \(2\)]\),...,\!\(\*SubscriptBox[\(S\), \(n\)]\),k] is a predefined rate law for Irreversible Mass Action Kinetics that returns a velocity v=k*\!\(\*SubscriptBox[\(S\), \(1\)]\)*\!\(\*SubscriptBox[\(S\), \(2\)]\)*\!\(\*SubscriptBox[\(S\), \(3\)]\)\!\(\*SubscriptBox[\(\[CenterEllipsis]S\), \(n\)]\);\nmass[k] returns v=k; \nmass[] returns v=1.";



uui::usage="uui[S,\!\(\*SubscriptBox[\(V\), \(m\)]\),\!\(\*SubscriptBox[\(K\), \(m\)]\)] is  is a predefined rate law for Irreversible Simple Michaelis-Mentin Kinetics that returns a velocity v=\!\(\*FractionBox[\(\*SubscriptBox[\(V\), \(m\)]*S\), \(\*SubscriptBox[\(K\), \(m\)] + S\)]\).";
uur::usage="uur[S,P,\!\(\*SubscriptBox[\(V\), \(f\)]\),\!\(\*SubscriptBox[\(V\), \(r\)]\),\!\(\*SubscriptBox[\(K\), \(ms\)]\),\!\(\*SubscriptBox[\(K\), \(mp\)]\)] is a predefined rate law for Uni-Uni Reversible Simple Michaelis-Menten Kinetics that returns a velocity v=\!\(\*FractionBox[\(SubscriptBox[V, f] \((S/\*SubscriptBox[\(K\), \(ms\)])\) - SubscriptBox[V, r] \((P/\*SubscriptBox[\(K\), \(mp\)])\)\), \(1 + \((P/\*SubscriptBox[\(K\), \(mp\)])\) + \((S/\*SubscriptBox[\(K\), \(ms\)])\)\)]\)."


uuhr::usage="uuhr[S,P,\!\(\*SubscriptBox[\(V\), \(f\)]\),\!\(\*SubscriptBox[\(K\), \(m1\)]\),\!\(\*SubscriptBox[\(K\), \(m2\)]\),\!\(\*SubscriptBox[\(K\), \(eq\)]\)] is a predefined rate law for Uni-Uni Reversible Simple Michaelis-Menten Kinetics with Haldane Adjustment. The rate law returned is v=\!\(\*FractionBox[\(\((\*SubscriptBox[\(V\), \(f\)]/m1)\) \((S - P/\*SubscriptBox[\(K\), \(eq\)])\)\), \(1 + S/m1 + P/\*SubscriptBox[\(K\), \(m2\)]\)]\)."


isouur::usage="isouur[S, P, \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(ii\)]\), \!\(\*SubscriptBox[\(K\), \(eq\)]\)]is a predefined rate law for Iso Uni-Uni kinetics. The rate law returned is  \!\(\*FractionBox[\(SubscriptBox[V, f] \((S - P/\*SubscriptBox[\(K\), \(eq\)])\)\), \((S \((1 + P/\*SubscriptBox[\(K\), \(ii\)])\) + SubscriptBox[K, ms] \((1 + P/\*SubscriptBox[\(K\), \(mp\)])\))\)]\)."


hilli::usage="hilli[S, V, K,h] is a predefined rate law for Hill Kinetics. The rate law returned is v= \!\(\*FractionBox[\(V*\*SuperscriptBox[\(S\), \(h\)]\), \(\*SuperscriptBox[\(K\), \(h\)] + \*SuperscriptBox[\(S\), \(h\)]\)]\)."


hillr::usage="hillr[S, P,\!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(S\), \(half\)]\),\!\(\*SubscriptBox[\(P\), \(half\)]\),h, \!\(\*SubscriptBox[\(K\), \(eq\)]\)] is a predefined rate law for reversible Hill kinetics.  The rate law is \!\(\*FractionBox[\(S\\\ \((1 - \*FractionBox[\(P\), \(S\\\ \*SubscriptBox[\(K\), \(eq\)]\)])\)\\\ \*SuperscriptBox[\((\*FractionBox[\(P\), SubscriptBox[\(P\), \(half\)]] + \*FractionBox[\(S\), SubscriptBox[\(S\), \(half\)]])\), \(\(-1\) + h\)]\\\ \*SubscriptBox[\(V\), \(f\)]\), \(\((1 + \*SuperscriptBox[\((\*FractionBox[\(P\), SubscriptBox[\(P\), \(half\)]] + \*FractionBox[\(S\), SubscriptBox[\(S\), \(half\)]])\), \(h\)])\)\\\ \*SubscriptBox[\(S\), \(half\)]\)]\)."


hillmr::usage="hillmr[S, P, M, \!\(\*SubscriptBox[\(S\), \(0.5\)]\), \!\(\*SubscriptBox[\(P\), \(0.5\)]\), \!\(\*SubscriptBox[\(M\), \(0.5\)]\), Vf, Keq, h, \[Alpha]] is a predefined rate law for reversible Hill kinetics with one modifier. The rate law is \!\(\*FractionBox[\(S\\\ \((1 - \*FractionBox[\(P\), \(S\\\ \*SubscriptBox[\(K\), \(eq\)]\)])\)\\\ \*SuperscriptBox[\((\*FractionBox[\(P\), SubscriptBox[\(P\), \(0.5\)]] + \*FractionBox[\(S\), SubscriptBox[\(S\), \(0.5\)]])\), \(\(-1\) + h\)]\\\ \*SubscriptBox[\(V\), \(f\)]\), \(\((\*SubscriptBox[\(K\), \(1\)] + \*SubscriptBox[\(K\), \(2\)])\)\\\ \*SubscriptBox[\(S\), \(0.5`\)]\)]\) where \!\(\*SubscriptBox[\(K\), \(1\)]\)=(\!\(\*FractionBox[\(P\), SubscriptBox[\(P\), \(0.5\)]]\)+\!\(\*FractionBox[\(S\), SubscriptBox[\(S\), \(0.5\)]]\)\!\(\*SuperscriptBox[\()\), \(h\)]\)  and \!\(\*SubscriptBox[\(K\), \(2\)]\)=\!\(\*FractionBox[\(1 + \*SuperscriptBox[\((\*FractionBox[SubscriptBox[\(V\), \(f\)], SubscriptBox[\(M\), \(0.5`\)]])\), \(h\)]\), \(1 + \[Alpha]\\\ \*SuperscriptBox[\((\*FractionBox[SubscriptBox[\(V\), \(f\)], SubscriptBox[\(M\), \(0.5\)]])\), \(h\)]\)]\)."


hillmmr::usage="hillmmr[S, P, M, \!\(\*SubscriptBox[\(S\), \(0.5\)]\), \!\(\*SubscriptBox[\(P\), \(0.5\)]\), \!\(\*SubscriptBox[\(M\), \(0.5\)]\), \!\(\*SubscriptBox[\(M\), \(a\)]\), \!\(\*SubscriptBox[\(M\), SubscriptBox[\(a\), \(0.5\)]]\), \!\(\*SubscriptBox[\(M\), \(b\)]\), \!\(\*SubscriptBox[\(M\), SubscriptBox[\(b\), \(0.5\)]]\), \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(K\), \(eq\)]\), h, a, b, \!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(12\)]\)] is a predefined rate law for reversible Hill Kinetics with Two Modifiers. The Rate Law is \!\(\*FractionBox[\(S\\\ \((1 - \*FractionBox[\(P\), \(S\\\ \*SubscriptBox[\(K\), \(eq\)]\)])\)\\\ \*SuperscriptBox[\((\*FractionBox[\(P\), SubscriptBox[\(P\), \(0.5`\)]] + \*FractionBox[\(S\), SubscriptBox[\(S\), \(0.5`\)]])\), \(\(-1\) + h\)]\\\ \*SubscriptBox[\(V\), \(f\)]\), \(\*SubscriptBox[\(S\), \(0.5`\)]\\\ \((\*SubscriptBox[\(K\), \(1\)] + \*SubscriptBox[\(K\), \(2\)])\)\)]\) where \!\(\*SubscriptBox[\(K\), \(1\)]\)=(P/\!\(\*SubscriptBox[\(P\), \(0.5\)]\)+S/\!\(\*SubscriptBox[\(S\), \(0.5\)]\)\!\(\*SuperscriptBox[\()\), \(h\)]\)  and \!\(\*SubscriptBox[\(K\), \(2\)]\)=(1+\!\(\*SuperscriptBox[\((\*SubscriptBox[\(M\), \(a\)]/\*SubscriptBox[\(M\), SubscriptBox[\(a\), \(0.5\)]])\), \(h\)]\)+\!\(\*SuperscriptBox[\((\*SubscriptBox[\(M\), \(b\)]/\*SubscriptBox[\(M\), SubscriptBox[\(b\), \(0.5\)]])\), \(h\)]\))/(1+\!\(\*SuperscriptBox[\((\*SubscriptBox[\(M\), \(a\)]/\*SubscriptBox[\(M\), SubscriptBox[\(a\), \(0.5\)]])\), \(h\)]\) \!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\)+\!\(\*SuperscriptBox[\((\*SubscriptBox[\(M\), \(b\)]/\*SubscriptBox[\(M\), SubscriptBox[\(b\), \(0.5\)]])\), \(h\)]\) \!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\)+\!\(\*SuperscriptBox[\((\*SubscriptBox[\(M\), \(a\)]/\*SubscriptBox[\(M\), SubscriptBox[\(a\), \(0.5\)]])\), \(h\)]\) \!\(\*SuperscriptBox[\((\*SubscriptBox[\(M\), \(b\)]/\*SubscriptBox[\(M\), SubscriptBox[\(b\), \(0.5\)]])\), \(h\)]\) \!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\) \!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\) \!\(\*SubscriptBox[\(\[Alpha]\), \(12\)]\))"


usii::usage="usii[S,V,\!\(\*SubscriptBox[\(K\), \(m\)]\),\!\(\*SubscriptBox[\(K\), \(i\)]\)] is a predefined rate law for substrate inhibition kinetics (irreversible).  The rate law returned is \!\(\*FractionBox[\(S\\\ V\), \(\((1 + \*FractionBox[SuperscriptBox[\(S\), \(2\)], SubscriptBox[\(K\), \(i\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\). "


usir::usage="usir[S,P,\!\(\*SubscriptBox[\(V\), \(f\)]\),\!\(\*SubscriptBox[\(V\), \(r\)]\),\!\(\*SubscriptBox[\(K\), \(ms\)]\),\!\(\*SubscriptBox[\(K\), \(mp\)]\),\!\(\*SubscriptBox[\(K\), \(i\)]\)] is a predefined rate law for substrate inhibition kinetics (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] + \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \*FractionBox[SuperscriptBox[\(S\), \(2\)], SubscriptBox[\(K\), \(i\)]] + \*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]]\)]\)."


uai::usage="uai[S,V,\!\(\*SubscriptBox[\(K\), \(sa\)]\),\!\(\*SubscriptBox[\(K\), \(sc\)]\)] is a predefined rate law for substrate activation. The rate law returned is \!\(\*FractionBox[\(\*SuperscriptBox[\(S\), \(2\)]\\\ V\), \(\*SubsuperscriptBox[\(K\), \(sa\), \(2\)]\\\ \((1 + \*FractionBox[SuperscriptBox[\(S\), \(2\)], SubsuperscriptBox[\(K\), \(sa\), \(2\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(sa\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(sc\)]])\)\)]\)."


ucii::usage="ucii[S,V,Inh, \!\(\*SubscriptBox[\(K\), \(m\)]\),\!\(\*SubscriptBox[\(K\), \(i\)]\)] is a predefined rate law for competitive inhibition (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\), \(\((1 + Inh/\*SubscriptBox[\(K\), \(i\)] + S/\*SubscriptBox[\(K\), \(m\)])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


ucir::usage="ucir[S, P,Inh, \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(i\)]\)] is a predefined rate law for competitive inhibition (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(i\)]] + \*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]]\)]\)."


unii::usage="unii[S, Inh, V, \!\(\*SubscriptBox[\(K\), \(m\)]\),\!\(\*SubscriptBox[\(K\), \(i\)]\)]is a predefined rate law for noncompetitive inhibition (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\), \(\((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(i\)]] + \*FractionBox[\(S\\\ \((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(i\)]])\)\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


unir::usage="unir[S, P, Inh, \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(\(r\)\(,\)\(\\\ \)\)]\)\!\(\*SubscriptBox[\(K\), \(ms\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(i\)]\)] is a predefined rate law for noncompetitive inhibition (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(i\)]] + \((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(i\)]])\)\\\ \((\*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]])\)\)]\) ."


uuci::usage="uuci[S,Inh,V,\!\(\*SubscriptBox[\(K\), \(m\)]\),\!\(\*SubscriptBox[\(K\), \(i\)]\)] is a predefined rate law for uncompetitive inhibition (irreversible). The rate law returned is  \!\(\*FractionBox[\(S\\\ V\), \(\((1 + \*FractionBox[\(S\\\ \((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(i\)]])\)\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


uucr::usage="uucr[S,P,Inh,\!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\),\!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(i\)]\)] is a predefined rate law for uncompetitive inhibition (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(i\)]])\)\\\ \((\*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]])\)\)]\)."


umi::usage="umi[S,Inh,V,\!\(\*SubscriptBox[\(K\), \(m\)]\), \!\(\*SubscriptBox[\(K\), \(is\)]\), \!\(\*SubscriptBox[\(K\), \(ic\)]\)] is a predefined rate law for mixed inhibition kinetics (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\), \(\((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(is\)]] + \*FractionBox[\(S\\\ \((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(ic\)]])\)\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


umr::usage="umr[S,P,Inh,\!\(\*SubscriptBox[\(V\), \(f\)]\),\!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\),\!\(\*SubscriptBox[\(K\), \(mp\)]\),  \!\(\*SubscriptBox[\(K\), \(is\)]\), \!\(\*SubscriptBox[\(K\), \(ic\)]\)] is a predefined rate law for mixed inhibition kinetics (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(is\)]] + \((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(ic\)]])\)\\\ \((\*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]])\)\)]\)."


uaii::usage="uaii[S, \!\(\*SubscriptBox[\(A\), \(c\)]\),V,\!\(\*SubscriptBox[\(K\), \(m\)]\),\!\(\*SubscriptBox[\(K\), \(a\)]\)] is a predefined rate law for specific action kinetics (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\), \(\((1 + \*FractionBox[SubscriptBox[\(K\), \(a\)], SubscriptBox[\(A\), \(c\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


uar::usage="uar[S,P,\!\(\*SubscriptBox[\(A\), \(c\)]\),\!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(a\)]\)] is a predefined rate law for specific action kinetics (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \*FractionBox[SubscriptBox[\(K\), \(a\)], SubscriptBox[\(A\), \(c\)]] + \*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]]\)]\)."


ucti::usage="ucti[S, \!\(\*SubscriptBox[\(A\), \(c\)]\), V, \!\(\*SubscriptBox[\(K\), \(m\)]\), \!\(\*SubscriptBox[\(K\), \(a\)]\)] is a predefined rate law for catalytic activation (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\), \(\((1 + \*FractionBox[SubscriptBox[\(K\), \(a\)], SubscriptBox[\(A\), \(c\)]] + \*FractionBox[\(S\\\ \((1 + \*FractionBox[SubscriptBox[\(K\), \(a\)], SubscriptBox[\(A\), \(c\)]])\)\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


uctr::usage="uctr[S, P, \!\(\*SubscriptBox[\(A\), \(c\)]\), \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(a\)]\)] is a predefined rate law for catalytic activation (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \*FractionBox[SubscriptBox[\(K\), \(a\)], SubscriptBox[\(A\), \(c\)]] + \((1 + \*FractionBox[SubscriptBox[\(K\), \(a\)], SubscriptBox[\(A\), \(c\)]])\)\\\ \((\*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]])\)\)]\)."


umai::usage="umai[S, \!\(\*SubscriptBox[\(A\), \(c\)]\), V, \!\(\*SubscriptBox[\(K\), \(m\)]\), \!\(\*SubscriptBox[\(K\), \(as\)]\), \!\(\*SubscriptBox[\(K\), \(ac\)]\)] is a predefined rate law for mixed activation kinetics (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\), \(\((1 + \*FractionBox[SubscriptBox[\(K\), \(as\)], SubscriptBox[\(A\), \(c\)]] + \*FractionBox[\(S\\\ \((1 + \*FractionBox[SubscriptBox[\(K\), \(ac\)], SubscriptBox[\(A\), \(c\)]])\)\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


umar::usage="umar[S, P, \!\(\*SubscriptBox[\(A\), \(c\)]\), \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(as\)]\), \!\(\*SubscriptBox[\(K\), \(ac\)]\)] is a predefined rate law for mixed activation kinetics (reversible). The rate law returned is \!\(\*FractionBox[\(\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]]\), \(1 + \*FractionBox[SubscriptBox[\(K\), \(as\)], SubscriptBox[\(A\), \(c\)]] + \((1 + \*FractionBox[SubscriptBox[\(K\), \(ac\)], SubscriptBox[\(A\), \(c\)]])\)\\\ \((\*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]])\)\)]\)."


uhmi::usage="uhmi[S, M, V, \!\(\*SubscriptBox[\(K\), \(m\)]\), \!\(\*SubscriptBox[\(K\), \(d\)]\), a, b] is a predefined rate law for general hyperbolic modifier kinetics (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\\\ \((1 + \*FractionBox[\(b\\\ M\), \(a\\\ \*SubscriptBox[\(K\), \(d\)]\)])\)\), \(\((1 + \*FractionBox[\(M\), SubscriptBox[\(K\), \(d\)]] + \*FractionBox[\(S\\\ \((1 + \*FractionBox[\(M\), \(a\\\ \*SubscriptBox[\(K\), \(d\)]\)])\)\), SubscriptBox[\(K\), \(m\)]])\)\\\ \*SubscriptBox[\(K\), \(m\)]\)]\)."


uhmr::usage="uhmr[S, P, M,\!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ms\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(d\)]\), a, b] is a predefined rate law for general hyperbolic modifier kinetics (reversible). The rate law returned is \!\(\*FractionBox[\(\((1 + \*FractionBox[\(b\\\ M\), \(a\\\ \*SubscriptBox[\(K\), \(d\)]\)])\)\\\ \((\*FractionBox[\(S\\\ \*SubscriptBox[\(V\), \(f\)]\), SubscriptBox[\(K\), \(ms\)]] - \*FractionBox[\(P\\\ \*SubscriptBox[\(V\), \(r\)]\), SubscriptBox[\(K\), \(mp\)]])\)\), \(1 + \*FractionBox[\(M\), SubscriptBox[\(K\), \(d\)]] + \((1 + \*FractionBox[\(M\), \(a\\\ \*SubscriptBox[\(K\), \(d\)]\)])\)\\\ \((\*FractionBox[\(P\), SubscriptBox[\(K\), \(mp\)]] + \*FractionBox[\(S\), SubscriptBox[\(K\), \(ms\)]])\)\)]\)."


ualii::usage="ualii[S, Inh, V, \!\(\*SubscriptBox[\(K\), \(s\)]\), \!\(\*SubscriptBox[\(K\), \(ii\)]\), n, L] is a predefined rate law for allosteric inhibition (irreversible). The rate law returned is \!\(\*FractionBox[\(S\\\ V\\\ \*SuperscriptBox[\((1 + \*FractionBox[\(S\), SubscriptBox[\(K\), \(s\)]])\), \(\(-1\) + n\)]\), \(\((L\\\ \*SuperscriptBox[\((1 + \*FractionBox[\(Inh\), SubscriptBox[\(K\), \(ii\)]])\), \(n\)] + \*SuperscriptBox[\((1 + \*FractionBox[\(S\), SubscriptBox[\(K\), \(s\)]])\), \(n\)])\)\\\ \*SubscriptBox[\(K\), \(s\)]\)]\)."


ordubr::usage="ordubr[A, P, Q, \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ma\)]\), \!\(\*SubscriptBox[\(K\), \(mq\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(ip\)]\),\!\(\*SubscriptBox[\(K\), \(eq\)]\)] is a predefined rate for Ordered Uni-Bi Kinetics. The rate law returned is \!\(\*FractionBox[\(\((A - \*FractionBox[\(P\\\ Q\), SubscriptBox[\(K\), \(eq\)]])\)\\\ \*SubscriptBox[\(V\), \(f\)]\), \(A\\\ \((1 + \*FractionBox[\(P\), SubscriptBox[\(K\), \(ip\)]])\) + \*SubscriptBox[\(K\), \(ma\)] + \*FractionBox[\(\((P\\\ Q + Q\\\ \*SubscriptBox[\(K\), \(mp\)] + P\\\ \*SubscriptBox[\(K\), \(mq\)])\)\\\ \*SubscriptBox[\(V\), \(f\)]\), \(\*SubscriptBox[\(K\), \(eq\)]\\\ \*SubscriptBox[\(V\), \(r\)]\)]\)]\)."


ordbur::usage="ordbur[A, B, P, \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ma\)]\), \!\(\*SubscriptBox[\(K\), \(mb\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(ia\)]\), \!\(\*SubscriptBox[\(K\), \(eq\)]\)] is a predefined rate for Ordered Bi-Uni Kinetics. The rate law returned is \!\(\*FractionBox[\(\((A\\\ B - \*FractionBox[\(P\), SubscriptBox[\(K\), \(eq\)]])\)\\\ \*SubscriptBox[\(V\), \(f\)]\), \(A\\\ B + B\\\ \*SubscriptBox[\(K\), \(ma\)] + A\\\ \*SubscriptBox[\(K\), \(mb\)] + \*FractionBox[\(\((P\\\ \((1 + \*FractionBox[\(A\), SubscriptBox[\(K\), \(ia\)]])\) + \*SubscriptBox[\(K\), \(mp\)])\)\\\ \*SubscriptBox[\(V\), \(f\)]\), \(\*SubscriptBox[\(K\), \(eq\)]\\\ \*SubscriptBox[\(V\), \(r\)]\)]\)]\) ."


ordbbr::usage="ordbbr[A, B, P, Q, \!\(\*SubscriptBox[\(V\), \(f\)]\), \!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(mA\)]\),\!\(\*SubscriptBox[\(K\), \(mB\)]\), \!\(\*SubscriptBox[\(K\), \(mP\)]\), \!\(\*SubscriptBox[\(K\), \(mQ\)]\), \!\(\*SubscriptBox[\(K\), \(iA\)]\),  \!\(\*SubscriptBox[\(K\), \(iB\)]\), \!\(\*SubscriptBox[\(K\), \(iP\)]\), \!\(\*SubscriptBox[\(K\), \(eq\)]\)] is a predefined rate for Ordered Bi-Bi Kinetics. The rate law returned is \!\(\*FractionBox[\(\((A\\\ B - PQ/\*SubscriptBox[\(K\), \(eq\)])\)\\\ \*SubscriptBox[\(V\), \(f\)]\), \(A\\\ B\\\ \((1 + P/\*SubscriptBox[\(K\), \(iP\)])\) + B\\\ \*SubscriptBox[\(K\), \(mA\)] + \((A + \*SubscriptBox[\(K\), \(iA\)])\)\\\ \*SubscriptBox[\(K\), \(mB\)] + \*SubscriptBox[\(K\), \(1\)]\)]\) where \!\(\*SubscriptBox[\(K\), \(1\)]\)=(\!\(\*SubscriptBox[\(V\), \(f\)]\)/(\!\(\*SubscriptBox[\(K\), \(eq\)]\)\!\(\*SubscriptBox[\(V\), \(r\)]\)))(Q \!\(\*SubscriptBox[\(K\), \(2\)]\)+P (1+A/\!\(\*SubscriptBox[\(K\), \(iA\)]\)) \!\(\*SubscriptBox[\(K\), \(mQ\)]\)) and \!\(\*SubscriptBox[\(K\), \(2\)]\)=(1+P (1+B/\!\(\*SubscriptBox[\(K\), \(iB\)]\))+\!\(\*SubscriptBox[\(BK\), \(mA\)]\)/(\!\(\*SubscriptBox[\(K\), \(iA\)]\)\!\(\*SubscriptBox[\(K\), \(mB\)]\))) \!\(\*SubscriptBox[\(K\), \(mP\)]\)."


ppbr::usage="ppbr[A, B, P, Q, \!\(\*SubscriptBox[\(V\), \(f\)]\),\!\(\*SubscriptBox[\(V\), \(r\)]\), \!\(\*SubscriptBox[\(K\), \(ma\)]\), \!\(\*SubscriptBox[\(K\), \(mb\)]\), \!\(\*SubscriptBox[\(K\), \(mp\)]\), \!\(\*SubscriptBox[\(K\), \(mq\)]\), \!\(\*SubscriptBox[\(K\), \(ia\)]\),\!\(\*SubscriptBox[\(K\), \(iq\)]\), \!\(\*SubscriptBox[\(K\), \(eq\)]\)] is a predefined rate for Ping-Pong Bi-Bi Kinetics. The rate law returned is \!\(\*FractionBox[\(\((A\\\ B - \*FractionBox[\(P\\\ Q\), SubscriptBox[\(K\), \(eq\)]])\)\\\ \*SubscriptBox[\(V\), \(f\)]\), \(A\\\ B + B\\\ \((1 + \*FractionBox[\(Q\), SubscriptBox[\(K\), \(iq\)]])\)\\\ \*SubscriptBox[\(K\), \(ma\)] + A\\\ \*SubscriptBox[\(K\), \(mb\)] + \*FractionBox[\(\((Q\\\ \((P + \*SubscriptBox[\(K\), \(mp\)])\) + P\\\ \((1 + \*FractionBox[\(A\), SubscriptBox[\(K\), \(ia\)]])\)\\\ \*SubscriptBox[\(K\), \(mq\)])\)\\\ \*SubscriptBox[\(V\), \(f\)]\), \(\*SubscriptBox[\(K\), \(eq\)]\\\ \*SubscriptBox[\(V\), \(r\)]\)]\)]\)."


setEcho::usage="";
hideEcho::usage="";


newModel::usage="newModel[options] resets all counters and variables used by the MathSBML Model Builder. If any previous model has been constructed using add_ functions, it is erased.\nnewModel[x,options], where x is an identifier or string, is interpreted as newModel[id->x, options].\nOptions include:\nid->string, model id\nname->string, model name\nnotes->string, model notes\ncomments->string, comments to add to beginning of file."<>"\ncreator\[Rule]{family, given, email, org} data for MIRIAM creator annotation. Overrides MIRIAM` options\nMIRIAM`Given\[Rule]string\nMIRIAM`Family\[Rule]string\nMIRIAM`EMAIL\[Rule]string\nMIRIAM`Orgname\[Rule]string";


reactionToSBML::usage="reactionToSBML[options] returns the SBML for a <reaction.../>.\nreactionToSBML[r,options] is identical to reactionToSBML[reaction-> r, options].\nreactionToSBML[{{options},{options},...}] returns a <listOfReactions.../>, where each option list describes a different reaction. Alternatively the first argument in any option list may be a reaction, which in this case does not have be preceded by the reaction keyword.\n\nEach {options} is either {optionList} or {reaction, optionList}, where reaction has the form \!\(\*SubscriptBox[\(\[CapitalSigma]e\), \(i\)]\)\!\(\*SubscriptBox[\(r\), \(i\)]\)->\!\(\*SubscriptBox[\(\[CapitalSigma]s\), \(i\)]\)\!\(\*SubscriptBox[\(p\), \(i\)]\). If any option list does not have either the reactions option or at least one the reactants or products options,the first element in options is assumed to be a rule describing the reaction.\n\nAvailable Options:\n"<>
"reaction->(\!\(\*SubscriptBox[\(\[CapitalSigma]e\), \(i\)]\)\!\(\*SubscriptBox[\(r\), \(i\)]\)->\!\(\*SubscriptBox[\(\[CapitalSigma]s\), \(i\)]\)\!\(\*SubscriptBox[\(p\), \(i\)]\)), where \!\(\*SubscriptBox[\(r\), \(i\)]\) and \!\(\*SubscriptBox[\(p\), \(i\)]\) are names of of reactants and products; and \!\(\*SubscriptBox[\(e\), \(i\)]\) and \!\(\*SubscriptBox[\(s\), \(\(i\)\(\\\ \)\)]\)are the corresponding stoichiometry expressions. The stoichiometry expressions must be either a number or have the form Stoichiometry[expr] where expr is any expression. If the option reaction is used then the options reactants, products, reactantStoichiometry, and productStoichiometry are ignored.\n"<>
"id \[Rule]string - required reaction identifier, no default\n"<>"name\[Rule] string - reaction name.\n"<>"reactants\[Rule] {} (none, default), r,  or {\!\(\*SubscriptBox[\(r\), \(1\)]\), \!\(\*SubscriptBox[\(r\), \(2\)]\), ....}, names of reactants. This option is ignored if the option reaction is used.\n"<>
"products\[Rule] {} (none, default), p,  or {\!\(\*SubscriptBox[\(p\), \(1\)]\), \!\(\*SubscriptBox[\(p\), \(2\)]\), ....}, names of products. This option is ignored if the option reaction is used.\n"<>
"modifiers\[Rule] {} (none, default), m,  or {\!\(\*SubscriptBox[\(m\), \(1\)]\), \!\(\*SubscriptBox[\(m\), \(2\)]\), ....}, names of modifiers\n"<>
"reactantStoichiometry\[Rule]integer, expression, {\!\(\*SubscriptBox[\(e\), \(1\)]\),\!\(\*SubscriptBox[\(e\), \(2\)]\),..}, where  \!\(\*SubscriptBox[\(e\), \(j\)]\) is any expression. The stoichiometries are listed in the same order as the names of the reactants. If fewer stoichiometries then reactants are specified the remaining reactants are assigned a stoichiometry of 1. . This option is ignored if the option reaction is used.\n"<>
"productStoichiometry\[Rule]integer, expression, {\!\(\*SubscriptBox[\(e\), \(1\)]\),\!\(\*SubscriptBox[\(e\), \(2\)]\),..}, where  \!\(\*SubscriptBox[\(e\), \(j\)]\) is any expression. The stoichiometries are listed in the same order as the names of the products. If fewer stoichiometries then producrts are specified the remaining products are assigned a stoichiometry of 1.. This option is ignored if the option reaction is used. \n"<>"kineticLaw\[Rule] any expression (no default); if no kinetic law is specified, none is included in the SBML; alternatively, kineticLaw\[Rule]{\"math\"\[Rule]expression, \"annotation\"\[Rule]list of symbolic XML containing annotations.\n"<>"parameters->{\!\(\*SubscriptBox[\(i\), \(1\)]\)\[Rule]\!\(\*SubscriptBox[\(o\), \(1\)]\),\!\(\*SubscriptBox[\(i\), \(2\)]\)\[Rule]\!\(\*SubscriptBox[\(o\), \(3\)]\),...}, where \!\(\*SubscriptBox[\(i\), \(1\)]\),\!\(\*SubscriptBox[\(i\), \(2\)]\),... are the ids of the parameters, and \!\(\*SubscriptBox[\(o\), \(1\)]\),\!\(\*SubscriptBox[\(o\), \(2\)]\),... are option lists of the form {name\[Rule]\!\(\*SubscriptBox[\(v\), \(1\)]\),value\[Rule]\!\(\*SubscriptBox[\(v\), \(2\)]\), units\[Rule]\!\(\*SubscriptBox[\(v\), \(3\)]\), constant\[Rule]\!\(\*SubscriptBox[\(v\), \(4\)]\), annotation\[Rule]\!\(\*SubscriptBox[\(v\), \(5\)]\)}, or any subset thereof, where \!\(\*SubscriptBox[\(v\), \(1\)]\),etc., are the values of the name, value, units and constant field.\n"<>"reversible\[Rule]True\nfast\[Rule]False\n\nExample:\nreactionToSBML[reaction\[Rule] (A+2B\[Rule] C),kineticLaw\[Rule] k*A*B,parameters\[Rule] {k\[Rule] {value\[Rule] 12,name\[Rule] \"Rate Constant\"}}]\n\n"<>"<reaction id=\"reaction2\"\n    name=\"reaction2\"\n    reversible=\"true\"\n    fast=\"false\">\n <listOfReactants>\n  <speciesReference species=\"A\"/>\n  <speciesReference species=\"B\">\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <cn type=\"integer\">2</cn>\n   </math>\n  </speciesReference>\n </listOfReactants>\n <listOfProducts>\n  <speciesReference species=\"C\"/>\n </listOfProducts>\n <listOfModifiers/>\n <kineticLaw timeUnits=\"time\"\n     substanceUnits=\"substance\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <times/>\n    <ci>A</ci>\n    <ci>B</ci>\n    <ci>k</ci>\n   </apply>\n  </math>\n  <listOfParameters>\n   <parameter id=\"k\"\n       value=\"12\"\n       name=\"Rate Constant\"/>\n  </listOfParameters>\n </kineticLaw>\n</reaction>";


speciesToSBML::usage="speciesToSBML[options] returns an SBML <species ... /> definition\nspeciesToSBML[x,options], where x is an identifier or string, is interpreted as speciesToSBML[id->x,options]\n"<>"speciesToSBML[{{options}, {options},...}] returns an SBML <listOfSpecies .../> block for a set of species described by the option lists.\n"<>"Options have the same names as the SBML fields for species: id, name, metaid, compartment, initialAmount, initialConcentration, units, boundaryCondition, charge, constant, annotation, notes. If both a concentration and an amount are given, the first one in the option list is assumed to be the correct one."<>
"\n\nThe following PROPOSED LEVEL 3 option is allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default)."<>
"\n\n\!\(\*
StyleBox[\"Example\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"1\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"(\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"single\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"species\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\")\",\nFontVariations->{\"Underline\"->True}]\):\n\n"<>"speciesToSBML[id\[Rule] \"fred\", name\[Rule] \"Fred Flintstone\", compartment\[Rule] \"bedrock\" , boundaryCondition\[Rule] \"false\", constant\[Rule] \"true\", initialConcentration\[Rule]5, units\[Rule] \"rocks\" , charge\[Rule]17]\n\n"<>"returns the string\n\n"<>"<species id=\"fred\" name=\"Fred Flintstone\" compartment=\"bedrock\" boundaryCondition=\"false\" constant=\"true\" initialConcentration=\"5\" units=\"rocks\" charge=\"17\"/>"<>"\n\n\!\(\*
StyleBox[\"Example\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"2\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"(\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"multiple\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"species\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\")\",\nFontVariations->{\"Underline\"->True}]\):\n\n"<>"speciesToSBML[{{id\[Rule] \"fred\", compartment\[Rule] \"bedrock\"}, {id\[Rule] \"barney\",compartment\[Rule] \"bedrock\"}}]\n\nreturns the string\n\n"<>"<listOfSpecies>\n <species id=\"fred\"\n     name=\"fred\"\n     compartment=\"bedrock\"\n     boundaryCondition=\"false\"\n     constant=\"false\"/>\n <species id=\"barney\"\n     name=\"barney\"\n     compartment=\"bedrock\"\n     boundaryCondition=\"false\"\n     constant=\"false\"/>\n</listOfSpecies>";


speciesTypeToSBML::usage="speciesTypeToSBML[options] returns the SBML for a speciesType. Options include:"<>"\nid->Sid\nname->optional string."


functionToSBML::usage="functionToSBML[options] returns an SBML string for a <functionDefinition ... /> definition.\n"<>"functionToSBML[{{options}, {options},...}] returns an SBML string for a <listOfFunctionDefinitions ... />\n\nOptions:\narguments\[Rule]x or {\!\(\*SubscriptBox[\(x\), \(1\)]\),\!\(\*SubscriptBox[\(x\), \(2\)]\),...}, names of the function arguments. At least one argument must be supplied. If no arguments are given a single dummy argument will be generated.\nid\[Rule]string, value of SBML id field; if not specified, a name functionk, where k is an incrementing integer, will be supplied.\nmetaid->string,if different from \"\" the metaid will be assigned to the value of the given string.\nmath\[Rule]expression, Mathematica expression for the function return value in terms of the arguments. If not specified, the value of 1 will be returned.\nname\[Rule]string, value of SBML name field if not specified, the value of the id field will be used.\n\nExample 1, <functionDefinition ...>:\n\nfunctionToSBML[id\[Rule] alfafa, arguments\[Rule] {horse, grass}, math\[Rule] ( 1/(horse*grass))]\n\nreturns the string:\n\n"<>"<functionDefinition id=\"alfafa\"\n    name=\"alfafa\">\n <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <lambda>\n   <bvar>\n    <ci>horse</ci>\n   </bvar>\n   <bvar>\n    <ci>grass</ci>\n   </bvar>\n   <apply>\n    <times/>\n    <cn type=\"integer\">1</cn>\n    <apply>\n     <power/>\n     <apply>\n      <times/>\n      <ci>grass</ci>\n      <ci>horse</ci>\n     </apply>\n     <cn type=\"integer\">-1</cn>\n    </apply>\n   </apply>\n  </lambda>\n </math>\n</functionDefinition>"<>"\n\nExample 2, <listOfFunctionDefintions ...>\n\n"<>"functionToSBML[{{id\[Rule] QRT,arguments\[Rule] {x}, math\[Rule] x^(1/4)},{id\[Rule] sinc, arguments\[Rule] {x}, math\[Rule] Sin[x]/x}}]"<>"\n\nreturns the string:\n\n"<>"<listOfFunctionDefinitions>\n <functionDefinition id=\"QRT\"\n     name=\"QRT\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <lambda>\n    <bvar>\n     <ci>x</ci>\n    </bvar>\n    <apply>\n     <power/>\n     <ci>x</ci>\n     <cn type=\"rational\">1<sep/>4</cn>\n    </apply>\n   </lambda>\n  </math>\n </functionDefinition>\n <functionDefinition id=\"sinc\"\n     name=\"sinc\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <lambda>\n    <bvar>\n     <ci>x</ci>\n    </bvar>\n    <apply>\n     <times/>\n     <apply>\n      <sin/>\n      <ci>x</ci>\n     </apply>\n     <apply>\n      <power/>\n      <ci>x</ci>\n      <cn type=\"integer\">-1</cn>\n     </apply>\n    </apply>\n   </lambda>\n  </math>\n </functionDefinition>\n</listOfFunctionDefinitions>";
 


unitToSBML::usage="unitToSBML[options] returns an SBML <unitDefinition .../>.\nunitToSBML[x,options], where x is an identifier or string, is the same as unitToSBML[id->x,options].\nunitToSBML[{{options},{options},...}] returns a <listOfUnitDefinitions ...> where each sub-option list corresponds to the option list of the first form.\nOptions:\nid->no default, value of id field of unitDefiniton, if not specified, supplied by program as unitn, where n is an integer\nname->no default, if not supplied, value of id  is used\nunit->{}, contains an option list of the form \"string\"->{scale->0, exponent->1, multiplier->1, offset->1}, where \"string\" is a quote-delimited string indicated the value of the kind field of the <unit ...> expression.\n\nExample:\n\nunitToSBML[id\[Rule] \"mmlh\",name\[Rule] \"millimoles_per_liter_per_hour\",unit\[Rule] {\"mole\"\[Rule] {scale\[Rule] -3}, \"litre\"\[Rule] {exponent\[Rule] -1}, \"second\"\[Rule] {multiplier\[Rule] 0.000277778, exponent\[Rule] -1}}]";


compartmentToSBML::usage="compartmentToSBML[options] returns a <compartment .../>\ncompartmentToSBML[x, options], where x is an identifier or string, is the same as compartmentToSBML[id->x,options]\ncompartmentToSBML[{{options},{options},...}] returns a <listOfCompartments .../> where each option list corresponds to a single <compartment .../> definition.\nOptions are the same as valid compartment fields: id, name, spatialDimensions, size, untis, outside, constant. Default values are set as per the SBML Level 2 spec."<>"\n\nThe following PROPOSED LEVEL 3 option is allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default)."<>"\n\nExample:\n\ncompartmentToSBML[id\[Rule] \"bedrock\", size\[Rule] \"40000\"]\n\nreturns the string:\n\<compartment id=\"bedrock\" name=\"bedrock\" size=\"40000\"/>\n\nThe input:\n\ncompartmentToSBML[{{id\[Rule] \"c1\",size\[Rule] 5},{id\[Rule] \"c2\",spatialDimensions\[Rule] 2},{id\[Rule] \"c3\",name\[Rule] \"unsized_compartment_3\"}}]\n\nreturns the string:\n\n<listOfCompartments>\n <compartment id=\"c1\"\n     name=\"c1\"\n     size=\"5\"/>\n <compartment id=\"c2\"\n     name=\"c2\"\n     spatialDimensions=\"2\"/>\n <compartment id=\"c3\"\n     name=\"unsized_compartment_3\"/>\n</listOfCompartments>";

setCompartment::usage="setCompartment[name] sets the current compartment to name in the model builder. \nAny subsequent call to addSpecies that specifies a compartment will override this setting.\nAll subsequent calls to addSpecies, until the option compartment is used, will place the species in compartment \"name\".\nsetCompartment[Null] will clear the compartment name stack. The result will be that subsequent species will be added to the first compartment of the model."


initialAssignmentToSBML::usage="initialAssignmentToSBML[options] returns the SBML for an <initiaAssignment>...<../> object. Options are: symbol, math, SBOTerm, metaid, notes, annotation."



compartmentTypeToSBML::usage="compartmentTypeToSBML[options] returns the SBML for a compartmentTYPE. Options include:"<>"\nid->Sid\nname->optional string."


parameterToSBML::usage="parameterToSBML[options] returns a <parameter.../> definition.\nparameterToSBML[x,options], where x is an identifier or string, is interpreted as parameterToSBML[id->x,options].\nparameterToSBML[id\[Rule]value] can be used if value is a number (name will be set to id).\nparameterToSBML[{{options},{options},...}] returns a <listOfParameters.../> where each option list corresponds to a single <parameter.../> definiton. Options are identical to those for a parameter: id, name, value, units, constant."<>"\n\nThe following PROPOSED LEVEL 3 options are allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default).\nforeach->name of compartment array for implied parameter array."<>"\n\nExample:\n\nparameterToSBML[id\[Rule] \"Pi\", name\[Rule] \"pi\",  value\[Rule] 3.14]\n\nreturns\n\n<parameter id=\"Pi\" name=\"pi\" value=\"3.14\"/>\n\nparameterToSBML[{{id\[Rule]\"pi\", value->3.14}, {id\[Rule]\"e\",value\[Rule]2.718}, {id\[Rule]\"E\",name\[Rule]\"Enzyme_Concentration\",constant\[Rule]\"false\",value\[Rule]1}}]\n\nreturns\n\n<listOfParameters>\n <parameter id=\"pi\"\n     name=\"pi\"\n     value=\"3.14\"/>\n <parameter id=\"e\"\n     name=\"e\"\n     value=\"2.718\"/>\n <parameter id=\"E\"\n     name=\"Enzyme_Concentration\"\n     value=\"1\"\n     constant=\"false\"/>\n</listOfParameters>";


ruleToSBML::usage="ruleToSBML[options] returns a rule definition.\nruleToSBML[x, options] is the same as ruleToSBML[id->x,options].\nruleToSBML[{{options},{options},...}] returns a <listOfRules.../>, where each option list corresponds to a separate rule.\n\nOptions:\nid-> Optional identifier to ading the rule. Since SBML does not define an \"id\" field for rules, ids are placed as a metaid within the rule definition.\ntype->algebraicRule,assignmentRule,or rateRule (no default)\nvariable->name of variable (variable n) if not specified.\nmath->formula for the rule."<>"\n\nThe following PROPOSED LEVEL 3 options are allowed if Arrays->True is set by an call to newModel[]:\nArrayDimensions->{i->{min,max},j->{min,max},...} or {} (default).\nvariableLInk->{variable->{index1,index2,...}} or {} (default). If variableLink is specified then the variable field is ignored.\nruleToSBML[type->initialAssignmentRule,variableLink->{x->i},ArrayDimensions->{i->{1,3}},data->{5,10,15}] for a vector, assigns the data {5,10,15} to the vector x with an index of i that runs from 1 to 3\nruleToSBML[type->initialAssignmentRule,variableLink->{x->{i,j}},ArrayDimensions->{i->{1,3},j->{1,3}, data->{{5,10,15},{20,25,30},{35,40,50}}] for a matrix, assigns the data to a matrix with indices i and j that each run from 1 to 3."<>"\n\nExample 1: ruleToSBML[type\[Rule] assignmentRule, variable\[Rule] x, math\[Rule] x+y]\nreturns:\n<assignmentRule variable=\"x\">\n <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n  <apply>\n   <plus/>\n   <ci>x</ci>\n   <ci>y</ci>\n  </apply>\n </math>\n</assignmentRule>\n\nExample2:\nruleToSBML[{{type->\"algebraicRule\",math->x^2}, {type->\"rateRule\",variable->y,math->2*x}}]\nreturns:\n<listOfRules>\n <algebraicRule>\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <power/>\n    <ci>x</ci>\n    <cn type=\"integer\">2</cn>\n   </apply>\n  </math>\n </algebraicRule>\n <rateRule variable=\"y\">\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <times/>\n    <cn type=\"integer\">2</cn>\n    <ci>x</ci>\n   </apply>\n  </math>\n </rateRule>\n</listOfRules>";


constraintToSBML::usage="constraintToSBML[options] returns the SBML for a <constraint>...<../> object. Options are: message, math, SBOTerm, metaid, notes, annotation."


eventToSBML::usage="eventToSBML[options] returns a single <event.../> definition.\neventToSBML[{{options},{options},...}] returns a <listOfEvents.../>, where each option list corresponds to a single event.\n\nOptions:\nid\[Rule]event id, if not provided, defaults to eventn where n is an integer.\nname\[Rule]event name, if not provided, defaults to value of event.\ntrigger->expression, required,any Mathematica expression that evaluates to True or False.\ndelay->expression, optional, any expression that evaluates to a number.\ntimeUnits->units, optional units to use for time.\neventAssignment->{\!\(\*SubscriptBox[\(var\), \(1\)]\)\[Rule]\!\(\*SubscriptBox[\(expr\), \(1\)]\),\!\(\*SubscriptBox[\(var\), \(2\)]\)\[Rule]\!\(\*SubscriptBox[\(expr\), \(2\)]\),...}, what should happen when the event is triggered, each variable \!\(\*SubscriptBox[\(var\), \(i\)]\) is assigned to the value of expression \!\(\*SubscriptBox[\(expr\), \(i\)]\).\n\nExample 1: single event:\neventToSBML[id\[Rule]\"foo\", name\[Rule]\"A basic event\", timeUnits\[Rule] \"hours\",trigger\[Rule] (x>5), eventAssignment\[Rule] {x\[Rule] y+x, y\[Rule] 0}]\nreturns:\n<event id\"foo\" name=\"A basic event\" timeUnits=\"hours\">\n <trigger>\n  <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n   <apply>\n    <gt/>\n    <ci>x</ci>\n    <cn>5</cn>\n   </apply>\n  </math>\n </trigger>\n <listOfEventAssignments>\n  <eventAssignment variable=\"x\">\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <apply>\n     <plus/>\n     <ci>x</ci>\n     <ci>y</ci>\n    </apply>\n   </math>\n  </eventAssignment>\n  <eventAssignment variable=\"y\">\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <cn>0</cn>\n   </math>\n  </eventAssignment>\n </listOfEventAssignments>\n</event>\n\nExample 2: listOfEvents:\neventToSBML[{{id\[Rule]\"yon\", name\[Rule]\"y turned on\", trigger\[Rule] x>17, eventAssignment\[Rule]{y\[Rule]0, z\[Rule]100}}, {id\[Rule]\"yoff\",name\[Rule]\"y turned off\", trigger\[Rule]x>20, eventAssignment\[Rule]{y\[Rule]100, z\[Rule]0}}}]\n\nreturns:\n<listOfEvents>\n <event id=\"yon\" name=\"y turned on\">\n  <trigger>\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <apply>\n     <gt/>\n     <ci>x</ci>\n     <cn>17</cn>\n    </apply>\n   </math>\n  </trigger>\n  <listOfEventAssignments>\n   <eventAssignment variable=\"y\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>0</cn>\n    </math>\n   </eventAssignment>\n   <eventAssignment variable=\"z\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>100</cn>\n    </math>\n   </eventAssignment>\n  </listOfEventAssignments>\n </event>\n <event id=\"yoff\" name=\"y turned off\">\n  <trigger>\n   <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n    <apply>\n     <gt/>\n     <ci>x</ci>\n     <cn>20</cn>\n    </apply>\n   </math>\n  </trigger>\n  <listOfEventAssignments>\n   <eventAssignment variable=\"y\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>100</cn>\n    </math>\n   </eventAssignment>\n   <eventAssignment variable=\"z\">\n    <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n     <cn>0</cn>\n    </math>\n   </eventAssignment>\n  </listOfEventAssignments>\n </event>\n</listOfEvents>";


reactionToSymbolicSBML::usage="reactionToSymbolicSBML returns Symbolic SBML for a reaction or listOfReactions. Usage is identical to reactionToSBML.";
speciesToSymbolicSBML::usage="speciesToSymbolicSBML returns Symbolic SBML for a species or listOfSpecies. Usage is identical to speciesToSBML.";
speciesTypeToSymbolicSBML::usage="speciesTypeToSymbolicSBML returns Symbolic SBML for a speciesType or listOfSpeciesTypes. Usage is identical to speciesTypeToSBML.";
functionToSymbolicSBML::usage="functionToSymbolicSBML returns Symbolic SBML for a function or listOfFunctions. Usage is identical to functionToSBML.";
unitToSymbolicSBML::usage="unitToSymbolicSBML returns Symbolic SBML for a unit or a listOfUnits. Usage is identical to unitToSBML.";
compartmentToSymbolicSBML::usage="compartmentToSymbolicSBML returns Symbolic SBML for a compartment or listOfCompartments. Usage is identical to compartmentToSBML.";
compartmentTypeToSymbolicSBML::usage="compartmentTypeToSymbolicSBML returns Symbolic SBML for a compartmentType or listOfcompartmentTypes. ";
parameterToSymbolicSBML::usage="parameterToSymbolicSBML returns Symbolic SBML for a parameter or listOfParameters. Usage is identical to parameterToSBML.";
ruleToSymbolicSBML::usage="ruleToSymbolicSBML returns Symbolic SBML for a rule or listOfRules. Usage is identical to ruleToSBML.";
constraintToSymbolicSBML::usage="constraintToSymbolicSBML[options] returns the symbolic SBML for a <constraint>...<../> object. Options are: message, math, SBOTerm, metaid, notes, annotation."
eventToSymbolicSBML::usage="eventToSymbolicSBML returns Symbolic SBML for an event or a listOfEvents. Usage is identical to eventToSBML.";
initialAssignmentToSymbolicSBML::usage="initialAssignmentToSymbolicSBML returns Symbolic SBML for an initialAssignment. Usage is idential to initialAssignmentToSBML";



getObjectAttribute::usage="getObjectAttribute[object, attribute, number]\nobject is an sbml object such as \"species\", and attribute is one of its attributes, such as \"id\" or \"name\", e.g., getObjectAttribute[\"compartment\", \"size\", 1]. The value returned will always be a string because it is coming from xml.";
getObjectID::usage="getObjectID[sbmlobject, n] returns the ID of the nth SBML object sbmlobject, e.g., getObjectID[\"species\", 2]. The value returned will always be a string because it is coming from xml.";
getObjectIDs::usage="getObjectIds[ojbect]"; 

getObjectName::usage="getObjectName[sbmlobject, n] returns the name of the nth SBML object sbmlobject, e.g., getObjecName[\"species\", 3].  The value returned will always be a string because it is coming from xml.";
getObjectNames::usage="getObjectNames[object]"; 
 
getNumberOfObjects::usage="getNumberOfObjects[object] where object is a string such as \"compartment\""; 

getCompartmentID::usage="getCompartmentID[number]";
getEventID::usage="getEventID[number]";
getFunctionID::usage="getFunctionID[number]";
getParameterID::usage="getParameterID[number]";
getRuleID::usage="getRuleID[number]";
getSpeciesID::usage="getSpeciesID[number]";
getUnitID::usage="getUnitID[number]";
getSpeciesTypeID::usage="getSpeciesTypeID[number]";
getCompartmentTypeID ::usage="getCompartmentTypeID[number]";
getConstraintID::usage="getConstraintID[number]";
getInitialAssignmentID::usage="getInitialAssignmentID[number]";

getCompartmentName::usage="getCompartmentName[number]";
getEventName::usage="getEventName[number]";
getFunctionName::usage="getFunctionName[number]";
getParameterName::usage="getParameterName[number]";
getRuleName::usage="getRuleName[number]";
getSpeciesName::usage="getSpeciesName[number]";
getUnitName::usage="getUnitName[number]";
getSpeciesTypeName::usage="getSpeciesTypeName[number]";
getCompartmentTypeName::usage="getCompartmentTypeName[number]";
getConstraintName::usage="getConstraintName[number]";
getInitialAssignmentName::usage="getInitialAssignmentName[number]";

getCompartmentNames::usage="getCompartmentNames[]";
getEventNames::usage="getEventNames[]";
getFunctionNames::usage="getFunctionNames[]";
getParameterNames::usage="getParameterNames[]";
getRuleNames::usage="getRuleNames[]";
getSpeciesNames::usage="getSpeciesNames[]";
getUnitNames::usage="getUnitNames[]";
getSpeciesTypeNames::usage="getSpeciesTypeNames[]";
getCompartmentTypeNames::usage="getCompartmentTypeNames[]";
getConstraintNames::usage="getConstraintNames[]";
getInitialAssignmentNames::usage="getInitialAssignmentNames[]";

getCompartmentIDs::usage="getCompartmentIDs[]";
getEventIDs::usage="getEventIDs[]";
getFunctionIDs::usage="getFunctionIDs[]";
getParameterIDs::usage="getParameterIDs[]";
getRuleIDs::usage="getRuleIDs[]";
getSpeciesIDs::usage="getSpeciesIDs[]";
getUnitIDs::usage="getUnitIDs[]";
getSpeciesTypeIDs::usage="getSpeciesTypeIDs[]";
getCompartmentTypeIDs::usage="getCompartmentTypeIDs[]";
getConstraintIDs::usage="getConstraintIDs[]";
getInitialAssignmentIDs::usage="getInitialAssignmentIDs[]";


getObject::usage="getObject[type,arguments] retrieves the specified object type. See also getObjects.\ntype must be one of the following strings: \"compartment\",\"event\",\"function\",\"parameter\",\"reaction\",\"rule\"\"species\",\"unit\"\narguments may be a single integer, id, or a list of integers and/or ids. ";
getObjectNumber::usage="getObjectNumber[type,arguments] retrieves the number of the specified object type.\ntype must be one of the following strings: \"compartment\",\"event\",\"function\",\"parameter\",\"reaction\",\"rule\"\"species\",\"unit\"\nargument must be a valid sid";
getObjects::usage="getObject[type1,args1,type2,args2,...] returns a list of the specified objects as symbolic XML.  See getObject.\ngetObject[type1\[Rule]arg1,type2\[Rule]arg2,...] returns the objects as a rule list\nexamples:\ngetObject[\"event\",A,\"Species\",B]\ngetObject[\"rule\"\[Rule]{1,3},\"function\"\[Rule]1,\"species\"\[Rule]{x,y,z}]";

replaceObject::usage="";


getReaction::usage="getReaction[x] returns the selected reaction (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth reaction in the model.\ngetReaction[{x1,x2,...}] returns the list of reactions x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfReactions::usage="getNumberOfReactions returns the number of reactions in the model.";
getReactions::usage="getReactions[] returns all of the reactions in the model.";
getReactionNumber::usage="No information is available about this function at the present time.";
replaceReaction::usage="No information is available about this function at the present time.";



getRule::usage="getRule[x] returns the selected rule (in symbolic XML) from the model. The argument must be an integer n, to retrieve the nth rule in the model, or a list of integers,to retrieve a list of rules.";
getRules::usage="getRules[] returns a list of all the rules in the model.";
getNumberOfRules::usage="getNumberOfRules[] returns the number of rules in the model.";
getRuleNumber::usage="No information is available about this function at the present time.";
replaceRule::usage="No information is available about this function at the present time.";




getConstraint::usage="getConstraint[n] returns the selected Constraint (in symbolic XML) from the model. The argument must be an integer n.";
getConstraints::usage="getConstraints[] returns a list of all the <Constraint> objects in the model (in symbolic SBML).";
getNumberOfConstraints::usage="getNumberOfConstraints[] returns the number of <Constraint> objects in the model.";
getConstraintNumber::usage="No information is available about this function at the present time.";
replaceConstraint::usage="No information is available about this function at the present time.";
addConstraint::usage="No information is available about this function at the present time.";
removeConstraint::usage="No information is available about this function at the present time.";
modifyConstraint::usage="No information is available about this function at the present time.";


getInitialAssignment::usage="getInitialAssignment[n] returns the selected initialAssignment (in symbolic XML) from the model. The argument must be an integer n or an SID referring to the symbol field of the initialAssignment.";
getInitialAssignments::usage="getInitialAssignments[] returns a list of all the <initialAssignment> objects in the model (in symbolic SBML).";
getNumberOfInitialAssignments::usage="getNumberOfInitialAssignments[] returns the number of <initialAssignment> objects in the model.";
getInitialAssignmentNumber::usage="No information is available about this function at the present time.";
replaceInitialAssignment::usage="No information is available about this function at the present time.";
addInitialAssignment::usage="No information is available about this function at the present time.";
removeInitialAssignment::usage="No information is available about this function at the present time.";
modifyInitialAssignment::usage="No information is available about this function at the present time.";


getCompartment::usage="getCompartment[x] returns the selected compartment (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth compartment in the model.\ngetCompartment[{x1,x2,...}] returns the list of compartments x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfCompartments::usage="getNumberOfCompartments[] returns the number of compartments in the model";
getCompartments::usage="getCompartments[] returns a list of all the compartments in the model";
getCompartmentNumber::usage="No information is available about this function at the present time.";
replaceCompartment::usage="No information is available about this function at the present time.";


getUnit::usage="getUnit[x] returns the selected unit (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth unit in the model.\ngetUnit[{x1,x2,...}] returns the list of unit x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getUnits::usage="getUnits[] returns a list of all the units in the model.";
getNumberOfUnits::usage="getNumberOfUnits[] returns the number of units in the model.";
getUnitNumber::usage="No information is available about this function at the present time.";
replaceUnit::usage="No information is available about this function at the present time.";

getParameter::usage="getParameter[x] returns the selected parameter (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth parameter in the model.\ngetParameter[{x1,x2,...}] returns the list of parameters x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfParameters::usage="getNumberOfParameters[] returns the number of global parameters in the model";
getParameters::usage="getParameters[] returns a list of all the global parameters in the model.";
getParameterNumber::usage="";
replaceParameter::usage="";

getSpecies::usage="getSpecies[x] returns the selected species (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth species in the model.\ngetSpecies[{x1,x2,...}] returns the list of species x1, x2, ..., which can be specified in any combination of identifying SIDs or numbers.\ngetSpecies[] returns a list of all the species in the model.";
getNumberOfSpecies::usage="getNumberOfSpecies[] returns the number of species in the model.";
getSpeciesNumber::usage="No information is available about this function at the present time.";
replaceSpecies::usage="No information is available about this function at the present time.";

getFunction::usage="getFunction[x] returns the selected function (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth function in the model.\ngetFunction[{x1,x2,...}] returns the list of functions x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfFunctions::usage="getNumberOfFunctions[] returns the number of functions in the model";
getFunctions::usage="getFunctions[] returns a list of all the functions in the model.";
getFunctionNumber::usage="No information is available about this function at the present time.";
replaceFunction::usage="No information is available about this function at the present time.";

getEvent::usage="getEvent[x] returns the selected event (in symbolic XML) from the model. The argument may be either an SID or an integer n to retrieve the nth event in the model.\ngetEvent[{x1,x2,...}] returns the list of events x1, x2, ..., which can be specified in any combination of identifying SIDs or integers.";
getNumberOfEvents::usage="getNumberOfFunctions[] returns the number of events in the model";
getEvents::usage="getFunctions[] returns a list of all the events in the model.";
getEventNumber::usage="No information is available about this function at the present time.";
replaceEvent::usage="No information is available about this function at the present time.";

addSpecies::usage="addSpecies[id, options] adds a species to the current model. Options are the same as speciesToSBML. If the species previously exists, the previous information about it in the model is replaced. If the required compartment is not specified for the species it is assigned to \"Indeterminate.\" If any units are specified for the species and they have not been previously defined in the model or are not predefined units, new units are added to the model without any <unit kind...> information.\naddSpecies[{s1,s2,..}, options] adds the set of species to the model.";

removeSpecies::usage="removeSpecies[id] removes a species from the model.";

addCompartment::usage="addCompartment[id, options] adds a new compartment to the model. Options are the same as compartmentToSBML. If the compartment previously exists, the previous information about it in the model is replaced.";
removeCompartment::usage="removeCompartment[id] removes a compartment from the model. If the compartment contains any species, the compartment may not be removed.";
compartmentCreate::usage="";
compartmentCreateWith::usage="";

addEvent::usage="addEvent[id, options] adds a new event to the model. Options are the same as eventToSBML. If an event with the same id already exists in the model, it will be replaced with the new event.";
removeEvent::usage="removeEvent[id] removes the event from the model.";

addFunction::usage="addFunction[id, options] adds a new function to the model. Options are the same as functionToSBML. If a function with the same id has been previously defined, the old definition is replaced with the new definition.";
removeFunction::usage="removeFunction[id] removes a function from the model.";

addParameter::usage="addParameter[id, options] adds a new parameter to the model. Options are the same as parameterTOSBML. If the parameter has been previously defined, the old definition is replaced with the new definiton.";
removeParameter::usage="removeParameter[id] removes a parameter from the model.";

addReaction::usage="addReaction[reaction, options] adds a reaction to the current model. Options are the same as reactionToSBML. If the id is specified and a reaction with the same id already exists in the model then the previous information about that reaction is replaced. If any of the reactants, products, or modifiers in the reaction have not been previously defined in the model, they are added to compartment \"Indeterminate.\"";
removeReaction::usage="removeReaction[id] removes a reaction from the current model.";

addRule::usage="addRule[options] adds a rule to the current model. Options are the same as ruleToSBML.";
removeRule::usage="removeRule[id] removes a rule from the current model.";

addUnit::usage="addUnit[unit, options] adds a unit to the current model. If a unit by the same name has been previously defined, it is replaced.";
removeUnit::usage="removeUnit[id] removes a unit from the current model. If the unit is referenced by a species or parameter in the model it may not be removed.";

getSpeciesType::usage="gets a speciesType as symbolic SBML by number or name";
getSpeciesTypeNumber::usage="";
getNumberOfSpeciesTypes::usage="getNumberOfSpeciesTypes[] returns the number of speciesTypes that have  been defined in the current model.";
addSpeciesType::usage="addSpeciesType adds a speciesType to the model. Options are the same speciesTypeToSBML";
removeSpeciesType::usage="removeSpeciesType[id] removes a speciesType from the model.";
modifySpeciesType::usage="modifySpeciesType[id, options] modifies a species in the current model.";
replaceSpeciesType::usage="No information is available about this function at the present time.";


getCompartmentType::usage="gets a CompartmentType as symbolic SBML by number or name";
getCompartmentTypeNumber::usage="getCompartmentTypeNumber[id] returns the integer number of the compartmentType with the specified id";
getCompartmentTypes::usage="gets a list of all compartmentTypes as symbolic SBML";
getNumberOfCompartmentTypes::usage="getNumberOfCompartmentTypes[] returns the number of CompartmentTypes that have  been defined in the current model.";
addCompartmentType::usage="addCompartmentType adds a CompartmentType to the model. Options are the same CompartmentTypeToSBML";
removeCompartmentType::usage="removeCompartmentType[id] removes a CompartmentType from the model.";
modifyCompartmentType::usage="modifyCompartmentType[id, options] modifies a Compartment in the current model.";
replaceCompartmentType::usage="No information is available about this function at the present time.";

resetDefaultUnits::usage="resetDefaultUnits[] resets the set of predefined units to the default set in the spec. Some of these units may have been overridden in a model definition.";

createModel::usage="createModel[] returns the SBML text for the current model.\ncreateModel[filename] writes the SBML to a file.\nOptions:\n\"annotations\"\[Rule]True, If False, suppresses all annotations\n\"notes\"\[Rule]True, If False, suppresses all annotations\n\"comments\"\[Rule]True, If False, suppresses all comments.";
createSymbolicModel::usage="createSymbolicModel[] returns Symbolic XML for the current model.";
getModel::usage="getModel[] is the same as createSymbolicModel.";
getSBMLModel::usage="getSBMLModel[] is the same as createModel."

showModel::usage="showModel[] gives a verbose listing of the current model similar to the verbose listing provided by SBMLRead";
dumpModel::usage="dumpModel performs a debugging dumpt of the current model.";
loadSimulator::usage="loadSimulator[] loads the current model into simulator-readable form, i.e, the same form returned by SBMLREAD. Thus functions such as SBMLNDSolve can be run on it. SBMLRead automatically loads both the simulator  (unless return->False) and the model builder (unless LoadModelBuilder->False) when it reads a file. ";
loadModelBuilder::usage="loadModelBuilder[file,options] reads an SBML file into the model builder.";

modifyCompartment::usage="modifyCompartment[id,options] or modifyCompartments[options] modifies the specified compartment in the current model. The compartment must be identified by the value of its id tag. Any options that are specified in the call to modifyCompartment replace the previously existing values for the corresponding SBML tag. All other tags retain their original values.Any valid options for compartmentToSBML may be used.";
modifyModel::usage="modifyModel[options] changes properties of a model. Valid options are:id, name.";
modifyFunction::usage="modifyFunction[id, options] or modifyFunction[options] modifies the specified function in the current modmel. The function must be identified by the value of its id tag. Any options that are specified in the call to modifyFunction replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid option for functionToSBML or addFunction may be used.";
modifyUnit::usage="modifyUnit[id, options] or modifyUnit[options] modifies the specified unit definition in the current model. The unit definition must be identified by the value of its id tag. Any options that are specified in the call to modifyUnit replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid options for unitToSBML may be used.";
modifyParameter::usage="modifyParameter[id, options] or modifyParameter[options] modifies the specified parameter definition in the current model.  The parameter must be identified by the value of its id tag. Any options that are specified in the call to modifyParameter replace the previously existing values for the corresponding SBML tag. All other tags retain their original values.  Any valid option for parameterToSBML or addParameter may be used.";
modifySpecies::usage="modifySpecies[id, options] or modifySpecies[options] modifies the specified species in the current model. The species must be identified by the value of its id tag. Any options that are specified in the call to modifySpecies replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid option for speciesToSBML or addSpecies may be used.";
modifyReaction::usage="modifyReaction[id, options] or modifyReaction[options] modifies the specified reaction in the current model. The reaction must be identified by the value of its id tag. Any options that are specified in the call to modifyReaction replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid option for reactionToSBML or addReaction may be used.";
modifyRule::usage="modifyRule[id, options] or modifyRule[options] modifies the specified rule in the current model.  The reaction must be identified by the value of its metaid tag, which is specified with the id option. Any options that are specified in the call to modifyRule replace the previously existing values for the corresponding SBML tag. All other tags retain their original values.  Any valid options for ruleToSBML or addRule may be used.";
modifyEvent::usage="modifyEvent[id, options] or modifyEvent[options] modifies the specified event definition in the current model. The event must be identified by the value of its id tag. Any options that are specified in the call to modifyEvent replace the previously existing values for the corresponding SBML tag. All other tags retain their original values. Any valid options for eventToSBML or addEvent may be used.";


MathMLToInfix::usage="MathMLToInfix[string_] converts a MathML content string into an infix expression.";
InfixToMathML::usage="InfixToMathML[expression_] returns a MathML string representing the given Mathematica expression.";


sameReaction::usage="TBD";
compareReactions::usage="TBD";


setAnnotationNamespace::usage="setAnnotationNamespace[URI] sets the URI to be used in subsequent annotations. setAnnotationNamespace is identical to setAnnotationURI"; 
setAnnotationURI::usage="setAnnotationURI[URI] sets the URI to be used in subsequent annotations. setAnnotationURI is identical to setAnnotationNamespace.";
setAnnotationURL::usage="setAnnotationURL has been replaced by setAnnotationURI.";

setAnnotationPackage::usage="setAnnotationPackage[name] sets the name of the package to be used in subsequent annotations. The annotation block is formatted as\n<annotation xmlns:package=\"url\">...</annotation>";
annotationToSymbolicSBML::usage="annotationToSymbolicSBML[a\[Rule]b] returns Symbolic SBML for an annotation that is specified heirarchically; a is a string, and b is either a string, a list consisting of a single string, or a list of rules of the same form as a\[Rule]b. The annotation uses the package and URI most recently defined by setAnnotationPackage and setAnnotationURI. Curly brackets {} around a single string on the right hand side of any arrow indicate that the string should be represented heirarchically as \n\n\t<foo:tag>\n\t <foo:f>v</foo:f>\n\t ...\n\t</foo:tag>\n\nrather than inline as\n\n\t <foo:tag \"foo:f\"=\"g\" .../> \n\nin the ultimate XML.\n\n"<>"annotationToSymbolicSBML[a\[Rule]b,package,URI] returns the Symbolic SBML using the specified package and URI.\n\n"<>"annotationToSymbolicSBML[XMLElement[\"annotation\",...]] returns the argument passed to it.\n\n"<>"annotationToSymbolicSBML[XMLElement[...]] encapsulates the XML in an annotation block.\n\nSee annotationToSBML for examples.";
annotationToSBML::usage="annotationToSBML returns text SBML. The arguments are the same as annotationToSymbolicSBML.\n\n"<>"annotationToSBML[\"a\"\[Rule] \"b\",\"foo\",\"http://woo.com\"] returns\n\n"<>"<annotation>\n <foo:a xmlns:foo=\"http://woo.com\">b</foo:a>\n</annotation>\n\n"<>"annotationToSBML[\"a\"\[Rule] {\"b\"\[Rule] \"c\",\"d\"\[Rule] {\"e\"},\"f\"\[Rule] {\"g\"\[Rule]{ \"h\"},\"p\"\[Rule] {\"q\"}, \"f1\"\[Rule] \"f2\"}},\"foo\",\"http://woo.com\"] returns \n\n"<>"<annotation>\n <foo:a xmlns:foo=\"http://woo.com\"\n     foo:b=\"c\">\n  <foo:d>e</foo:d>\n  <foo:f foo:f1=\"f2\">\n   <foo:g>h</foo:g>\n   <foo:p>q</foo:p>\n  </foo:f>\n </foo:a>\n</annotation>";
setSBMLAnnotation::usage="setSBMLAnnotation[annotation,package,URI] defines the annotations for the current SBML file; these annotations are outside of the model. The annotations may be listed heirarchically as rules. For example:\n\n"<>"\tsetSBMLAnnotation[\"A\"\[Rule] {\"b\"\[Rule] {\"c\"},\"d\"\[Rule] \"f\"}, \"foo\", \"http:/foo.com/ns\"]\n\n"<>"returns the symbolic XML (and saves the information for later use by createModel[]) for the following SBML fragment:\n\n"<>"<annotation>\n <foo:A xmlns:foo=\"http:/foo.com/ns\" foo:d=\"f\">\n  <foo:b>c</foo:b>\n </foo:A>\n</annotation>" ;
setModelAnnotation::usage="setModelAnnotation[annotation,package,URI] defines the annotations for the current SBML file; these annotations are outside of the model. The annotations may be listed heirarchically as rules. For example:\n\n"<>"\tsetModelAnnotation[\"A\"\[Rule] {\"b\"\[Rule] {\"c\"},\"d\"\[Rule] \"f\"}, \"foo\", \"http:/foo.com/ns\"]\n\n"<>"returns the symbolic XML (and saves the information for later use by createModel[]) for the following SBML fragment:\n\n"<>"<annotation>\n <foo:A xmlns:foo=\"http:/foo.com/ns\" foo:d=\"f\">\n  <foo:b>c</foo:b>\n </foo:A>\n</annotation>" ;


dimensionToSymbolicSBML::usage="";
dimensionToSBML::usage="";
indexToSBML::usage="";
indicesToSBML::usage="";
indexToSymbolicSBML::usage="";
indicesToSymbolicSBML::usage="";
vectorToSBML::usage="";
vectorToSymbolicSBML::usage="";
matrixToSBML::usage="";
matrixToSymbolicSBML::usage="";



XMLOut::usage="XMLOut[symbolicXML] returns a an XML string corresponding to symbolic SBML."


init::usage="init resets certain global parameters used by MathSBML.";
(* mathSBMLHelpReference::usage="mathSBMLHelpReference[options] returns a reference manual - list of all basic usage strings in MathSMBL.";*)
help::usage = "help[context] prints the help strings for the specified contexts.\nhelp[] returns a list of the available contexts."; 
Help::usage="Help[context], Help[]"; 
$HelpContexts::usage=""; 
AddHelp::usage="AddHelp[\"context`\"]. To set up the Help[context] system for context foo`,\n(1) Somewhere in the context foo`, call AddHelp[\"foo`\"]. This will tell the Help system that the help function you define in step (2) exists.\n(2) Somewhere in context foo define the function foo`Private`foohelp[]. This function will be called by Help[context]."


Clear[ bulletize,
numerize,
numerizedList,sbmlReadLimitations,sbmlReadOptions]; 


(* addCelleratorReaction::usage="addCelleratorReaction[reaction, options] is a wrapper for addReaction. All rate constants must be specified. Options may contain values for rate constants. \nAll mass action reaction are broken down into their constituitive parts. Names for intermediate compounds are generated automatically. The reaction "<>"Overscript[a\[RightArrowLeftArrow]b, c], "<>"for example, is stored as three separate reactions: "<>"a+c\[ShortRightArrow]a\[UnderBracket]c, a\[UnderBracket]c\[ShortRightArrow]a+c, a\[UnderBracket]c\[ShortRightArrow]b+c; the compound name a\[UnderBracket]c is automatically generated from the constituent species, and the underbracket character may be replaced by any other character with the option MolecularDelimiter. Note that the underbracket character (\[UnderBracket]) is replaced with the underscore (_) before being written to SBML. Only valid SID characters are allowed. \n"<>"\nThe following forms for reaction have been implemented:\n"<>"\t{a\[ShortRightArrow]b,k}\n"<>"\t{Subscript[\[CapitalSigma], i]Subscript[p, i]Subscript[A, i]\[ShortRightArrow]Subscript[\[CapitalSigma], j]Subscript[q, j]Subscript[B, j],k} (p,q stoichiometries)\n"<>"\t{Overscript[a\[ShortRightArrow]b, c], k}\n"<>"\t{a\[RightArrowLeftArrow]b, Subscript[k, f], Subscript[k, r]}\n"<>"\t{Overscript[a\[RightArrowLeftArrow]b, enzyme], a, d, k}\n"<>"\t{Overscript[a\[RightArrowLeftArrow]b, enzyme], a, d, Subscript[k, f],Subscript[k, r]}\n"<>"\t{Underoverscript[a\[RightArrowLeftArrow]b, reverse, forward], Subscript[a, f], Subscript[d, f], Subscript[k, f], Subscript[a, r], Subscript[d, r], Subscript[k, r]}\n"<>"The following cascades have been implemented:\n"<>"\t{a\[ShortRightArrow]b\[ShortRightArrow]c\[ShortRightArrow]...,Subscript[k, 1],Subscript[k, 2],...}\n"<>"\t{Overscript[a\[RightArrowLeftArrow]b\[RightArrowLeftArrow]c\[RightArrowLeftArrow], enzyme],Subscript[a, 1],Subscript[d, 1],Subscript[k, 1],...}\n"<>"See Cellerator documentation for an explanation of these reactions.\n\nExample:\n"<>"addCelleratorReaction[{Overscript[substrate\[RightArrowLeftArrow]product, enzyme], a, d, k}, a->0.001, d->.1, k->1]"; *)


InterpolationSet::usage="InterpolationSet is an uninstantiated function that encapsulates a set of InterpolatingFunction's, as in:\n\n
InterpolationSet[tstart, tend, {x[t]\[Rule] InterpolatingFunction[..][t], y[t]\[Rule]InterpolatingFunction[..][t],..}].\n\n SBMLNDSolve returns a list of InterpolationSet's when events occur in the model.\nThe list of InterpolatingFunction's may be recovered from teh InterpolationSet using getInterpolationFunction";
getInterpolatingFunction::usage="getInterpolatingFunction[InterpolationSet[tstart,tend,f]], returns f, where f is the list of InterpolationFunctions encapsulated in the InterpolationSet.";


IgnoreCollisions::usage="IgnoreCollisions[\"context`\"] means that potential variable collisions between model variables and previously defined Mathematica variables in the specified context are to be ignored (not reported as errors) by SBMLRead.\n\nIgnoreCollisions[] means that all potential variable collisions are reported.\n\nIgnoreCollisions[\"Global`\"] is the default setting.\n\nOnly potential collisions with Mathematica Variables can be inhibited in this manner; IgnoreCollisions has no affect upon checking for collisions between model variables, which cannot be inhibited.\n\nCollisions with a Mathematica Variable do not necessarily indicate an SBML model error. However, they may cause MathSBML to produce unexpected and incorrect results. \n\nMost model collisions occur as a result of using SBMLRead[... context\[Rule]None ...]. If the option context\[Rule]None is not used then collisions will be unlikely.";


resetIC::usage="resetIC[m,var,value]\nresetIC[m,var\[Rule]value]\nresetIC[m,{var1\[Rule]val1,...}]\n\nThis function will typically be used when a modeler wants to perform multiple simulations with different initial conditions, and does not want to create a different SBML file for each set of initial conditions.\n\nThe function resetIC will return a modified version of model m (where m is the original output of SBMLRead or an equivalent function) with the specified initial conditions reset.It is not necessary to specify the model id, name, or context, as that is auto-determined and any context specified will be ignored. Compare with resetParameter.\n\nIntroduced in version 2.5.15-\[Alpha]";

resetParameter::usage="resetParameter[m,var,value]\nresetParameter[m,var\[Rule]value]\nresetParameter[m,{var1\[Rule]val1,...}]\n\nThe function resetParameter will return a modified version of the model m (where m is the original output of SBMLRead or an equivalent function) with the specified parameter (in SBMLConstants) reset to the specified value. Note that resetParameter will not have any effect unless the original model was input with evaluateParameters\[Rule]False, because otherwise all parameter values will have already been replaced with their corresponding values in the differential equations. Compare with resetIC.\nIntroduced in version 2.5.15-\[Alpha]";


setMIRIAMcreatorFamily::usage="";
setMIRIAMcreatorGiven::usage="";
setMIRIAMcreatorEMAIL::usage="";
setMIRIAMcreatorOrgname::usage="";
setMIRIAMcreatedTime::usage="";
setMIRIAMmodifiedTime::usage="";
setMIRIAMcreator::usage="";
resetMIRIAMcreator::usage="";

vCardToSymbolicXML::usage="";
createBag::usage="";
getBagSize::usage="";

MIRIAMCreateTimeToSymbolicXML::usage="";
MIRIAMmodifiedTimeToSymbolicXML::usage="";
MIRIAMcreatorToSymbolicXML::usage="";



getBiomodel::usage="getBiomodel[n: integer, opt: options (any SBMLRead options) ]"


visualizeSBMLModel::usage="visualizeSBMLModel[filename, options] uses GraphPlot to generate a visualization of the model species, including reactions and rules. Species are indicated by ovals and reactions by rectangles. Species-Species connections are rules. (Events are not included). Options are any Plot options, By default the annotations are the species and reaction ids, and the image is labeled by the model id. If  visualizeByName->True, the name field is used instead."


visualizationArrowLength::usage="An option for visualizeSBMLModel. Length of arrow in pixels";
visualizationBoxWidth::usage="An option for visualizeSBMLModel. Width of reaction box in relative coordinates."
visualizationBoxHeight::usage="An option for visualizeSBMLModel. Height of reaction box in relative coordinates.";
visualizationRadius::usage="An option for visualizeSBMLModel. Radius of species oval in relative coordinates.";
visualizationFontSize::usage="An option for visualizeSBMLModel. Font size for visualization content.";
visualizationHeaderFontSize::usage="An option for visualizeSBMLModel. Font size for visualization header.";
visualizationFontFamily::usage="An option for visualizeSBMLModel. Font family used for visualization.";
visualizeByName::usage="True/False, default is False, use ids.";
ignoreSpecies::usage="An option for visualizedSBMLModel. A list of species id's to ignore, e.g., emptySet"; 




variableToParameter::usage="variableToParameter[model, variable]\nvariableToParameter[filename, variable, options]\nreturns an SBML Model (same format as the output of SBMLRead) where the specified variable has been changed to a constant parameter. In the first form, model is the output of SBMLRead. In the second format, options are any valid options for SBMLRead.";

parametricScan::usage="parametricScan[model, parameter, min, max, delta, X, time]\nparametricScan[filename, parameter, min, max, delta, X, time]\nreturns a list containing the values {{min,X[time]}, {min+delta, X[time]}, .., {max, X[time]}}, where the values are obtained by solving the model with the value of the specified parameter set to the values min, min+delta,..., max. Here is any model variable, and time is the duration of the SBMLNDSolve run.\nNote: in the first type of invocation, the model was be orignally imported using the option evaluateParameters\[Rule]False (the default is True).";


icScan::usage="icScan[model, var, min, max, delta, X, time]\nicScan[filename, var, min, max, delta, X, time]\nreturns a list containing the values {{min,X[time]}, {min+delta, X[time]}, .., {max, X[time]}}, where the values are obtained by solving the model with the value of the specified initial conditin var[0] set to the values min, min+delta,..., max. Here is any model variable, and time is the duration of the SBMLNDSolve run.";


\[Cent]Header$Alignment = "Center";
\[Cent]Header$Alignment::usage = 
  "\[Cent]Header$Alignment is a global parameter that sets the alignment value used \
to print headers. See TextAlignment.";
$Column\[Cent]Header$Color = RGBColor[0.415693`, 0.352901`, 0.803903`];
\[Cent]Header$Color = RGBColor[0.`, 0.`, 0.501999`];

\[Cent]Header$Title$Color = \!\(\*
TagBox[
StyleBox[
RowBox[{"RGBColor", "[", 
RowBox[{"0.239998`", ",", "0.569994`", ",", "0.250008`"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\);

\[Cent]Header$Color::usage = 
  "\[Cent]Header$Color is a global parameter that sets the color of headers used to \
print headers. See FontColor.";

\[Cent]Header$Size = 16;
\[Cent]Header$Size::usage = 
  "\[Cent]Header$Size is a global parameter that sets the font size used to print \
headers.See FontSize";

\[Cent]Header$Weight = "Bold";
\[Cent]Header$Weight::usage = 
  "\[Cent]Header$Weight is a global parameter that sets the font weight used to \
print headers. See FontWeight";

\[Cent]Header$Font = "Times";
\[Cent]Header$Font::usage = 
  "\[Cent]Header$Font is a global parameter that sents the font used to print \
headers. See FontFamily.";

$Column\[Cent]HeaderSize = 14;


Begin["`Private`"];


$$LoadBug=False;
LTPrint[x___]:= If[$$LoadBug, Print[x]]; 


csymbolTimeURL="http://www.sbml.org/sbml/symbols/time";
csymbolDelayURL="http://www.sbml.org/sbml/symbols/delay";


Get["MathSBML-Utilities.m"];
Get["MathSBML-Public.m"]; 



If[$$LoadBug, Print["Loading:private functions"]];



Contexts2IgnoreCollisions={};
IgnoreCollisions[context_]:= AppendTo[Contexts2IgnoreCollisions,context];
IgnoreCollisions[]:= (Contexts2IgnoreCollisions={}); 
IgnoreCollisions["Global`"];

previouslyDefinedNamesInTheMathematicaEnvirnoment=Names["*"];
previouslyDefinedContextsInTheMathematicaEnvironment=Contexts[];

checkForSybmolCabollision[var_?StringQ]:= checkForSymbolCollision[var,"symbol"];
checkForSymbolCollision[var_?StringQ,type_?StringQ]:=Module[{u,contexts},
contexts=Complement[previouslyDefinedContextsInTheMathematicaEnvironment,Contexts2IgnoreCollisions];

If[MemberQ[previouslyDefinedNamesInTheMathematicaEnvirnoment,var], 
If[MemberQ[contexts,Context[var]],
Print["Warning: "//boldRed, "The "//boldBlack,type<>" "//boldBlack,var//boldBlue," may collide with the previously defined symbol "//boldBlack,Context[var]<>var//boldRed, " and cause unexpected results."//boldBlack];

u=ToExpression[var<>"::usage"];
If[StringQ[u],
If[StringLength[u]>80, u=StringTake[u,75]<>"... (use ?"<>var<>" for more information)."];
 Print[MyStyle[u,FontColor-> Purple]]];
]; 
];
]; 


If[$$LoadBug, Print["Loading:private: File-checking functions"]];


fileExists[fname_, opt___?OptionQ]:= Module[{f},
f = If[StringQ[fname], fname, ToString[fname]];
Return[Length[FileNames[f, opt]]>0];
];


validInputFile[in_?StringQ]:= Module[{ok},
ok = fileExists[in];

If[!ok,
Print[boldOrange["Error: "],
boldRed["The requested input file: \""],
boldBlack[ in ], 
boldRed["\" does not exist. No file read."]
];
]; 
Return[ok];
];
validInputFile[x___]:= Print[boldOrange["Error:"],boldRed[" the argument to validInputFile must be a string."]];



availableOutputFile[out_?StringQ]:= Module[{ok,fn},
ok=!fileExists[out, IgnoreCase-> True];
If[!ok,
fn = FileNames[out, IgnoreCase-> True];
If[MemberQ[fn,out], 
Print[boldRed["Error: "],
boldBlack["The requested output file: "],
boldBlue[ out ], 
boldBlack[" already exists. No file written."]
];
,
Print[boldRed["Error: "],
boldBlack["The requested output file: "],
boldBlue[ out ], 
boldBlack[" is similar in name to the existing file: "],
boldBlue[First[fn]],
boldBlack[". No file written."]
];
]; 
]; 
Return[ok];
]; 
availableOutputFile[x___]:=Print[boldRed["Error:"],boldBlack[" the argument to availableOutputFile must be a string."]];


validateOutputFileName[out_?StringQ]:= Module[{ok,fn,vout,itry,maxtry=100000, dot,front,rear,debug=False},
vout = out;
ok=!fileExists[vout, IgnoreCase-> True];
If[debug, Print["validateOutputFileName: ok:",ok]]; 
If[ok, Return[out]];
itry=1;
dot=StringPosition[out,"."];
If[debug, Print["validateOutputFileName: dot:",dot]]; 
If[Length[dot]>0,
dot=First[Last[dot]];
front = StringTake[out,dot-1];
rear = StringDrop[out,dot];
,
front=out;
rear="";
];
If[debug, Print["validateOutputFileName: {front,rear}:",{front,rear}]]; 

While[!ok \[And] itry<maxtry,
vout = front<>ToString[itry]<>"."<>rear;
ok=!fileExists[vout, IgnoreCase-> True];
itry++;
];
If[debug, Print["validateOutputFileName: vout:",vout]]; 

If[ok,

Print[boldRed["Warning: "],
boldBlack["The requested output file: "],
boldBlue[ out ], 
boldBlack[" already exists. The following file name was used instead: "], boldBlue[vout]
];
Return[vout];
];
Print[boldOrange["Error: "],
boldBlack["Unable to create the file: "],
boldBlue[ out ]];
Return["$Failed"];
]; 


(* If[$$LoadBug, Print["Loading:checkForFullInstallation"]]; *)


(* $SBMLValidatorInstalled=False;
$SBMLValidate=Indeterminate;
checkForFullInstallation:= Block[{base=$UserBaseDirectory,f, checkfor, ok},

checkfor[q_]:= Module[{ok}, 
ok=fileExists[q];
If[!ok, Print["Warning: ",q," not installed."]];
Return[ok];
];
f=ToFileName[base,"Applications"];
checkfor[f];

(* check for SBMLValidator Installation *)

f=ToFileName[f,"SBMLValidator"];
If[!fileExists[f], 
checkfor[f];
,
ok=checkfor[ToFileName[f,"SBMLValidator.class"]] \[And]
checkfor[ToFileName[f,"MultipartPost.class"]];
If[ok,
InstallJava[];
AddToClassPath[f];
$SBMLValidatorInstalled=True;
$SBMLValidate=JavaNew["SBMLValidator"]
];
];
];

checkForFullInstallation; *) 



(* If[$$LoadBug, Print["Loading:SBMLValidate"]]; *)


(* SBMLValidate[file_]:=SBMLValidate[file,"text"];
SBMLValidate[file_,format_?StringQ]:=Module[{ok},

If[$SBMLValidatorInstalled,
ok=fileExists[file];

If[!ok, 
Print["Error: unable to find ",file];
Return[Indeterminate];
];


Switch[format,
"text",
ok=$SBMLValidate@validateSBML[file,format];,

"xml",  
ok=$SBMLValidate@validateSBML[file,format];
ok=ImportString[ok,"xml"];
,
_, Print["Warning: SBMLValidate: requested format ",format," not recognized - valid formats are \"xml\",\"text\""];
ok=Indeterminate;
];

Return[ok];
];
Print["Error: one or more validator components are not installed. An error message indicating the missing component should be displayed when you load MathSBML."];
checkForFullInstallation;
] *)


checkOptions[module_, {requestedoption__}, allowedoptions_]:= Module[{req},
req = {requestedoption}//Flatten;
Apply[
And,
checkOptions[module,#,allowedoptions]&/@req
]];
checkOptions[module_,requestedoption_, allowedoptions_]:= Module[{allowedopts,requestedopt},

allowedopts = Flatten[{allowedoptions}]; 
allowedopts = Map[If[OptionQ[#], First[#], #]&, allowedopts];
allowedopts = stringer/@allowedopts;

requestedopt=requestedoption;
If[requestedopt=={}, Return[True]];
If[OptionQ[requestedopt], requestedopt=First[requestedopt]]; 
requestedopt=stringer[requestedopt];

If[MemberQ[allowedopts, requestedopt], Return[True]];
Print["Warning: "//boldRed,requestedopt//boldBlue," is not an option for "//boldBlack,module// boldBlue," -- "," allowed options are: "//boldBlack, list2CommaSeparatedString[allowedopts]//boldBlue ];
Return[False];
];



If[$$LoadBug, Print["Loading:XMLOut"]];


XMLOut[symbolicXML_]:= sunderscore[ExportXMLString[symbolicXML]];


makeString[x_?StringQ]:= x;
makeString[x_]:= ToString[InputForm[x]];


boldRed[x_]:= MyStyle[x, FontColor-> RGBColor[1,0,0], FontWeight->"Bold"];
 
boldOrange[x_]:= MyStyle[x, FontColor-> RGBColor[1,0.5, 0],FontWeight-> "Bold"];boldBlue[x_]:= MyStyle[x, FontColor-> RGBColor[0, 0, 1], FontWeight->"Bold"]; 
boldBlack[x_]:= MyStyle[x, FontColor-> GrayLevel[0], FontWeight-> "Bold"];
boldGray[x_]:= MyStyle[x, FontColor-> GrayLevel[0.5], FontWeight-> "Bold"]; 
boldGreen[x_]:= MyStyle[x, FontColor-> RGBColor[.2,0.9,.6], FontWeight-> "Bold"]; 
hiBlackOnYellow[x_]:= MyStyle[x, Background-> \!\(\*
TagBox[
StyleBox[
RowBox[{"RGBColor", "[", 
RowBox[{"1", ",", "1", ",", "0"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),FontColor-> GrayLevel[0], FontWeight-> "Bold"];
hiRedOnYellow[x_]:= MyStyle[x, Background-> \!\(\*
TagBox[
StyleBox[
RowBox[{"RGBColor", "[", 
RowBox[{"1", ",", "1", ",", "0"}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),FontColor->RGBColor[1,0,0], FontWeight-> "Bold"];


stringulate[s_?StringQ]:= s;
stringulate[s_?ListQ]:= stringulate/@s;
stringulate[s_]:= ToString[InputForm[s]];


cpuPush[]:= Module[{},
$SBML$CPU= Prepend[$SBML$CPU, TimeUsed[]]; 
];
cpuPop[]:= Module[{f},
f=First[$SBML$CPU]; 
$SBML$CPU=Rest[$SBML$CPU];
Return[f]; 
];
cpuGet[]:=Module[{}, If[$SBML$ReportCPU, Return[TimeUsed[]-cpuPop[]], Return[0.0]]];

cpuSet[]:= If[$SBML$ReportCPU, cpuPush[]]; 
cpuReport[msg_]:= Module[{c},
If[$SBML$ReportCPU,
c= cpuPop[];
Print[">>>CPU = ",TimeUsed[]-c," ", msg]; 
];
]; 


cpuObserver[msg_]:= Module[{},
If[$CPU$Trace,
$CPULast=$CPU;
$CPU=TimeUsed[];
Print[$CPU-$CPULast," Seconds for ",msg];
];
];


saveCPU[]:= Module[{},
$CPU$Last$Saved=$CPULast;
$CPU$Saved = $CPU;
];
retrieveCPU[]:= Module[{},
$CPULast=$CPU$Last$Saved;
$CPU=$CPU$Saved;
];


If[$$LoadBug, Print["Loading:resetSBMLGlobals"]];


resetSBMLGlobals[]:= Module[{},
$SBML$modelcount=0; 
$SBML$SessionWarnings = 0; 
$SBML$SessionStartTime=TimeUsed[];
$SBML$CompartmentNames={};
$SBML$CompartmentVolumes={};
$SBML$CompartmentUnits={};
$SBML$CompartmentOutsides={};
$SBML$FrozenVariables = {};
$SBML$Algebraic$Rules={};
$SBML$Constraints={};
$SBML$InitialAssignments={};
$Compartment$ID = "";
$Species$ID = "$";
$SBML$warnings=True;
];


If[$$LoadBug, Print["Loading:preprocessSBML"]];


preprocessSBML[sbml_]:= Module[{m, myrule, myXMLElement},
(* remove underscores in rules of the form string1-> string2 *)
myrule[x_?StringQ, y_?StringQ]:= Module[{x1,y1},
x1 = StringReplace[x, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}];
y1 = StringReplace[y, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}];
Return[x1-> y1];
];
myrule[x_,y_]:= Rule[x,y];

myXMLElement[x_, y_,z_]:= Module[{x1, z1},
x1 = StringReplace[x, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}];

z1 = 
Map[If[StringQ[#], StringReplace[#, {"_"-> MathSBML`Private`$SBML$Underscorecharacter}],#]&,z];
Return[XMLElement[x1, y, z1]];
];
myXMLElement[x___]:= XMLElement[x]; 


m = sbml/.{Rule-> myrule};
m = m/.{XMLElement-> myXMLElement};

(*7-27-2004: 2.3.31: *) 

m = fixXMLeNotation[m]; 

m=itemcheck[m,"math"];
Return[m];
];

itemcheck[m_, item_]:= Module[{sbml, XMLStuff,XMLObj, mathrule, myrule, mprime,debug},
debug=False;

If[debug, Print["dbg:itemcheck: ",item]]; 

XMLStuff["sbml", a_, b_]:= {a};
XMLStuff[a___]:= {};
XMLObj["Document"][{declaration_},stuff_, morestuff_]:= {stuff};
myrule[{xmlns_,item},mathns_]:= {mathns};
myrule[{xmlns_, anythingelse_}, otherns_]:= {};
myrule[other_,stuff_]:= {}; 

sbml=m/.{XMLElement-> XMLStuff, XMLObject-> XMLObj};
sbml=Flatten[sbml];

mathrule=sbml/.{Rule->myrule};
mathrule= Flatten[mathrule];


Clear[XMLStuff];
mprime=m;
If[Length[mathrule]>0,
Block[{nextmath,restmath},
restmath=mathrule;
While[Length[restmath]>0,
nextmath=First[mathrule];
restmath=Rest[restmath];
If[debug, Print["dbg:itemcheck: checking ",nextmath]];

(* For each {xmlns, "math"}->mathmlns, replace all XMLElement[{xmlns,operator}...] with the XMLElement[operator,...] itself
*)

XMLStuff[{nextmath, y_},x___]:= XMLElement[y, x];
XMLStuff[z___]:= XMLElement[z];

mprime = mprime/.{XMLElement-> XMLStuff};

];
];
]; 
Return[mprime];

];


If[$$LoadBug, Print["Loading:fixXMLeNotation"]];


fixXMLeNotation[xml_]:= Module[{myxml,f},

f["cn",{"type"->"e-notation"},{mantissa_,XMLElement["sep",{},{}],exponent_}]:=Module[{man, exp,fxml},
man = Xpression2SymbolicMathML[ToExpression[mantissa]][[3,1]];

exp = Xpression2SymbolicMathML[ToExpression[exponent]][[3,1]];

fxml = XMLElement["apply",{},{XMLElement["times",{},{}],XMLElement["apply",{},{XMLElement["power",{},{}],XMLElement["cn",{"type"->"integer"},{"10"}],exp}],man}];
Return[fxml];
];
f[x___]:= XMLElement[x];

myxml = xml/.{XMLElement-> f};
Return[myxml];
]


If[$$LoadBug, Print["Loading:postprocessSBML"]];


postprocess[sbml_]:= Module[{m, myrule, myXMLElement},
(* remove underscores in rules of the form string1-> string2 *)
myrule[x_?StringQ, y_?StringQ]:= Module[{x1,y1},
x1 = StringReplace[x, {MathSBML`Private`$SBML$Underscorecharacter-> "_"}];
y1 = StringReplace[y, { MathSBML`Private`$SBML$Underscorecharacter-> "_"}];
Return[x1-> y1];
];
myrule[x_,y_]:= Rule[x,y];

myXMLElement[x_, y_,z_]:= Module[{x1, z1},
x1 = StringReplace[x, {MathSBML`Private`$SBML$Underscorecharacter-> "_"}];

z1 = 
Map[If[StringQ[#], StringReplace[#, { MathSBML`Private`$SBML$Underscorecharacter-> "_"}],#]&,z];
Return[XMLElement[x1, y, z1]];
];
myXMLElement[x___]:= XMLElement[x]; 


m = sbml/.{Rule-> myrule};
m = m/.{XMLElement-> myXMLElement};

Return[m];
];


If[$$LoadBug, Print["Loading:getSBML"]];


Options[getSBML]={verbose-> True};
getSBML[file_,opt___?OptionQ]:= Module[{s1,s,sbml,filename, sbmloptions,level,version,cpu,hf,dbg=False},
If[dbg, Print["getSBML: file:"//boldRed,file//boldBlue]];
hf = stringer[Head[file]];
hf = StringReplace[hf,"\""-> ""]; 
Switch[hf (* stringer[Head[file]]*)      ,
"String",
If[!fileExists[ file],
Print["Error: "//boldRed,"The file "//boldBlack,file//boldBlue," does not exist."//boldBlack];
Abort[];
];
s1 = Import[file,"XML"]; filename=file;,
"XMLObject[Document]",s1=file;filename="Internal Model";,
_, Print["Error: "//boldOrange," SBMLRead: first argument must be either a file name or Symbolic Obj SBML."//boldBlack];
Abort[];
];
s = preprocessSBML[s1]; 
cpuObserver["Import"];
dbg=Global`debug/.{opt}/.{Global`debug-> False};

sbml = Cases[s,XMLElement["sbml",___],3]; 
If[dbg, Print["getSBML:sbml:",sbml]];
cpuObserver["sbml/Cases"];

abortIfNoTag[sbml, "sbml"];

cpuObserver["abortIfNoTag"];

sbml = {First[sbml]}; (* ignore multiple sbml *) 
sbmloptions = extractXMLOptions[First[sbml]];
{level,version} = determineSBMLVersion[sbmloptions];

If[dbg, Print["getSBML: Level,Version=",level,",",version]];


(* need to figure out model id & name here as well *)
(* move this to getSBMLlevel2 *)
(*
If[level>1,
If[MB$Load, 

newModel[Global`level-> level,Global`version-> version, Global`echo-> MB$Echo];
MB$SBMLAnnotation=getAnnotations[sbml]//Flatten; 
MB$SBMLNotes=getNotes[sbml]//Flatten;

];
,
MB$Load=False;
]; 
If[dbg, Print["getSBML:MB$Load:",MB$Load,", MB$SBMLNotes:",MB$SBMLNotes ]];
*)





cpuObserver["determineVersion"];

Switch[level,
1,
Switch[version,

1,Return[getSBMLlevel1[sbml,filename, opt]],

2,Return[getSBMLlevel1[sbml,filename, opt]],

(* other versions of level 1 *) 
_, 
Print["SBML Level ", level , " version ",version," is not currently supported."];Abort[];
];
(* end of level 1 *)
,
2,
If[dbg, Print["getSBML:Calling getSBMLLevel2:" ]];
Switch[version,

1,Return[getSBMLlevel2[sbml,filename, opt]],

2,Return[getSBMLlevel2[sbml,filename, opt]],

3, Return[getSBMLlevel2[sbml,filename, opt]],

4, 
Print["Error: MathSBML: "//boldRed, "SBML Level "//boldBlack, level//boldBlue , " version "//boldBlack,version//boldBlue," is not fully implemented in MathSBML."//boldBlack]; 
Return[getSBMLlevel2[sbml,filename, opt]],

(* other versions of level 2 *) 
_, 
Print["Error: MathSBML: "//boldRed, "SBML Level "//boldBlack, level//boldBlue , " version "//boldBlack,version//boldBlue," is not currently implemented in MathSBML."//boldBlack];Abort[];
];
(* end of level 2 *)

,
(* other levels *) 

_, Print["Error: MathSBML:"//boldRed, "SBML Level "//boldBlue,level//boldBlue," is not currently supported."//boldBlack]; Abort[];

];

Print["Error: MathSBML: "//boldRed, "SBML version "//boldBlack, version//boldBlue, " is not currently implemented in MathSBML."//boldBlack];
]


getSBMLNotes[sbml_]:=Module[{},
$SBML$Notes =Cases[sbml,XMLElement["notes",___],5];
If[Length[$SBML$Notes]>0, 
$SBML$Notes= $SBML$Notes//First//extractXMLSubElements];
If[Length[$SBML$Notes]>0, $SBML$Notes=First[$SBML$Notes]];
];



getSBMLlevel1[sbml_,filename_, opt___?OptionQ]:= Module[{ models, modeloptions,modelnames,modelName,   statistics, importedModel,modelCounterString, numericalSolution
},
dbg = $SBML$debug;


$SBML$UnitAssociations={};
$SBML$ODES={};
$SBML$SpeciesCompartmentAssociations={};

debugPrint[dbg,"SBML level.version = ", $SBML$Level$Version ];
If[$SBML$printModelName,
modelCounterString=" ********** Model "<>ToString[$SBML$modelcount]<>" ********** \n",
modelCounterString="";
];
If[saveVerboseData,
 verboseSave[modelCounterString<>"File Name:"<> filename<>"\nSBML Level "<>ToString[$SBML$Level]<>" Version "<>ToString[$SBML$Version],
{},{}];
]; 
getSBMLNotes[sbml]; 
 
(***** Models *****)
cpuSet[]; 

models = Cases[sbml,XMLElement["model",___],3]; 
cpuReport["models"];


abortIfNoTag[models, "model"];
modeloptions = Map[extractXMLOptions,models];
modelnames=Map["name"/.#/.{"name"-> "Unnamed\[UnderBracket]Model"}&, modeloptions];
printWarning[Length[modelnames]>1,
"Only one model is permitted; additional models ignored."];


modelname = First[modelnames] // removeUnderscore;

If[saveVerboseData, 
verboseSave["Model: "<>modelname, {}, {}];
]; 

debugPrint[dbg,"getSBML:: modelname:",modelname];

setModelContext[modelname];

models={First[models]};
$SBML$Models = models; 

(***** Units *****)
cpuSet[];
getSBMLunits[opt];
cpuReport["units"];

(***** Compartments *****)
cpuSet[];
getSBMLcompartments[opt];
cpuReport["compartments"];

(***** Species *****)
cpuSet[];
getSBMLspecies[opt]; 
cpuReport["species"];

(***** Parameters *****)
cpuSet[];
getSBMLparameters[opt];
cpuReport["parameters"];

(***** Rules *****)
cpuSet[];
getSBMLrules[opt];
cpuReport["rules"];


(***** Reactions *****)
cpuSet[];
getSBMLreactions[opt];
cpuReport["reactions"];

If[$SBML$verbose, verbosePrint[]]; 

(* reportUnassignedParameters[];
reportMisingIC[]; *) 
printStatistics[];
 

$SBML$UnitAssociations = Select[$SBML$UnitAssociations, ToString[Last[#]]!= ToString[$SBML$IndeterminateValue]&];


importedModel = {};



If[SBMLRead$return,

If[SBMLRead$returnODES, importedModel=Append[importedModel,Global`SBMLODES-> $SBML$ODES]];

If[SBMLRead$returnContext, importedModel=Append[importedModel,Global`SBMLContext-> $SBML$Context]];


If[SBMLRead$returnIC, importedModel=
Append[importedModel,
Global`SBMLIC->ToExpression[initialize[SBMLVariables]]
]];

If[SBMLRead$returnConstants, importedModel=Append[importedModel,Global`SBMLConstants->(SBMLReplacementRules)]];

If[SBMLRead$returnSpecies, importedModel=Append[importedModel,
Global`SBMLSpecies->functionate[$SBML$Species$IDs]
]];

If[SBMLRead$returnGlobalParameters, importedModel=Append[importedModel,
Global`SBMLParameters->SBMLGlobalParameters
]];

If[SBMLRead$returnModelVariables, importedModel=Append[importedModel,
Global`SBMLModelVariables->ToExpression[functionate[SBMLVariables]]
]];

If[SBMLRead$returnAlgebraicRules, importedModel=Append[importedModel,Global`SBMLAlgebraicRules-> $SBML$Algebraic$Rules]];

If[SBMLRead$returnUnitDefinitions, importedModel=Append[importedModel,Global`SBMLUnitDefinitions-> $SBML$UnitRules]];

If[SBMLRead$returnUnitAssociations, importedModel=Append[importedModel,Global`SBMLUnitAssociations-> $SBML$UnitAssociations]];

If[SBMLRead$returnReactions, importedModel=Append[importedModel,Global`SBMLReactions-> $SBML$Reactions]];

If[SBMLRead$returnModelName,
importedModel = Append[importedModel,Global`SBMLModelName-> modelname];
];

If[SBMLRead$returnCompartments,
importedModel = Append[importedModel,
Global`SBMLCompartments->( ToExpression/@$SBML$CompartmentNames)];
]; 

If[SBMLRead$returnSpeciesCompartmentAssociations,
importedModel = Append[importedModel,Global`SBMLSpeciesCompartmentAssociations-> $SBML$SpeciesCompartmentAssociations];
];

If[SBMLRead$returnSolution>0, 
numericalSolution = SBMLNDSolve[importedModel, SBMLRead$returnSolution,
Sequence[SBML$NDSolveOptions]
]; 
importedModel = Append[importedModel, Global`SBMLNumericalSolution-> numericalSolution];
];

];

importedModel=Append[importedModel, Global`SBMLLevelVersion-> ToExpression[$SBML$Level$Version]];
importedModel=Sort[importedModel];
Return[importedModel];
];


If[$$LoadBug, Print["Loading:setModelContext"]];


(* If[Length[Names["PreviousModelContexts"]]>0,
PreviousModelContexts=Flatten[{PreviousModelContexts}],
PreviousModelContexts={};
];
*) 
PreviousModelContexts={};

setModelContext[name_]:= Module[{},
If[$SBML$Context=="Automatic",
$SBML$Context=name<>"`",

If[StringTake[$SBML$Context,-1]!= "`", 
$SBML$Context=$SBML$Context<>"`"
];


];
If[$SBML$Context=="None`", 
$SBML$UnitsContext="Units`", 
$SBML$UnitsContext=$SBML$Context<>"Units`"
];

PreviousModelContexts=Union[AppendTo[PreviousModelContexts,$SBML$Context]];

]; 


If[$$LoadBug, Print["Loading:printStatistics"]];


printStatistics[]:= Module[{},
If[$SBML$Stats,
statistics = {
{"Compartments",$SBML$NCompartments},
{"Species",Length[SBMLVariables]},
{"ODES",Length[$SBML$ODES]},
{"Global Parameters", $SBML$NGlobalParameters},
{"Local Parameters",$SBML$NLocalParameters},
{"Rules",$SBML$NRules},
{"Reactions",$SBML$NReactions}

};

If[$SBML$Level>1, 
statistics = Append[statistics,
{"Events",$SBML$NEvents}];
];
statistics = Join[statistics,{{"CPU Used",TimeUsed[]-$SBML$InitialCPU},
{"Warnings", $SBML$FileWarnings}}];

printTable[statistics,title-> "File Statistics",columnHeaders->{"Description","Value"}];
];
];


If[$$LoadBug, Print["Loading:determineSBMLVersion"]];


determineSBMLVersion[{opt___}]:= Module[{lev,ver,options,xmlns,expectedXMLNS,
$XMLNS={"http://www.w3.org/2000/xmlns/","xmlns"}
},
options = Flatten[{opt}];
lev = "level"/.options/.{"level"-> "0"}//ToString//ToExpression;
ver = "version"/.options/.{"version"-> "0"}//ToString//ToExpression;


$SBML$Level = lev;
$SBML$Version=ver;
$SBML$Level$Version = ToString[$SBML$Level]<>"."<>ToString[$SBML$Version];

Switch[$SBML$Level$Version,
"1.1",expectedXMLNS= "http://www.sbml.org/sbml/level1";,
"1.2",expectedXMLNS= "http://www.sbml.org/sbml/level1";,
"2.1",expectedXMLNS= "http://www.sbml.org/sbml/level2";,
"2.2",expectedXMLNS= "http://www.sbml.org/sbml/level2/version2";,
"2.3", expectedXMLNS="http://www.sbml.org/sbml/level2/version3";,
"2.4", expectedXMLNS="http://www.sbml.org/sbml/level2/version4";,
_,expectedXMLNS= "??-UNKNOWN-NAMESPACE-Level-"<>stringer[$SBML$Level]<>"-Version-"<>stringer[$SBML$Version]<>"-??";
]; 

xmlns =$XMLNS/.options/.{$XMLNS->expectedXMLNS};

If[xmlns!= expectedXMLNS,
Print["Error: "//boldRed,
"Specified Namespace = "//boldBlack,"'"<>xmlns<>"'"//boldBlue, "is not consistent with SBML Level "//boldBlack, $SBML$Level//boldBlue, " Version "//boldBlack, $SBML$Version//boldBlue,"\nThe correct namespace is "//boldBlack,
"'"<>expectedXMLNS<>"'"//boldBlue
]];

Return[{lev,ver}];
]


reportMisingIC[]:= Module[{variablesWithoutIC},

variablesWithoutIC = 
Select[SBMLVariables,SBMLIC[#]==ToString[$SBML$IndeterminateValue]&];

If[Length[variablesWithoutIC]>0, 
If [$SBML$UseDefaultIC, 
printWarning["The following variables do not have initial conditions: "<>list2CommaSeparatedString[variablesWithoutIC]<>". They have  been assigned a default value of "<>$SBML$DefaultIC];

Map[definef[SBMLIC,#,ToString[$SBML$DefaultIC]]&, variablesWithoutIC];


,
printWarning["The following variables do not have initial conditions: "<>variablesWithoutIC<>". A default value may be assigned using the option defaultIC."];

]; 
]; 
Return[];
]


reportUnassignedParameters[]:= Module[{},

If[Length[SBMLUndefinedConstants]>0,

If[$SBML$UseDefaultParameterValue,
printWarning["The following parameters were not defined in the model: "<>list2CommaSeparatedString[SBMLUndefinedConstants]<>". These parameters were assigned a default value of "<>$SBML$DefaultParameterValue];

,printWarning["The following parameters were not defined in the model: "<>list2CommaSeparatedString[SBMLUndefinedConstants]<>". You can use the option defaultParameterValue to define a global default value."];
];
]; 



];


If[$$LoadBug, Print["Loading:definef"]];


definef[f_,x_,value_]:= Module[{debug=False, useval},
useval = value;
If[f===SBMLIC \[And] stringer[decontextify[ x ]]== "t"  \[And] value=="Indeterminate", 
useval = "0"
]; 

If[debug, Print["definef: {f, x, value}:", {f, x, useval}]];

f[x]=useval
];


ReplaceRuleListPart[opt_-> value_, oldOptList_]:= Module[{old,i,new},
old = Flatten[{oldOptList}]; 
i = Flatten[Position[First/@old, opt]]; 
If[Length[i]>0, 
i = First[i]; 
new = ReplacePart[old, opt-> value, i];
,
new = Append[old, opt-> value];
]; 
Return[new];
];


If[$$LoadBug, Print["Loading:getSymbols"]];


getSymbols[exp_]:= Module[{v,expr,myxml, dbg=False},

expr=exp;
If[StringQ[expr],expr=ToExpression[expr]];

myxml["ci",{___},{x_}]:= x;
myxml["csymbol",___]:= {}; 

myxml[_, {___}, {z___}]:= {z};


v =Xpression2SymbolicMathML[expr];

If[dbg, Print["getSymbols: v(1):", v]]; 

v =ToExpression/@(( v/.{XMLElement-> myxml})//Flatten//Union);
If[dbg, Print["getSymbols: v(2):", v]]; 
v = Select[v, !(NumberQ[#])&];
v=Complement[v,{If}];

If[dbg, Print["getSymbols: exp: ", exp, " v: ", v]; 
]; 

Return[v];
];


getInterpolatingFunction[InterpolationSet[t1_, t2_, if_]]:= if;


NDSolveSBMLWithEvents[inputSystem_, tmax_,ievents_,iconstraints_, opt___?OptionQ]:= Module[{modelvariables, r,ic,vars,triggeredvars,dbg=True,n="Not Implemented", triggers,test, tevent,triggeredEvents,t,tstart,tstop,actions,triggeredActions,nonTriggeredVars,solution,ievent,triggeredNames, eventNames,trace,delays,triggeredDelays,badeventdt,iclose,dtevent, values, eventLast,maxclose,maxevents,fs,triggeredValues,delayed,currentDelayValues,remappedEvents, events,eventflags,delayedNames,delayAmounts,havedelays,delayedActions,currentlyDelayedActions,savedEvents,newEvents,constants,flagvariables,
icalready,ic2use,ic4flags,constraints,triggeredConstraints,constraintMessages,
interpolateForEventTime,intInterval, remapEvents, updateEvents, constraintsToEvents
},

dbg = Global`debug/.{opt}/.{Global`debug-> False};
If[dbg, Print["NDSolveSBMLWithEvents:events:",ievents];
Print["NDSolveSBMLWithEvents:constraints:",iconstraints];
];

flagvariables={};

trace = (Global`trace/.Flatten[{opt}])/.{Global`trace-> False};
maxevents = (Global`MaxEvents/.Flatten[{opt}])/.{Global`MaxEvents-> 100};
maxclose=(Global`MaxCloseEvents/.Flatten[{opt}])/.{Global`MaxCloseEvents-> 10};
eventLast=-Infinity;
badeventdt =(Global`BadEventTimePrecision)/.Flatten[{opt}]/.{Global`BadEventTimePrecision->10.^-7};

ievent=0;iclose=0;
r = inputSystem;
solution={};
n={};
fs = Global`SBMLFunctions/.r;
constants = Global`SBMLConstants/.r; (* added 2.5.13 4 May 06 *) 

If[dbg,
 Print["NDSolveSBMLWithEvents:"//boldBlue," ievents: "//boldOrange,ievents//boldBlue]; Print["NDSolveSBMLWithEvents:"//boldBlue," fs: "//boldOrange,fs//boldBlue];
 Print["NDSolveSBMLWithEvents:"//boldBlue,
" r (input): "//boldOrange,r//boldBlue]; 

]; 

constraintsToEvents[constraints_]:= Module[{events,dbg=False,i, constraintToEvent},

If[ToExpression[$SBML$Level$Version]<2.2, Return[{}]]; 
i=0;

If[dbg,Print["constraintsToEvents: "//boldBlue,"constraints: "//boldBlack, constraints//boldRed]];

constraintToEvent[c_]:= Module[{event,trigger,eventID},
trigger =First[c];
If[dbg, Print["constraintToEvent: trigger: ", trigger]]; 
 trigger=stringer[trigger]; 
i++;
eventID="Constraint\[UnderBracket]"<>ToString[i]<>"\[UnderBracket]$Violation"//contextify;
event=(eventID-> {"trigger"-> trigger,"delay"-> "0","events"-> {}});
Return[event];
];(* end of constraintToEvent *)

events = constraintToEvent/@constraints;

If[dbg,Print["constraintsToEvents: "//boldBlue,"mapped events: "//boldBlack, events//boldRed]];


Return[events];

];(* end of constraintsToEvents *)


(* Replace SBML Events with Mathematica Events defined as follows (rev. 10/28/04 2.4.3)

Each event e in E has a trigger expression Te and assignments Ae.
For each event e we create in mathematica 
(1) a variable Ve with initial value false
(2) a mathematica event with trigger (NOT Ve) AND Te and assignments Ae and Ve=true 
(3) a mathematica event with trigger Ve AND (NOT Te) and assignment Ve=false

*) 

remapEvents[evlist_,currentTime_]:= Module[{remapEvent, i,nev,flags, updatedEvents,ic,vars,odes,initialFlagVals},
If[dbg, Print["remapEvents:evlist:",evlist]]; 
i=0; 
(* nev=Length[evlist]; *) 
flags={};

remapEvent[evid_-> evdata_]:= Module[{tr,tr1,tr2,
de,ev,ev1, ev2,op, flag,ev1n,ev2n, new,delayedevents},
op = {evdata}//Flatten;
tr=ToExpression["trigger"/.op ];
de = "delay"/.op;
ev = "events"/.op;
If[stringer[de]!= "0", 
delayedevents=ev;
ev={},
delayedevents={}];


flag = Symbol[stringer[evid]<>"\[UnderBracket]$flag"];
flags = Append[flags, flag];
AppendTo[flagvariables, functionate[flag]];

ev1n=stringer[evid]<>"\[UnderBracket]$eventSet";
(* AppendTo[flagvariables, Symbol[functionate[ev1n]]]; *)

tr1=stringer[And[flag[Global`t]<0,tr]];
ev1 = Append[ev, stringer[flag[Global`t]-> 1]];
ev1 = {"trigger"-> tr1,"delay"-> de,"events"-> ev1,"delayedevents"-> delayedevents};

ev2n=stringer[evid]<>"\[UnderBracket]$eventReset";
(* AppendTo[flagvariables, Symbol[functionate[ev2n]]]; *)

tr2=stringer[And[flag[Global`t]>0, Not[tr]]];
ev2 = {stringer[flag[Global`t]-> -1]};
ev2 = {"trigger"-> tr2, "delay"-> "0", "events"-> ev2,"delayedevents"-> {}};

new = {ev1n-> ev1, ev2n-> ev2};
Return[new]; 
]; 
remapEvent[x___]:= Module[{},Print["Error:"//boldOrange, " remapEvent:"//boldRed," invalid input data format: "//boldBlack,{x}//boldRed];
Abort[];
];

(* end of remapEvent *) 


updatedEvents = remapEvent/@evlist;
updatedEvents = Join@@updatedEvents;

(* new initial values for event flags: save preset values, and assign -1 to new flags *)

eventflags = stringer/@flags; 
initialFlagVals = (SBMLIC/@eventflags);
initialFlagVals=initialFlagVals/.{"Indeterminate"-> "-1"};
MapThread[definef[SBMLIC, #1, #2]&, {eventflags,initialFlagVals}]; 

If[dbg, Print["remapEvents:",eventflags,initialFlagVals]; ]; 

(* add variable, IC values for eventflags *)

modelvariables=Global`SBMLModelVariables/.r ;
modelvariables=Global`SBMLModelVariables/.inputSystem;

(* of existing ic, use only those from the model, not for the flags *)

icalready=Global`SBMLIC/.r;
ic2use=Select[icalready,MemberQ[Head/@modelvariables,Head[First[#]]]&];

(* assign new ic for flags based on values found above *)
ic4flags=MapThread[
(( #1[currentTime]==#2)&), {flags, ToExpression/@initialFlagVals}];

ic = Join[ic2use,ic4flags];

r=ReplaceRuleListPart[Global`SBMLIC-> ic,r];


vars = Join[modelvariables,(#[Global`t])&/@flags];
r = ReplaceRuleListPart[Global`SBMLModelVariables-> vars, r];

If[dbg, Print["SBMLIC/.input:",Global`SBMLIC/.inputSystem,
"\nSBMLIC/.r (new):",Global`SBMLIC/.r,"\n-------------------------"];];



Return[updatedEvents];

];(* end of remapEvents *) 


interpolateForEventTime[tfirst_, tlast_, precision_]:= Module[{ta,tb,tc, dt,result, nsteps},
ta = tfirst; tb = tlast;dt = tb-ta;
If[dbg, 
Print["interpolateForEventTime: {tfirst,tlast},triggers:",{tfirst,tlast},triggers];
Print[triggers/.n/.{Global`t-> tlast}];
];

(* check to see if set at tfirst 3/4/05 2.4.9*)
result = (test/.n)/.{Global`t-> ta};
If[tfirst>0,
If[result,
result=Map[(#/.n)/.{Global`t-> ta}&,triggers];

Return[{ta,result}];
];
]; 

(* In Version 5.1, Method-> EventLocator will have already found the event time *)
(* If[$VersionNumber>5,
result=Map[(#/.n)/.{Global`t-> tb}&,triggers];
Return[{tb,result}];
];
*) 

nsteps=0;
While[dt>precision,
tc = (tb+ta)/2;
result = (test/.n)/.{Global`t-> tc};
If[dbg,
Print[
"interpolateForEventTime: "//boldBlue,"{ta,tc,tb},result:"//boldOrange,
{ta,tc,tb}//boldBlue,","//boldBlue,
result//boldBlue," triggers:"//boldOrange,(triggers/.n/.{Global`t-> tc})//boldBlue]
];
If[result,tb=tc,ta =tc];
dt = tb-ta;
nsteps++;
]; 

If[dbg,Print["interpolateForEventTime: iterations:",nsteps]];

(* check to see if it should really be at tlast 2.4.9 *)
If[tb>= tlast-precision,tb=tlast];

(* check for individual condition at stopping time *)

result=Map[(#/.n)/.{Global`t-> tb}&,triggers];
Return[{tb,result}];
];  (* end of interpolateForEventTime *)

intInterval[]:= Module[{c,int},
c=Cases[n,InterpolatingFunction[___][___],Infinity];
int[InterpolatingFunction[domain_, table___][t___]]:= Flatten[{domain}];
Return[int[First[c]]];
]; (* end of intInterval *)

updateEvents[currentEvents_, updateTime_]:= Module[{dbg=False},
savedEvents=currentEvents;
(* Print["currentEvents:",currentEvents]; *)

remappedEvents= remapEvents[currentEvents, updateTime];
(* Print["remappedEvents:",remappedEvents]; *) 

If[dbg,
 Print["NDSolveSBMLWithEvents:"//boldBlue,
" remappedEvents: "//boldOrange,remappedEvents//boldBlue,"\nNDSolveSBMLWithEvents:"//boldBlue,
" eventflags: "//boldOrange,eventflags//boldBlue,"\nNDSolveSBMLWithEvents:"//boldBlue,
" r (revised): "//boldOrange,r//boldBlue]; 
]; 

events = remappedEvents;

triggers = Map["trigger"/.#&,Last/@events];
triggers = Map[StringReplace[#, "[t]"-> "[Global`t]"]&, triggers];
triggers =  ToExpression/@triggers;
triggers = triggers//.fs;
triggers = triggers/.constants; (* added 5/4/06 2.5.13 *)


If[dbg, Print["NDSolveSBMLWithEvents: triggers:", triggers]];

test=Or@@triggers;


eventNames=First/@events;
actions = Map["events"/.#&,Last/@events];
ic = Global`SBMLIC/.r;
vars =Head/@( First/@ic);
values = Last/@ic;
delayedActions=Map["delayedevents"/.#&,Last/@events];


delays = ToExpression/@Map["delay"/.#&,Last/@events];
havedelays = ToString[#]!="0"&/@delays;



If[dbg, 
Print["updateEvents:\n","names:",eventNames,"\nactions:",actions,"\ndelays:",delays,"\nhavedelays:",havedelays,"\ndelayedActions:",delayedActions];Print["NDSolveSBMLWithEvents:"//boldBlue," triggers: "//boldOrange,triggers//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "actions: "//boldOrange,actions//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "vars: "//boldOrange,vars//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "actions: "//boldOrange,actions//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "ic: "//boldOrange,ic//boldBlue,
"\nNDSolveSBMLWithEvents:"//boldBlue, "vars: "//boldOrange,vars//boldBlue,"\nNDSolveSBMLWithEvents:"//boldBlue, "values: "//boldOrange,values//boldBlue];
]; 

(* reset SBMLIC because this might not be the first time this model has been run since it was loaded, and an event might have reset an IC - 2.3.33 *)

MapThread[definef[SBMLIC, #1, #2]&, {stringer/@vars,stringer/@ values}]; 

]; (* end of updateEvents *)

If[dbg, Print["ievents:", ievents]]; 

If[dbg, Print["iconstraints: ",iconstraints]];
constraints=constraintsToEvents[iconstraints];
If[dbg, Print["constraints: ",constraints]];

(* convert message to something useful*) 
Block[{totext},
totext[x_]:= Module[{y,xml},
xml["message",{}, {z__}]:= First[{z}]; 
xml["message",{},z_]:=z;
xml["body",_, {z__}]:= First[{z}]; 
xml["bocy",_, z_]:= z; 
xml[z___]:= XMLElement[z]; 
y=x//.{XMLElement-> xml};
Return[y];
];

constraintMessages= Map[Rule[#[[1]], totext[#[[2]]]]&, iconstraints];
If[dbg, Print["constraintMessages: ",constraintMessages]];
];

t=0;
updateEvents[Join[ievents,constraints], t];

While[t<tmax,

If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"t:"//boldOrange,t//boldBlue,"*********************"//boldRed];
Print["NDSolveSBMLWithEvents:"//boldBlue,
"ic:"//boldOrange,ic//boldBlue];
Print["NDSolveSBMLWithEvents:"//boldBlue,"test:"//boldOrange,test//boldBlue];
];


n=NDSolveSBMLModel[r,t, tmax, StoppingTest-> test, opt];
If[ToString[n]=="$Failed", Return[$Failed]]; 


n = Flatten[n];
If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"n: "//boldOrange,n//boldBlue]];
 

{tstart,tstop}=intInterval[];

If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"{tstart,tstop}: "//boldOrange,{tstart,tstop}//boldBlue]];

{  tevent,triggeredEvents}=interpolateForEventTime[tstart,tstop,10^(-7)];

If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"{tevent,triggeredEvents}: "//boldOrange,{tevent,triggeredEvents}//boldBlue]];

(* Add solution to set only if it has a non-zero duration -
might be a set/reset situation and don't need a separate interpolation curve) 
-- added test 3-4-05 2.4.9 *)

(* Replace MemberQ[modelvariables,First[#]] with Not[MemberQ[flagvariables,First[#]]] -- 2.5.25 8/1/06
 *)


If[tevent>tstart,
solution = Append[solution,InterpolationSet[t,tevent,Select[n, Not[MemberQ[flagvariables,First[#]]]&]
]];
];

triggeredDelays=Last/@Select[ {triggeredEvents,delays}//Transpose, First];

If[dbg,Print["NDSolveSBMLWithEvents:"//boldBlue,"revised solution: "//boldOrange,solution//boldBlue]];


currentDelayValues=triggeredDelays/.n/.{Global`t-> tevent};
delayed=Positive/@currentDelayValues;
triggeredNames =Last/@Select[ {triggeredEvents,eventNames}//Transpose, First];


If[dbg,Print["triggeredNames:",triggeredNames,"\ntriggeredDelays:",triggeredDelays,"\ncurrentDelayValues:",currentDelayValues,"\ndelayed:",delayed]];

(* check for triggered constraints *)
triggeredConstraints = decontextify/@triggeredNames;
triggeredConstraints=Select[triggeredConstraints,And[StringTake[#,10]=="Constraint",StringTake[#,-9]=="$eventSet"]&];
If[Length[triggeredConstraints]>0,
triggeredConstraints=StringDrop[#,11]&/@triggeredConstraints; (* drop "Constraint\[UnderBracket]" *) 
triggeredConstraints=StringDrop[#,-21]&/@triggeredConstraints; (* dropt "\[UnderBracket]$Violation\[UnderBracket]$EventSet *)
triggeredConstraints=ToExpression/@triggeredConstraints; (* should be a list of integers now *)

Print["Constraint violation: "//boldRed,constraintMessages[[#,2]]//boldBlue,"\nConstraint violated at t = "//boldBlack,tevent//boldBlack]&/@triggeredConstraints;

]; 

MapThread[
If[#1< 0, 
Print["Warning:"//boldRed,"A negative delay of "//boldBlack,#1//boldBlue," for event "//boldBlack,#2//boldBlue," was set at t = "//boldBlack,tevent//boldBlue]
]&,
{currentDelayValues,triggeredNames}];


newEvents={};
If[And@@delayed,
delayedNames=Last/@Select[{delayed,triggeredNames}//Transpose,First];
delayAmounts=
Last/@Select[{delayed,currentDelayValues}//Transpose,First];
currentlyDelayedActions=
Last/@Select[ {triggeredEvents,delayedActions}//Transpose, First];

If[dbg, MapThread[
Print["Delayed Event:",#1," delay:",#2," actions:",#3]&,{delayedNames,delayAmounts, currentlyDelayedActions}];
]; 

newEvents=stringer/@Table[Unique[stringer[$SBML$Context]<>"delayed\[UnderBracket]event\[UnderBracket]"], {Length[delayedNames]}];

newEvents=MapThread[Rule[#1, 
{
"trigger"-> stringer[(Global`t>=(tevent+ #2))], 
"delay"-> "0",
"events"->(stringer/@ #3)
}]&,
{newEvents, delayAmounts, currentlyDelayedActions}];

If[dbg, Print["newEvents:",newEvents];];
];


ievent++;

If[trace,
If[tevent<tmax,
(* Print["Event Trace: "//boldRed,"("//boldBlack,ievent//boldBlue,") t:"//boldBlack,tevent//boldBlue," Event(s): "//boldBlack,list2CommaSeparatedString[decontextify/@ToString/@triggeredNames]//boldBlue," Delay(s):"//boldBlack,
list2CommaSeparatedString[ToString/@currentDelayValues]//boldBlue];*)

MapThread[
Print["Event Trigger: "//boldRed, ievent//boldBlue," t="//boldBlack,tevent//boldBlue, " Event = "//boldBlack,#1//boldBlue, " Delay = "//boldBlack ,#2//boldBlue]&,
{decontextify/@ToString/@triggeredNames, ToString/@currentDelayValues}
];
If[dbg,Print["{tstart, tevent, tstop}:",{tstart,tevent,tstop}]];
,
Print["Event Trigger: "//boldRed,"t:"//boldBlack,tevent//boldBlue," Event: "//boldBlack,"RequestedEndOfSimulation"//boldBlue];
];
]; 

If[ievent>maxevents, 
Print["Error: "//boldRed,"Possible bad event structure; more than "//boldBlack,maxevents//boldBlue," events (MaxEvents) have occurred.  by t="//boldBlack,tevent//boldBlue,"(To inhibit this check set MaxEvents\[Rule]Infinity)."//boldBlack]; 
Abort[]
];

dtevent = t-eventLast; eventLast=t;
If[dtevent<badeventdt,
iclose++;
If[iclose>= maxclose, 
Print[
">>Error Abort: "//boldOrange,"Possible Bad Event (MaxCloseEvents). The event(s): "//boldBlack,list2CommaSeparatedString[ToString/@triggeredNames]//boldRed, 
" has (have) occurred "//boldBlack,
maxclose//boldBlack," (MaxCloseEvents) times within a very a time interval of "//boldBlack,
badeventdt//boldBlack," (BadEventTimePrecision) at t="//boldBlack,tevent//boldBlack]; 
Abort[];
];
,
iclose=0;
]; 


(* make a list of all the actions that need to occur *)
triggeredActions =Flatten[
Last/@Select[
Transpose[{triggeredEvents,actions}],
First]
];

triggeredActions=ToExpression/@triggeredActions;


If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"{tstart,tstop}:"//boldOrange,{tstart,tstop}//boldBlue];
];


(* some initial conditions will be based on actions *)
triggeredActions=triggeredActions/.{Rule-> List};
triggeredvars=Head/@First/@triggeredActions;

(* 2.3.33 - make sure SBMLIT is reset correctly *) 
triggeredvalues = (Last/@triggeredActions)/.n/.{Global`t-> tevent};
If[dbg, 
Print["NDSolveSBMLWithEvents:"//boldBlue," triggeredvars: "//boldOrange,triggeredvars//boldBlue];
Print["NDSolveSBMLWithEvents:"//boldBlue," triggeredActions(1): "//boldOrange,triggeredActions//boldBlue];
Print["NDSolveSBMLWithEvents:"//boldBlue," triggeredvalues: "//boldOrange,triggeredvalues//boldBlue];

]; 
MapThread[definef[SBMLIC, #1, #2]&, {stringer/@triggeredvars,stringer/@ triggeredvalues}]; 
(* end of 2.3.33 fix *) 


triggeredActions=MapThread[#1[Global`t]==#2&,{triggeredvars, triggeredvalues}];
triggeredActions = triggeredActions/.{Global`t-> tevent};

If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"triggeredActions(2):"//boldOrange,triggeredActions//boldBlue];
];

(* determine remainder of initial conditions *)
nonTriggeredVars= Complement[vars, triggeredvars];
If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"nonTriggeredVars:"//boldOrange,nonTriggeredVars//boldBlue];
];

ic = Map[
Equal[
#[tevent],
(#[Global`t]/.n)/.{Global`t-> tevent}
]&,
nonTriggeredVars];
ic = Join[ic,triggeredActions];
If[dbg,
Print["NDSolveSBMLWithEvents:"//boldBlue,
"modified ic:"//boldOrange,ic//boldBlue];
];

r=ReplaceRuleListPart[Global`SBMLIC-> ic,r];

t=tevent;

(* and the new events for delayed events  *)

If[And@@delayed,updateEvents[Join[savedEvents,newEvents], t]];

]; (* end While t < tmax *)

(* reset the event flags and other IC so they don't persist for another run, as they have been changed 2.5.13, 4 May 06 *)

Clear[SBMLIC];
SBMLIC[unknownVariable_]:=ToString[$SBML$IndeterminateValue];

Return[solution];
];


If[$$LoadBug, Print["Loading:solveUntil"]];


solveUntil[condition_,equations_, variables_, {t_, tmin_,tmax_}, 
opt___?OptionQ]:= Module[{n,tstop,thalt,dbg=False,options,legacyEvent},

If[dbg,
Print[">>>debug solveUntil: {opt}:"//boldRed,{opt}]
];

legacyEvent=(($VersionNumber<5.0 )\[And] (ToString[condition]!= "True"));

If[$VersionNumber<5.1,
If[legacyEvent, Off[InterpolatingFunction::"inhr"]];
(* turning off this message does not appear to work in 4.2
even though it is guaranteed to occur. *)
n=NDSolve[equations,variables,{t,tmin,tmax},StoppingTest-> condition,opt];
If[legacyEvent, On[InterpolatingFunction::"inhr"]];
Return[{tmax, n}];
]; 

(* use throw/catch instead *)
n=Catch[
NDSolve[equations,variables,{t,tmin,tmax},StepMonitor:> 
(If[condition \[Or] (t>= tmax), Throw[t]]),opt
]
];
If[ListQ[n], Return[{t, n}]];
tstop = n;
If[dbg,
Print[">>>debug solveUntil: Event located at "//boldRed," tstop:"//boldBlack,tstop//boldBlue]
];

thalt=Min[tstop,tmax];

If[dbg,
Print[">>>debug solveUntil: thalt "//boldRed,thalt]
];

n=NDSolve[equations,variables,
{t,tmin,thalt},opt];

Return[{thalt, n}];
]



neededCompartmentSizesDefined[x_]:= Module[{r,rules,arulevars,  defunct,odevars,ic, decont,debug=False, uninitializedCompartments, initialassignments},
defunct[a_[b_]]:= a[b];
defunct[a_'[b_]]:= a[b];
decont[Rule[a_,b_]]:= Rule[decontextify[a],decontextify[b]];

If[False, Print["neededCompartmentSizesDefined: x, ",x]]; 

r= Global`SBMLSpeciesCompartmentAssociations/.x;
If[debug, Print["neededCompartmentSizesDefined: r, ",r]]; 

(* remove compartments that have constant volumes assigned *)
r= expressionate/@r;
If[debug, Print["neededCompartmentSizesDefined: r (2):",r]]; 
rules=(Global`SBMLConstants/.x);
If[debug, Print["neededCompartmentSizesDefined: rules:",rules]]; 


r=Rule[First[#], Last[#]/.rules]&/@(r/.{Rule-> List});
If[debug, Print["neededCompartmentSizesDefined: r (2.5):",r]]; 

r=Select[r,!NumberQ[Last[#]]&];
If[debug, Print["neededCompartmentSizesDefined: r (3):",r]]; 

(* remove compartments that have assignment rules *)
arulevars =First/@( (Global`SBMLAssignmentRules/.x/.Global`SBMLAssignmentRules-> {}));
arulevars = defunct/@arulevars;
If[debug, Print["neededCompartmentSizesDefined: arulevars:",arulevars]]; 

r=Select[r, !MemberQ[arulevars,Last[#]]&];
If[debug, Print["neededCompartmentSizesDefined: r (4):",r]]; 

(* remove compartments that have rate rules *)

odevars = (Global`SBMLODES/.x/.{Global`SBMLODES-> {}});
odevars =defunct/@(First/@odevars);
If[debug, Print["neededCompartmentSizesDefined: odevars:",odevars]]; 
r=Select[r, !MemberQ[odevars,Last[#]]&];
If[debug, Print["neededCompartmentSizesDefined: r (5):",r]]; 

r=decont/@r;
If[debug, Print["neededCompartmentSizesDefined: r (6):",r]]; 

(* remove compartments that have initial conditions defined *)
(* these are compartments with constant->false but do not have rules *)
ic =First/@(Global`SBMLIC/.x);
(* added 2.7.4  because otherwise the ics were ignored !! *) 
ic= decontextify/@ic;
If[debug, Print["ic: ", ic]]; 


r=Select[r, !MemberQ[ic,Last[#]/.{Global`t-> 0}]&];
If[debug, Print["neededCompartmentSizesDefined: r (7):",r]]; 

r=(r/.{Rule-> List}); 
If[Length[r]>0, 
uninitializedCompartments=Union[Last/@r], 
Return[{}]
]; 

If[debug, Print["uninitializedCompartments:", uninitializedCompartments]]; 

(* remove initial assignments  - added 2.7.4 *)
initialassignments = Global`SBMLInitialAssignments/.x/.{Global`SBMLInitialAssignments-> {}}; 
initialassignments=decontextify/@First/@(initialassignments/.{Rule-> List});
initialassignments=functionate/@Map[If[SameQ[Head[#], Symbol], #, Head[#]]&, initialassignments];

If[debug, Print["initialassignments: ", initialassignments]]; 
uninitializedCompartments = Complement[uninitializedCompartments, initialassignments]; 


If[Length[uninitializedCompartments]>0, 

(* set remaining compartments to 1 *)

r=Rule[contextify[#],1]&/@uninitializedCompartments; 

Print["Error: "//boldRed, "SBMLNDSolve: uninitialized compartment: "//boldBlack, "\""<>stringer[#]<>"\""//boldBlue, " -- A default value of 1 will be used; this may be different from the intent of the model. "//boldBlack]&/@ uninitializedCompartments;
If[debug, Print["neededCompartmentSizesDefined: r (8):", r]]; 
Return[r];
];
Return[{}]; 
]


NDSolveSBMLModel[r_, tstart_, tmax_, opt___?OptionQ]:= Module[{s,odes,ic,rules,vars,fs,system, addedDummyVariable,
varsWithoutODES, ODESWithoutVars,devars,varsindes,vars2remove, varsinic, ic2add,sodes,ic2,indic, extraodes,dbg, systemvars, definedvars, undefinedvars,p, ars,asrs,haveAlgebraicRules, haveAssignmentRules,namesofvars2remove, pgoal, asrules, arvars,retry,NDSolveOptions,solver, test,algic,fluxes,sars,sppecies, compartments, hasAlgebraicRule,hasAssignmentRule, varname, texit, whatis, whatsitsname, nameItIfNecessary, udcrs, constants
},

dbg = Global`debug/.{opt}/.{Global`debug-> False};

whatsitsname[uin_]:= Module[{nids, itsname}, 

nids=$SBML$NameIDAssociations;
nids = Rule[decontextify[First[#]], Last[#]]&/@nids;
itsname = uin/.nids/.{uin-> ""};
Return[itsname];
]; 

whatis[uin_]:= Module[{s, p, u},

u=defunctionate[stringer[uin]]; 
s=stringer/@defunctionate/@decontextify/@(Global`SBMLSpecies/.r);

If[MemberQ[s, u], Return["species"]]; 
p =stringer/@defunctionate/@decontextify/@( Global`SBMLParameters/.r);
If[MemberQ[p, u], Return["parameter"]]; 


Return["variable"]; 
];

nameItIfNecessary[uin_]:= Module[{itsname}, 
itsname=whatsitsname[uin];
If[stringer[itsname]!= stringer[uin], 
Return[ " ("<>stringer[itsname]<>") "]
]; 
Return[""]; 
];

debugPrint[dbg, "NDSolveSBMLModel:: tstart,tmax ", {tstart,tmax}];

varname[u_'[arg_]]:= u;

(* catch return value for undefined compartments 2.7.0.5 29 Nov 07 *)
udcrs = neededCompartmentSizesDefined[r];
debugPrint[dbg, "NDSolveSBMLModel: udcrs", udcrs]; 

odes = Global`SBMLODES/.r;
ic= Global`SBMLIC/.r;

(* include undefined compartment rules here 2.7.0.5 29 Nov 07 *)
rules=(Global`SBMLConstants/.r);
rules=Join[rules, udcrs];

vars = Global`SBMLModelVariables/.r;
fs = (Global`SBMLFunctions/.r)/.(Global`SBMLFunctions-> {});
ars = (Global`SBMLAlgebraicRules/.r/.Global`SBMLAlgebraicRules-> {}); 
asrs = (Global`SBMLAssignmentRules/.r/.Global`SBMLAssignmentRules-> {}); 

(* turn fluxes into assignment rules 2.5.25 1-Aug-06 *)
fluxes = Global`SBMLKineticLaws/.r/.{Global`SBMLKineticLaws-> {}};
asrs = Join[asrs, fluxes];
asrs = asrs//.rules;

asrules = asrs/.{Equal-> Rule};
arvars = First/@asrules;

(* removes variables with assignment rules 2.4.4 1-Nov-04 *) 

vars = Complement[vars,arvars];
odes = odes//.asrules;

If[Length[odes]<1, 
odes = Append[odes, differentize[addedDummyVariable]==0]; 
ic =Append[ic,addedDummyVariable[tstart]==1];
vars = Append[vars, functionate[addedDummyVariable]];
];

If[dbg, 
debugPrint[dbg, "NDSolveSBMLModel:: odes", odes];
debugPrint[dbg, "NDSolveSBMLModel:: ic", ic];
debugPrint[dbg, "NDSolveSBMLModel:: vars", vars];
debugPrint[dbg, "NDSolveSBMLModel:: asrules", asrules];
debugPrint[dbg, "NDSolveSBMLModel:: arvars", arvars];
]; 

hasAlgebraicRule[x_]:=( Length[Position[ars, x]]>0); 
hasAssignmentRule[x_]:= MemberQ[First/@(asrs),x];

(****** Check for Poorly formed system *****) 

(* devars is a list of variables like x'[t] *) 
devars = Map[ToString,vars]; 
devars =Map[StringReplace[#,"[t]"-> "'[t]"]&,devars];
devars = Map[ToExpression,devars]; 


(* remove any excess variables *) 
(* varsindes is the lhs of the odes, x'[t] *)
varsindes = Map[First,odes];
varsWithoutODES = Complement[devars,varsindes]; 

debugPrint[dbg, "NDSolveSBMLModel:: devars", devars];
debugPrint[dbg, "NDSolveSBMLModel:: varsindes", varsindes];

If[Length[varsWithoutODES]>0,

vars2remove = Map[ToExpression[StringReplace[ToString[#],"'[t]"-> "[t]"]]&,varsWithoutODES];

(* check to see if any of the variables have algebraic rules -- if so, not necessary to add an ODE  - don't check Mathematica Version here, because it is checked elsewhere in this function. Added 7-31-03  *) 

debugPrint[dbg, "NDSolveSBMLModel:: vars2remove", vars2remove];
haveAlgebraicRules= Select[vars2remove, hasAlgebraicRule];
haveAssignmentRules= Select[vars2remove, hasAssignmentRule];
vars2remove = Complement[vars2remove, haveAlgebraicRules  ,haveAssignmentRules  ]; 
debugPrint[dbg, "NDSolveSBMLModel:: haveAlgebraicRules", haveAlgebraicRules];
debugPrint[dbg, "NDSolveSBMLModel:: haveAssignmentRules", haveAssignmentRules];
debugPrint[dbg, "NDSolveSBMLModel:: vars2remove", vars2remove];


vars2remove = Complement[vars2remove,{ Global`t[Global`t]}];

Block[{notAFlag, notFlags},

notAFlag[v_]:= Not[StringMatchQ[stringer[v], RegularExpression["(.+)\[UnderBracket]\$(.+)"]]];
notFlags=Select[vars2remove,notAFlag];

If[Length[vars2remove]>0  (* \[And] TrueQ[$VersionNumber< 5  ] *) ,

(* add odes of the form x'[t]=0 for extra variables if prior to version 5 *)
(* extraodes=ToExpression/@Map[StringReplace[#,"[t]"-> "'[t]==0"]&, ToString/@vars2remove]; *)
extraodes=ToExpression/@Map[StringReplace[#,"[t]"-> "'[t]==0"]&, ToString/@vars2remove]; 

odes = Join[odes, extraodes]; 
varsindes = Map[First,odes];


notFlags = ToString/@notFlags;
notFlags=decontextify/@notFlags;
Module[{dbg=False},
debugPrint[dbg, "NDSolveSBMLModel::extraodes ", extraodes]; 
debugPrint[dbg, "NDSolveSBMLModel:: odes", odes];
debugPrint[dbg, "NDSolveSBMLModel:: varsindes", varsindes];
debugPrint[dbg, "NDSolveSBMLModel:: notFlags", notFlags];
debugPrint[dbg, "NDSolveSBMLModel:: vars2remove", vars2remove]
]; 




If[$ReportMissingODE,

Map[Print[
"Warning: "//boldRed,whatis[#]//boldBlack," ", 
#//boldBlue, 
" appears to be constant. "//boldBlack
]&,
notFlags];
$ReportMissingODE=False;
];
]; 
];
];
(* remove excess initial conditions *) 
(* change varsindes to be like x[0] instead of x'[t] *) 
varsindes = varname/@varsindes;
ic = Select[ic, MemberQ[varsindes,Head[First[#]]]&];

(* supply insufficent initial conditions *)
 (* varsinic is like x[0] *)
varsinic =Head/@First/@ic;
ic2add = Complement[varsindes, varsinic];

If[Length[ic2add]>0, 

If[$ReportMissingIC,
printWarning["No initial condition provided for "<>list2CommaSeparatedString[decontextify[ToString/@ic2add, $SBML$Context]]<>"; zeros assumed for missing values. "];
$ReportMissingIC=False;
]; 

ic2add = Map[#==0&, ic2add];
ic = Join[ic, ic2add];
];

(* check for indeterminates *)
ic2add = Select[ic, ToString[Last[#]]=="Indeterminate"&];
If[Length[ic2add]>0,
indic = Map[First, ic2add];
indic = Map[ToString,indic];
indic= Map[StringReplace[#,"["<>ToString[tstart]<>"]"->""]&, indic];
If[$ReportMissingIC,
Print["Warning: "//boldRed, whatis[#]//boldBlack," ",   (#<>nameItIfNecessary[#])//boldBlue, " has indeterminate initial conditions."//boldBlack]&/@decontextify[indic,$SBML$Context];
$ReportMissingIC=False;
]; 
ic = ic/.{Indeterminate-> 0};
];


If[$InitialRun, 

(* Process the Initial Assignments *)

If[ToExpression[$SBML$Level$Version]>2.15, 
Block[{debug=False, iass, arzero, ialhs, iarhs, arulesrhs, aruleslhs, icvars, icrules, icvals, checkRepeated, hasrules, ia2consts, ia2constsvals, rulevars, rulevals},
iass = Global`SBMLInitialAssignments/.r/.{Global`SBMLInitialAssignments-> {}}; 
If[Length[iass]>0, 
arzero = asrules/.{Global`t-> 0};
hasrules = Length[arzero]>0; 
{ialhs, iarhs}=Transpose[iass/.{Rule-> List}];
If[hasrules,
{aruleslhs, arulesrhs}=Transpose[arzero/.{Rule-> List}],
{aruleslhs, arulesrhs}={{},{}} 
]; 
icrules = ic/.{Equal-> Rule};
icvars = First/@(icrules/.{Rule-> List});
If[debug, 
Print["initialAssignments:", iass]; 
Print["ialhs=", ialhs];
Print["iarhs=", iarhs];
Print["assignmentRules: ", asrules];
Print["aruleslhs:", aruleslhs];
Print["arulesrhs:", arulesrhs]; 
Print["arzero:", arzero];
Print["icrules:", icrules]; 
Print["icvars:", icvars];
Print["vars:", vars];
Print["arvars:", arvars];
];

checkRepeated[u_, v_]:= Module[{},
Check[ReplaceRepeated[u,v, MaxIterations-> 256], 
(Print["Error: "//boldRed, " Suspected loop in assignmentRules and initialAssignments"//boldBlack];Abort[])
]
];

iarhs = checkRepeated[iarhs, iass]; 

iass=MapThread[Rule, {ialhs, iarhs}]; 
arulesrhs = checkRepeated[arulesrhs, arzero];
arzero=MapThread[Rule, {aruleslhs, arulesrhs}]; 

iass=Join[iass,arzero];

icvals =checkRepeated[icvars, iass];
icvals =checkRepeated[icvals, icrules];

ic = MapThread[Equal, {icvars, icvals}];

If[debug,
Print["initialAssignments:", iass]; 
Print["arzero:", arzero];
Print["icvals:", icvals]; 
Print["ic:", ic];
Print["rules: ", rules]; 
]; 

(* check for initial assignments to constants *)

ia2consts =  Complement[ialhs, icvars];

If[Length[ia2consts]>0, 
ia2constsvals = ia2consts/.iass; 

(* remove the[0] from the initial assignments *)
ia2consts = Map[
If[SameQ[Head[#], Symbol], #, Head[#]]&, 
ia2consts];

ia2consts = MapThread[Rule, {ia2consts, ia2constsvals}]; 

(* modify rules to account for initial assignments to cosntants *)

rulevars = Transpose[rules/.{Rule-> List}][[1]]; 
rulevals = rulevars/.ia2consts/.rules; 
rules = MapThread[Rule, {rulevars, rulevals}]; 

If[debug, 
Print["ia2consts: ", ia2consts , " (Constants with init assignments)"]; 
Print["{rulevars, rulevals}: ", {rulevars, rulevals}]; 
Print["rules (revised): ", rules]; 
];

] (* End If Length[ia2consts] > 0 *)
]  (* End if Length[iass]>0 ... *)
] (* end Block *) 
]; (* end > 2.15 *)

$InitialRun=False

]; (* end initial run *)



(* Join the initial conditions to the system of odes *)

system = ((Join[odes,ic]//.fs)//.rules); 


(* add ode-less variables as algebraic conditions *)
 
(* Block[{isAFlag, areFlags, flagnames},

isAFlag[v_]:= StringMatchQ[stringer[v], RegularExpression["(.+)\[UnderBracket]\$(.+)"]];
areFlags=Select[vars2remove,isAFlag];


If[Length[areFlags]>0 \[And] TrueQ[$VersionNumber>=  5],
areFlags = stringer/@areFlags;
flagnames = StringReplace[#,"[t]"-> ""]&/@areFlags;

(* Add check here to make sure none of the added SBMLIC are INDETERMINATE *) 
algic=SBMLIC/@flagnames;


MapThread[If[#2=="Indeterminate",
If[$FirstIteration, 
Print["Warning: "//boldOrange, " no initial condition was specified for "//boldBlack,#1//boldRed," -- a value of zero will be used instead."//boldBlack];
]; 
]&,
{areFlags,algic}
];
If[$FirstIteration, $FirstIteration=False];

algic = algic/.{"Indeterminate"-> "0"};

areFlags=ToExpression/@MapThread[#1<>"=="<>#2&,{areFlags, algic}]; 

areFlags = (areFlags//.fs)//.rules;

debugPrint[dbg, "NDSolveSBMLModel:: fs: ", fs];
debugPrint[dbg, "NDSolveSBMLModel:: rules: ", rules];
debugPrint[dbg, "NDSolveSBMLModel:: added to system: ", areFlags];
system = Join[areFlags,system];

,
Print["This model contains events. Events required Mathematica version 5.0++ and not "<>$Version];
Abort[];
];
];
*)

(* Add algebraic rules - 7/31/03 *) 
If[Length[ars]>0,
If[$VersionNumber>= 5.0, 
ars = ((ars//.fs)//.rules);
system = Join[system, ars];
,
PrintWarning["This model contains algebraic rules. The solution of Differential-Algebraic equations requires Mathematica 5.0 or greater. You have version "<>$Version];
Abort[]; 
]; 
]; 

(* add assignment rules to DAE system in version 2.3.20 *)
(* don't add assignment rules starting in 2.4.4 *) 
(*
If[Length[asrs]>0 \[And] TrueQ[$VersionNumber>= 5],
asrs = Map[Equal[First[#],( Last[#]//.fs)//.rules]&,asrs];
system = Join[system, asrs];
];
*) 

(* check to see if there are any undefined symbols and print error message if so - added 7/31/03 -- this will catch potential NDSolve crashes *) 

systemvars = getSymbols[Last/@system]; (* just look at RHS of odes *) 
definedvars = getSymbols[vars];
undefinedvars = Complement[systemvars, definedvars];

debugPrint[dbg, "NDSolveSBMLModel:: undefinedVars: ", undefinedvars];  

If[Length[undefinedvars]>0,
If[MemberQ[undefinedvars, Global`delay], Print["Sorry: "//boldRed, "This model appears to contain the csymbol "//boldBlack, "delay"//boldBlue, " which has not been implemented in SBMLNDSolve."//boldBlack];
Return[$Failed];
]; 
Print[
boldRed["Error: "], 
boldBlack["The symbol "],#//boldBlue, 
boldBlack[" does not appear to have a numerical value.  NDSolve may be unable to produce numerical results."]
]&/@Map[decontextify[#,$SBML$Context]&, undefinedvars];
];
(********* end of check for poorly formed system *********)


debugPrint[dbg, "NDSolveSBMLModel:: system", system];
debugPrint[dbg, "NDSolveSBMLModel:: vars", vars];
debugPrint[dbg, "NDSolveSBMLModel:: {opt}", {opt}];

NDSolveOptions=MyFilterOptions[NDSolve,opt];

test=StoppingTest/.{opt}/.{StoppingTest-> False};

debugPrint[dbg, "NDSolveSBMLModel:: NDSolveOptions", NDSolveOptions];


(* solve & retry if error in accuracy/precision 2.3.37*)
solver[options___?OptionQ]:= Module[{n,ops,dbg=False, failmsg}, 

debugPrint[dbg, "NDSolveSBMLModel:: solver:", "Calling NDSolve"];
debugPrint[dbg, "NDSolveSBMLModel:: solver: system: ", system];
debugPrint[dbg, "NDSolveSBMLModel:: solver: vars: ", vars];
debugPrint[dbg, "NDSolveSBMLModel:: solver: tstart: ", tstart];
debugPrint[dbg, "NDSolveSBMLModel:: solver: tmax: ", tmax];
debugPrint[dbg, "NDSolveSBMLModel:: solver: {options}: ", {options}];


failmsg[]:= Module[{errors, nexterror},
errors=$MessageList;
While[Length[errors]>0, 
nexterror=First[errors];
errors=Rest[errors];
Switch[ToString[nexterror],
"NDSolve::mxst", 
Print["Error: "//boldRed, "Numerical integration could not converge because the maximum number of steps were exceeded.\nTry increasing the value of the option MaxSteps in your call to SBMLNDSolve."//boldBlack],
"NDSolve::icfail",
Print["Error: "//boldRed, "Numerical integration failed. The initial conditions appear to be inconsistent with the differential and/or algebraic equations in the model. \nThis will sometimes occur if an invalid set of initial conditions are specified in the model (e.g., all values equal to zero)."//boldBlack],
"NDSolve::nderr",
Print["Error: "//boldRed,"Numerical integraton failed. \nThis message sometimes indicates a singularity in the solution (e.g., dividing by zero)."];,
"NDSolve::ndsz",
Print["Error: "//boldRed,"Numerical integraton failed. The solver could not determine a step size that would work, no matter how small it tried. This sometimes indicates that the system is stiff. \nTry looking for singularities or a wide variation in the time constants within your model; or try changing PrecisionGoal or AccuracyGoal."//boldBlack];,
_,
Print["Error:"//boldRed, "Numerical integration error: "//boldBlack, nexterror//boldBlue," (a message for this error has not been written yet: Check help > built-in-functions > Warning messages > Numerical Computation > Equation Solving > message) "//boldBlack]; 
]; 
]; 

Abort[];
];





{texit, n}=Check[
solveUntil[test,system,vars,{Global`t,tstart,tmax},options],
failmsg[],
NDSolve::stopt, NDSolve::mxst, NDSolve::icfail, NDSolve::ndsz
];

Return[ n];
]; (* end of solver *)



retry:= Block[{s},
Print["Warning: SBMLNDSolve: "//boldOrange, "Attempting Error Recovery: "//boldRed," NDSolve is unable to solve the system. Trying again with "//boldBlack,"PrecisionGoal\[Rule]Automatic, AccuracyGoal\[Rule]Automatic."//boldRed];
s=Check[solver[PrecisionGoal->Automatic,AccuracyGoal->Automatic, NDSolveOptions], giveUp];
Return[s];
];

giveUp:= Block[{},

Print["Unable to find a solution."]; Abort[];
];

debugPrint[dbg, "NDSolveSBMLModel:: Calling Check"," "];
s = Check[solver[NDSolveOptions], retry, NDSolve::nderr, NDSolve::icfail] ;

debugPrint[dbg, "NDSolveSBMLModel:: Returned from Check"," "];

p = Position[Flatten[s], addedDummyVariable]; 
If[Length[p]>0,
While[ListQ[p] \[And] Length[p]>0, p = First[p]]; 
s ={ Drop[Flatten[s], {p, p}]}; 
];


(* put variables defined by assignment rules back in *)
s=Flatten[s];
sars=(Last/@asrules)//.asrules;
sars = sars/.s;
sars=sars//.fs; (* don't forget about functions !! 2.5.13 5/4/06 *) 


(* replaced rule by interpolation 2.4.14 5/8/05 Tokyo Hackathon so its compatible with SBMLPlot, dataTable, etc. *)
(* sars = MapThread[Rule[#1,#2]&,{arvars,sars}]; *)
sars = MapThread[#1->Interpolation[{{tstart,#2},{texit,#2}}, InterpolationOrder-> 1][Global`t]&, {arvars, sars}];

(* Print["sars(2)=", sars]; 

Print[Table[#/.sars, {Global`t, tstart, texit, (texit-tstart)/5.0}]&/@arvars];
*)

s = Join[s, sars]//List; 


debugPrint[dbg, "NDSolveSBMLModel:: s",s];
debugPrint[dbg, "NDSolveSBMLModel:: sars",sars];

vars = defunctionate/@(First/@(Flatten[s]));
(* include undefined compartments in "constants" 2.7.0.5 11.29.07*)
constants=Join[(Global`SBMLConstants/.r), udcrs];
species=defunctionate/@(Global`SBMLSpecies/.r);
compartments=defunctionate/@(Global`SBMLCompartments/.r);

(* some constants may have initial assignments *)
constants = Join[rules, constants]; 


(* retrieve the compartments & species that were constant and make them "plot-a-ble" *)



compartments=Complement[compartments, vars];
species=Complement[species, vars];

If[dbg,
Print["vars=",vars];
Print["constants=",constants];
Print["compartments=",compartments];
Print["species=",species];
];


compartments=Map[
Rule[functionate[#],
Interpolation[{{tstart,#/.constants},{texit, #/.constants}}, InterpolationOrder-> 1][Global`t]
]&
,
compartments
];
s=Join[s, compartments];

species=Map[
Rule[functionate[#],
Interpolation[{{tstart,#/.constants},{texit, #/.constants}}, InterpolationOrder-> 1][Global`t]
]&
,
species
];
s=Join[s, species];

s=Flatten[s]; (* 2.6.2 *)

Return[s];
];


If[$$LoadBug, Print["Loading:getSBMLreactions"]];


getSBMLreactions[opt___]:= Module[
{dbg, ODEs, species,  parameters, r,reactions, kineticLaw,law,chead,shortdes,myShort,reactionNumbers,reactionExpression,dODEs
},

cpuSet[]; 
reactionCPUProfile={}; 
aggregatereactionCPUProfile={}; 

reactionExpression[str_]:= Module[{s},
printWarning[!(StringQ[str]), "Input to reactionExpression must be a string, not '"<>ToString[str]<>"'."];
s = "("<>str<>")";
s = StringReplace[s, "\[Rule]"-> ")\[Rule]("];
Return[ToExpression[s]];
]; (* end reactionExpression *)


dbg = $SBML$debug;

law =$SBML$KineticLaw;
shortdes = $SBML$shortenODES;
myShort[x_]:= If[shortdes, Short[x], x];

$ReactionCounter = 0;

r = Cases[$SBML$Models,XMLElement["listOfReactions",___],3]; 
r = Cases[r,XMLElement["reaction",___],3]; 

$SBML$NReactions = Length[r];
cpuReport["getReactions initialization"];

cpuSet[];
Map[getSBMLreaction,r];
cpuReport["all calls to getSBMLreaction"];

cpuSet[];

reactionNumbers=Range[$ReactionCounter];
ODEs=Apply[Join, Map[$ReactionODEs, reactionNumbers]];
species =Apply[ Join, Map[$ReactionSpecies,reactionNumbers]]//Union;
reactions =Map[$Reactions, reactionNumbers] ;
$SBML$Reactions =Map[reactionExpression,Map[Last, reactions//Flatten]];


kineticLaw = Map[$ReactionLaws,reactionNumbers]; 

cpuObserver["getSBMLreaction: reactions: joining Stuff"];

debugPrint[dbg, "getSBMLreactions:: kineticLaw: ",kineticLaw];
debugPrint[dbg, "getSBMLreactions:: ODEs: ",ODEs];
debugPrint[dbg, "getSBMLreactions:: species: ",species];debugPrint[dbg, "getSBMLreactions:: reactions: ",reactions];

(* Combine the reaction ODE terms into complete ODEs *) 
(* eliminate frozen (boundary condition) species *) 
species = Select[species,(!SBMLParameterQ[ToString[#]])& ]; 

lastest[x_]:= Map[Last,x];
ODEs=Map[Cases[ODEs, #'[Global`t]==___]&, species];

ODEs= Map[lastest,ODEs];
ODEs = Map[Apply[Plus,#]&,ODEs];
ODEs  = MapThread[#1'[Global`t]==#2&, {species,ODEs}];

cpuReport["combining reaction terms into ODE's"];

If[saveVerboseData, 
cpuSet[]; 

reactions = (reactions/.{Rule-> List});
reactions =Map[Flatten, reactions];
If[!$SBML$verboseContext,reactions = decontextify[reactions, $SBML$Context]]; 
chead = {"Name", "Reaction"};

If[$SBML$ShowReactionParameters,
chead = Append[chead,"Parameters"];
parameters=Map[$ReactionParameters, reactionNumbers];
parameters=Map[Map[ToString,#]&,parameters];
parameters=Map[MathSBML`Private`parameterate, parameters];

If[!$SBML$verboseContext,parameters = Map[decontextify, parameters]; ]; 

reactions =MapThread[Append[#1,#2]&,{reactions,parameters}];
]; 

If[law, 
chead = Append[chead,"Kinetic Law"];
If[!$SBML$verboseContext,
kineticLaw = Map[ToString[InputForm[#]]&, kineticLaw];
kineticLaw = decontextify[kineticLaw, $SBML$Context];  
]; 

reactions =MapThread[Append[#1,#2]&,{reactions,Map[myShort,kineticLaw]}];
]; 

verboseSave["Reactions",chead, reactions];

If[$SBML$verboseContext,
verboseSave["Differential Equations from Reactions", 
{"Species", "Differential Equations"}, 
Transpose[{species,Map[myShort,ODEs]}]
]; 
,
species = decontextify[Map[ToString,species]];
dODEs=Map[ToString[InputForm[#]]&, ODEs]; 
dODEs= decontextify[dODEs, $SBML$Context];
dODEs=MapThread[StringReplace[#1,"Derivative[1]["<>#2<>"]"-> #2<>"'"]& ,{dODEs,species}];  
verboseSave["Differential Equations from Reactions", 
{"Species", "Differential Equations"},
Transpose[{species,Map[myShort,dODEs]}]
]; 
cpuReport["verbose listing"]; 
];
];
$SBML$ODES = Join[$SBML$ODES, ODEs];
If[$SBML$ReportCPU,
ReactionCPUsummary[];
ReactionCPUplot[]; 
]; 
Return[];
];


combineReactions[ODEs_, species_]:= Module[{r,dbg=True, lastest},
lastest[x_]:= Map[Last,x];
debugPrint[dbg,"combineReactions:: ODEs", ODEs];
r=Map[Cases[ODEs, #'[Global`t]==___]&, species];
debugPrint[dbg,"combineReactions:: r", r];
r= Map[lastest,r];
debugPrint[dbg,"combineReactions:: r", r];
r = Map[Apply[Plus,#]&,r];
debugPrint[dbg,"combineReactions:: r", r];
r  = MapThread[#1'[Global`t]==#2&, {species,r}];
debugPrint[dbg,"combineReactions:: r", r];

Return[r];
];


reactionForm[reactants_, reactantStoichiometry_, products_, 
productStoichiometry_, reversible_:False]:= Module[{rhs,lhs,reaction, dbg=False},

debugPrint[dbg, "reactionForm: input: reactants:", reactants];
debugPrint[dbg, "reactionForm: input: reactantStoichiometry:", reactantStoichiometry];
debugPrint[dbg, "reactionForm: input: products:", products];
debugPrint[dbg, "reactionForm: input: productStoichiometry:", productStoichiometry];
debugPrint[dbg, "reactionForm: input: reversible:", reversible];

If[Length[reactants]>0,
lhs = (ToExpression/@stringer/@reactants).(ToExpression/@stringer/@reactantStoichiometry);
,
lhs =Global`\[EmptySet];
];
(*lhs = ToString[InputForm[lhs]];*)
lhs = stringer[lhs];

If[Length[products]>0,
rhs = (ToExpression/@stringer/@products).(ToExpression/@stringer/@
productStoichiometry),
rhs = Global`\[EmptySet];
];
(* rhs = ToString[InputForm[rhs]]; J*)
rhs = stringer[rhs];

reaction = If[reversible,
 lhs<>"\[RightArrowLeftArrow]"<>rhs,
 lhs<>"\[Rule]"<>rhs
];
reaction = StringReplace[reaction,{" "-> ""}];
reaction = StringReplace[reaction,{"\[Rule]"->" \[Rule]  ","*"-> "","+"-> " + ", "\[RightArrowLeftArrow]"-> " \[RightArrowLeftArrow] "}];
debugPrint[dbg, "reactionForm: return value: ", reaction];

Return[reaction];

]


getSBMLreaction[r_]:=Module[{dbg=False,
opts, reactants, products, kineticlaw,parameters,reactantStoichiometry,
productODEs,reactantODEs,  keepSpecies, ODEs,
  species, theReactionInformation, eval, unkSpecies,reactionName,last,first,pstoic,rstoic,rspecies, pspecies, reaction, localparameters,globalparameters,shadowedparameters, rateEquation, parameterNames, parameterValues, cpu0,cpu1,cpu2,cpu3,cpu4,cpu5,cpu6, cpu7, cpu8, cpu9, cpu10,undefinedLocalParameters,  getSpeciesReference, localContext,localParameterReplacementRules, variables, cpudata, rvars, pvars, cpuRecord, reversibleReaction
},
$ReactionCounter++; 
If[Mod[$ReactionCounter, 50]==0, cpuSet[]]; 

cpuRecord[n_]:=Module[{},
If[$SBML$ReportCPU, 
cpudata=Prepend[cpudata, {n, cpuGet[]} ]; 
]; 
]; 

cpuSet[]; (* initialize *) 
cpudata={}; 

last[x_]:= If[Length[x]>0,Last[x],x];
first[x_]:= If[Length[x]>0, First[x],x];

keepSpecies[{x_, n_}]:=
If[MemberQ[$SBML$FrozenVariables, x],{},{x,n}];

getSpeciesReference[x_ ] := Module[{s, info,
stoichiometries, names,uniqueNames, denominators,i,lens,
dbg=False},
debugPrint[dbg,"getSpeciesReference: input",x];


s="Indeterminate";
Switch[$SBML$Level$Version,
"1.1",
s = Cases[x,XMLElement["specieReference",___],3]; 
,
"1.2",
s = Join[
Cases[x,XMLElement["specieReference",___],3],
Cases[x,XMLElement["speciesReference",___],3]]; 
,

_,
badSBMLVersionAbort["getSBMLreaction::getSpeciesReference:"];

];

info =Map[ extractXMLOptions,s];
info = info/.{"specie"-> "species"};
debugPrint[dbg,"getSpeciesReference: info", info];

names = Map["species"/.#/.{"species"-> "Indeterminate"}&, info];
names = Map[removeUnderscore, names]; 
names = contextify[names];

names = Map[Symbol, names];

denominators = Map["denominator"/.#/.{"denominator"-> "1"}&, info];
denominators=Map[ToExpression,denominators];

stoichiometries=Map[("stoichiometry"/.#)/.{"stoichiometry"-> "1"}&, info];
stoichiometries=Map[ToExpression,stoichiometries];
printWarning[Length[denominators]!= Length[stoichiometries], "Program Bug: Incompatible lengths in denominators and stoichiometries, "<>ToString[denominators]<>ToString[stoichiometries]
];

stoichiometries = stoichiometries/denominators;

debugPrint[dbg,"getSpeciesReference: {names,stoichiometries/denominators}", {names, stoichiometries}];

uniqueNames = Complement[Union[names],{"Indeterminate"}];

  
i = Map[Flatten[Position[names,#]]&, uniqueNames];
lens = Map[Length,i]; 

MapThread[printWarning[#1>1, "Duplicate <speciesReference> tags "<>" for '"<>ToString[#2]<>"' on same side of reaction '"<>ToString[reactionName]<>"'.  Stoichiometry is set to the sum of (stoichimetry/denominator) over all the duplicate references.  "]&,
{lens,uniqueNames}];



debugPrint[dbg,"getSpeciesReference: {uniqueNames,i,lens}", {uniqueNames,i,lens}];

stoichiometries = Map[Apply[Plus,stoichiometries[[#]]]&, i];

debugPrint[dbg,"getSpeciesReference: {uniqueNames,stoichiometries}", {uniqueNames,stoichiometries}];

debugPrint[dbg,"getSpeciesReference: output", s];

Return [{uniqueNames,stoichiometries}];

];(* end getSpeciesReference*)

cpuRecord[1];

cpuSet[];
opts = extractXMLOptions[r];
reactionName = "name"/.opts/.{"name"->"UnNamedReaction$"<>ToString[$ReactionCounter]};
reactionName=removeUnderscore[reactionName]; 

reversibleReaction = ToUpperCase[ToString["reversible"/.opts/.{"reversible"-> "False"}]]; 
reversibleReaction= Switch[reversibleReaction,
"TRUE", True,"FALSE",False,_, False]; 

(* define a local context for reaction parameters *) 

If[$SBML$Context=="None" \[Or]$SBML$Context== "None`", 

localContext=$SBML$Context;
, 

localContext=$SBML$Context;
If[StringTake[$SBML$Context,-1]!= "`", localContext=localContext<>"`"]; 
localContext=localContext<>reactionName<>"`";
]; 

cpuRecord[2];
cpuSet[]; 

reactants = Cases[r,XMLElement["listOfReactants",___],3]; 
{reactants, rstoic}  = getSpeciesReference[reactants];

debugPrint[dbg,"getSBMLReaction: reactants returned from getSpeciesReference",reactants];

cpuRecord[3];
cpuSet[]; 

products = Cases[r,XMLElement["listOfProducts",___],3]; 
{products, pstoic}  = getSpeciesReference[products];

cpuRecord[4];
cpuSet[]; 

kineticLaw = Cases[r,XMLElement["kineticLaw",___],3]; 
If[Length[kineticLaw]<1, 
kineticLaw=
{XMLElement["kineticLaw",{"formula"->"Indeterminate"},{}]}
];

debugPrint[dbg,"getSBMLreaction:: kineticLaw in SBML",kineticLaw ];
parameters = Cases[kineticLaw,XMLElement["listOfParameters",___],3]; 
parameters = Cases[parameters,XMLElement["parameter",___],3]; 
parameters = Map[extractXMLOptions,parameters];

cpuRecord[5];
cpuSet[]; 

parameterNames = Map[removeUnderscore[("name"/.#)]&,parameters];

(* localParameterReplacementRules=Map[contextify, parameterNames]; *)

localParameterReplacementRules=contextify[parameterNames];
cpuRecord[5.2];
cpuSet[]; 
(* parameterNames has the form {model`reaction`k1,...} *) 
parameterNames = Map[contextify[#,localContext]&,parameterNames];

(* localParameterReplacementRules has rules of the form model`k->model`reaction`k: These rules replace the NAMES of the parameters with NAMES in a local (to the individual reaction) context. THEY DO NOT REPLACE THE VALUES!! *)

cpuRecord[5.3];
cpuSet[]; 

localParameterReplacementRules=MapThread[ToString[#1]<>"\[Rule]"<>ToString[#2]&, 
{ localParameterReplacementRules,  parameterNames}];
localParameterReplacementRules=Map[ToExpression, localParameterReplacementRules]; 

cpuRecord[5.5];
cpuSet[]; 

(* Why would this next line be necessary if $SBML$evaluateParameters is False?? *) 

(* If[\[Not]$SBML$evaluateParameters, defineParameter[parameterNames]]; *) 
defineParameter[parameterNames];

cpuRecord[6];
cpuSet[]; 

 parameterValues = Map[ fromEForm[("value"/.#/.{"value"-> $SBML$IndeterminateValue})]&,parameters];

parameterValues=makeString/@parameterValues; 


$SBML$NLocalParameters += Length[parameters];

MapThread[definef[SBMLIC,#1,#2]&, {parameterNames, parameterValues}];

cpuRecord[7];
cpuSet[]; 

(* check for undefined local parameters *) 

undefinedLocalParameters = Select[parameterNames, SBMLIC[#]==
makeString[$SBML$IndeterminateValue]&];
If[Length[undefinedLocalParameters]>0, 

SBMLUndefinedConstants = Join[SBMLUndefinedConstants, undefinedLocalParameters]; 
If[$SBML$UseDefaultParameterValue,
Map[definef[SBMLIC,#,$SBML$DefaultParameterValue]&, undefinedLocalParameters];
];
]; 

cpuRecord[8];
cpuSet[]; 

If[\[Not]$SBML$evaluateParameters, 
addReplacementRule[parameterNames]];

cpuRecord[8.2];
cpuSet[]; 


kineticLaw = Apply[extractXMLOptions,kineticLaw];

cpuRecord[8.3];
cpuSet[]; 

kineticLaw = removeUnderscore["formula"/.kineticLaw];

cpuRecord[9];
cpuSet[]; 

If[dbg,
debugPrint[dbg,"getSBMLreaction::reactionName ",reactionName]; 
debugPrint[dbg,"getSBMLreaction:: opts",opts ];
debugPrint[dbg,"getSBMLreaction:: reactants",reactants ];
debugPrint[dbg,"getSBMLreaction:: rstoic",rstoic ];

debugPrint[dbg,"getSBMLreaction:: products",products ];
debugPrint[dbg,"getSBMLreaction:: pstoic",pstoic ];


debugPrint[dbg,"getSBMLreaction:: kineticLaw",kineticLaw ];
debugPrint[dbg,"getSBMLreaction:: parameters",parameters ];
];

(* here is the big cpu hog *) 
(*
rateEquation=ToExpression[kineticLaw]/.$Species2FunctionRules;
*) 

rateEquation = translateFormula[kineticLaw];

cpuRecord[10];
cpuSet[]; 

rateEquation = ToExpression[rateEquation]/.localParameterReplacementRules;

cpuRecord[10.5];
cpuSet[]; 

If[$SBML$evaluateParameters, 
rateEquation =evaluateConstantValues[rateEquation];
]; 

cpuRecord[11];
cpuSet[]; 

debugPrint[dbg,"getSBMLreaction:: rateEquation(3)",rateEquation ];

cpu5=TimeUsed[];

variables = {products, pstoic}//Transpose;
(*variables = Select[variables,!(MemberQ[$SBML$FrozenVariables,#[[1]]])&]; *)
variables = Select[variables,!(SBMLParameterQ[ToString[#[[1]]]])&];

If[Length[variables]>0, variables=Transpose[variables]]; 

cpuRecord[12];
cpuSet[]; 

productODEs=If[
Length[pstoic]>0,
 MapThread[(#1'[Global`t]==#2*(rateEquation))&, variables] , {}];

variables =  {reactants,rstoic}//Transpose;
(* variables = Select[variables,!(MemberQ[$SBML$FrozenVariables,#[[1]]])&]; *)
variables = Select[variables,!(SBMLParameterQ[ToString[#[[1]]]])&];

If[Length[variables]>0, variables=Transpose[variables]]; 

reactantODEs=If[
Length[rstoic]>0, 
MapThread[(#1'[Global`t]==(-1)*#2*(rateEquation))&,variables] , {}];
ODEs = Join[reactantODEs, productODEs];

cpuRecord[13];
cpuSet[]; 

(* species =Complement[ Union[Join[reactants, products]],$SBML$FrozenVariables]; *) 

species =Union[Join[reactants, products]]; 
species = Select[species, (\[Not]SBMLParameterQ[#])&]; 


cpuRecord[14];
cpuSet[]; 

If[$SBML$evaluateParameters, 
printWarning[MemberQ[{rateEquation},Infinity]\[Or] MemberQ[{rateEquation},ComplexInfinity] \[Or] MemberQ[{rateEquation},Indeterminate],
"Indeterminate form (0/0, 1/0, Infinity) occurs in reaction '"<>reactionName<>"'; unexpected results could occur. This model should be read with evaluateParameters\[Rule]False. " 
];

]; 

cpuRecord[15];
cpuSet[]; 

reaction = reactionForm[reactants, rstoic,products,pstoic,reversibleReaction];

reaction = {reactionName-> reaction};

cpuRecord[16];
cpuSet[]; 

$ReactionODEs[$ReactionCounter]=ODEs;
$ReactionSpecies[$ReactionCounter]=species;
$ReactionParameters[$ReactionCounter]= parameterNames//ToExpression;
$Reactions[$ReactionCounter]=reaction;
$ReactionLaws[$ReactionCounter]=rateEquation; 

cpuRecord[17];

If[$SBML$ReportCPU,

cpudata = Transpose[Reverse[cpudata]]; 
If[Length[reactionCPUProfile]<1,
reactionCPUProfile = cpudata;
aggregatereactionCPUProfile = cpudata;
,
aggregatereactionCPUProfile = Append[aggregatereactionCPUProfile, 
Last[cpudata] + Last[aggregatereactionCPUProfile]
];
reactionCPUProfile = Append[reactionCPUProfile, Last[cpudata]]; 
]; 

(* Print[">>>getReaction ("<>ToString[$ReactionCounter]<>")\n",
TableForm[cpudata]];
*)
]; 

If[Mod[$ReactionCounter, 50]==0,
cpuReport[" reaction "<>ToString[$ReactionCounter]<>", name = "<>reactionName];
]; 
];


ReactionCPUsummary[]:= Module[{r,h},
r=MathSBML`Private`reactionCPUProfile;
h = First[r];
r = Rest[r];
r = Transpose[r];
r = Map[Apply[Plus,#]&, r];
r={h,r};
Print[TableForm[r]]
];


ReactionCPUplot[]:= Module[{r,h,p},
r=MathSBML`Private`reactionCPUProfile;
h = First[r];
r = Rest[r];
r = Transpose[r];
p=MapThread[ListPlot[#1,PlotLabel-> #2,DisplayFunction-> Identity]&, {r,h}];
p = Partition[p, 5,5,{1,1},{}];
Show[GraphicsArray[p]];


r=MathSBML`Private`aggregatereactionCPUProfile;
h = First[r];
r = Rest[r];
r = Transpose[r];
p=MapThread[ListPlot[#1,PlotLabel-> #2,DisplayFunction-> Identity,PlotJoined-> True]&, {r,h}];
p = Partition[p, 5,5,{1,1},{}];
Show[GraphicsArray[p]];

]


badSBMLVersionAbort[msg_]:= Module[{},
Print[msg, " Unknown or unsupported SBML Version: ",$SBML$Level$Version];Abort[];
];


getSBMLparameters[opt___]:= Module[
{dbg,p,names,values, units,undefinedParameters,unitsNotOK,derivedUnits,tbl
},

dbg=$SBML$debug;

p = Cases[$SBML$Models,XMLElement["listOfParameters",___],3]; 
p = Cases[p,XMLElement["parameter",___],3]; 

p = Map[extractXMLOptions,p]; 
debugPrint[dbg, "getSBMLparameters:: p:: ",p];

names = Map["name"/.#&, p];


debugPrint[dbg,"getSBMLparameters:: names:: ",names];

values = Map[getAttributeValue["name",#,"value",p]&,names];
values = (values/.{"value"-> $SBML$IndeterminateValue });

debugPrint[dbg,"getSBMLparameters:: values:: ",values];

units = Map[getAttributeValue["name",#,"units",p]&,names];
units = (units/.{"units"-> $SBML$IndeterminateValue});
units=unitsContextify/@units;

debugPrint[dbg,"getSBMLparameters:: units:: ",units];

unitsNotOK = Select[units,(!unitDefinedQ[#])&]; 
If[Length[unitsNotOK]>0,Print["Warning: "//boldOrange,
"Invalid units specified in <parameter> definition: "//boldBlack,
list2CommaSeparatedString[unitsNotOK]//boldRed
];
]; 

$SBML$NLocalParameters =0;
$SBML$NGlobalParameters = Length[names];
SBMLGlobalParameters=names;

values = Map[fromEForm, values];
names=Map[contextify[removeUnderscore[#]]&,names];
defineParameter[names];

If[saveVerboseData,
derivedUnits=units/.$SBML$UnitRules;
If[$SBML$verboseContext, 
tbl =Transpose[{names, values, units ,derivedUnits}], tbl =Transpose[{names//decontextify, values, units ,derivedUnits}]
]; 

verboseSave["Global Parameters", 
{"Name","Value", "Units","Derived Units"}, 
tbl
]; 

];

debugPrint[dbg,"getSBMLparameters:: names:: ",names];
debugPrint[dbg,"getSBMLparameters:: values:: ",values];

(* 2.7.0.3 - added InputForm so that this works with e format also *)

MapThread[definef[SBMLIC,#1,#2]&, {names, Map[ToString[InputForm[#]]&,values]}];

(* check for missing values *)

SBMLUndefinedConstants = Select[SBMLConstants, SBMLIC[#]==ToString[$SBML$IndeterminateValue]&];
If[Length[SBMLUndefinedConstants]>0, 
If[$SBML$UseDefaultParameterValue,
Map[definef[SBMLIC,#,$SBML$DefaultParameterValue]&, SBMLUndefinedConstants];
];
]; 

Map[addReplacementRule,names]; 
debugPrint[dbg,"getSBMLparameters:: SBMLReplacementRules:: ",SBMLReplacementRules];

names = Map[ToExpression,names];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[ToExpression[#1]-> ToExpression[#2]&, {names,units}]];


Return[];
];


getSBMLrules[opt___]:= Module[{
dbg=False,ruletable,r,interpretRule,
getRuleEquation, addODE
},
r = Cases[$SBML$Models,XMLElement["listOfRules",___],3]; 
debugPrint[dbg,"getSBMLrules: r(1)",r];
$SBML$Algebraic$Rules={};


addODE[ODE_?StringQ]:= Module[{},
$SBML$ODES=Append[$SBML$ODES,ToExpression[ODE]];
];
addODE[x___]:= printWarning["addODE: program Error: argument must be a string: \""<>ToString[x]<>"\""];

getRuleEquation[name_, opts_]:= Module[{v,rhs,ruletype,lhs,eqn},



v=name/.opts/.{name-> "Indeterminate"};
v= removeUnderscore[v]; 
v=contextify[v];
rhs = "formula"/.opts/.{"formula"-> "Indeterminate"};
rhs = removeUnderscore[rhs];

rhs = translateFormula[rhs];
rhs = evaluateReplacementRules[rhs];
ruletype="type"/.opts/.{"type"-> "scalar"};

debugPrint[dbg,"getRuleEquation: v:", v]; 
debugPrint[dbg,"getRuleEquation: ruletype:", ruletype]; 

If[ruletype=="rate",
If[SBMLParameterQ[v], removeReplacementRule[v]];
defineVariable[v];
lhs=functionate[v<>"'"];
eqn = lhs<>"=="<>rhs;
addODE[eqn];
,
(* otherwise assume a "scalar" *) 
printWarning[ruletype!= "scalar","invalid rule type =\""<>ToString[ruletype]<>"\" treated as \"scalar\"."];
defineParameter[v];
SBMLIC[v]=rhs;
addReplacementRule[v]; 
lhs = v;
eqn = lhs<>"\[Rule]"<> rhs;

debugPrint[dbg,"getRuleEquation: SBMLReplacementRules:", SBMLReplacementRules]; 
];
Return[{v,eqn}];
]; (* end of getRuleEquation *) 

interpretRule["parameterRule"-> opts_]:= Module[{v,eqn},
{v,eqn}=getRuleEquation["name",opts];

Return[{v,"parameterRule",eqn}];
];
interpretRule["specieConcentrationRule"-> opts_]:= Module[{v, eqn},
{v,eqn}=getRuleEquation["specie",opts];

Return[{v,"specieConcentrationRule",eqn}];
];
interpretRule["speciesConcentrationRule"-> opts_]:= Module[{v,eqn},
{v,eqn}=getRuleEquation["species",opts];

Return[{v,"speciesConcentrationRule",eqn}];
];

interpretRule["compartmentVolumeRule"-> opts_]:= Module[{v,eqn},
{v,eqn}=getRuleEquation["compartment",opts];

Return[{v,"compartmentVolumeRule",eqn}];
];

interpretRule["algebraicRule"-> opts_]:= Module[{eqn},
eqn = "formula"/.opts/.{"formula"-> "Indeterminate"};
eqn = removeUnderscore[eqn];
eqn ="0=="<>translateFormula[eqn];
$SBML$Algebraic$Rules = Append[$SBML$Algebraic$Rules,ToExpression[eqn]];
Return[{"** None **", "algebraicRule",eqn}];
];

interpretRule[unknown___]:=Module[{},printWarning["interpretRule: programError: unknown or invalid rule format "<>ToString[unknown]];
Return[{"Indeterminate","Indeterminate","Indeterminate"}];];

If[Length[r]>0, 

(* check for multiple sets of rules *) 
If[
Length[r]>1,printWarning[ "getSBMLrules: Only one listOfRules tag is permitted; "<>ToString[Length[r]]<>" sets were found. Additional sets ignored."];
];

(* processs the first or only set of rules *) 
r= First[r];
debugPrint[dbg,"getSBMLrules: r(1.5)",r];
r=extractXMLSubElements[r];
debugPrint[dbg,"getSBMLrules: r(2)",r];

r=Map[getXMLElement,r];
debugPrint[dbg,"getSBMLrules: r(3)",r];

r  = Map[interpretRule,r];
debugPrint[dbg,"getSBMLrules: r(4)",r];
$SBML$NRules = Length[r];
,
$SBML$NRules = 0;
];


debugPrint[dbg, "getSBMLrules: SBMLReplacementRules",SBMLReplacementRules]; 
If[saveVerboseData,
If[!$SBML$verboseContext,
If[Length[r]>0, r = Transpose[r]; 
r = ReplacePart[r,decontextify[r[[1]]] ,1];
r = ReplacePart[r, decontextify[r[[3]], $SBML$Context], 3]; 
r = Transpose[r]; 
]; 
]; 

verboseSave["Rules",{"Variable", "Type of Rule in SBML","Mathematica Translation"}, r];
]; 

];


getSBMLspecies[opt___]:= Module[{dbg,
 species,speciesoptions,speciesNames,speciesIC, speciesICRules, speciesCompartment, compartments,unknownCompartments,  speciesBC, variables, variableic, frozenIC, speciesunits,speciescharge,rr,derivedunits,unitsNotOK, BCorNot
},

dbg = $SBML$debug;

species = Cases[$SBML$Models,XMLElement["listOfSpecies",___],3]; 

(* get each species *) 

Switch[$SBML$Level$Version,
(* 1.1 only allows <specie ...> tags *) 
"1.1",
species = Cases[species,XMLElement["specie",___],3]; 
,

(* 1.2 allows <specie ...> or <specie ...> tags *) 
"1.2",
species = Join[
Cases[species,XMLElement["specie",___],3],Cases[species,XMLElement["species",___],3]
];
,
_,
printWarning["getSBMLspecies:: unknown $SBML$Level$Version: "<>ToString[$SBML$Level$Version]];
];
speciesoptions=Map[extractXMLOptions,species];
speciesNames=Map["name"/.#&,speciesoptions];
speciesIC=Map["initialAmount"/.#/.{"initialAmount"-> $SBML$IndeterminateValue}&,speciesoptions];
speciesIC= Map[fromEForm, speciesIC];

(* just in case some loser names his/her compartments "compartment" *)
 
rr= {("compartment"-> "compartment")-> ("compartment"-> "\[RightPointer]compartment\[LeftPointer]holder")};

speciesCompartment=Map["compartment"/.#/.{"compartment"->$SBML$IndeterminateValue}&,
speciesoptions/.rr];


speciesCompartment = speciesCompartment/.{"\[RightPointer]compartment\[LeftPointer]holder"-> "compartment"};

speciesCompartment=Map[removeUnderscore, speciesCompartment];
speciesCompartment = Map[contextify, speciesCompartment];

speciesunits = Map["units"/.#&,speciesoptions];
speciesunits = speciesunits/.{"units"-> "substance"};
speciesunits = unitsContextify/@speciesunits;

unitsNotOK = Select[speciesunits,(!unitDefinedQ[#])&]; 
printWarning[Length[unitsNotOK]>0,
"Invalid units specified in <species> definition: "<>
list2CommaSeparatedString[unitsNotOK]
];

speciescharge = Map["charge"/.#&, speciesoptions];
speciescharge = (speciescharge/.{"charge"-> "0"});


speciesBC:=Map[(("boundaryCondition"/.#)/.{"boundaryCondition"-> "False"})&,speciesoptions];
BCorNot = Map[If[#=="true","Bound. Cond.", "Variable"]&, speciesBC];


speciesNames=Map[contextify[
removeUnderscore[#]]&,speciesNames];
defineVariable[speciesNames];

speciesNames=Map[Symbol,speciesNames];

speciesICRules=MapThread[#1-> ToExpression[#2]&,{speciesNames,speciesIC}];


debugPrint[dbg, "getSBMLspecies:: speciesCompartment", speciesCompartment];
debugPrint[dbg, "getSBMLspecies:: speciesICRules",speciesICRules];
debugPrint[dbg, "getSBMLspecies:: speciesBC", speciesBC];
debugPrint[dbg,"getSBMLspecies:: speciesNames",speciesNames];

(* 2.7.0.3 - recover species names for output of SBMLSpecies *)
$SBML$Species$IDs = speciesNames;

$SBML$SpeciesCompartmentAssociations=MapThread[Rule,{speciesNames,ToExpression/@speciesCompartment}];

compartments = Union[speciesCompartment];
unknownCompartments=Complement[compartments,$SBML$CompartmentNames];

printWarning[Length[unknownCompartments]>0,
"Unknown compartments specified in specie definition: "<>list2CommaSeparatedString[unknownCompartments]
];

If[saveVerboseData,

derivedunits = speciesunits/.$SBML$UnitRules;
If[$SBML$verboseContext,

verboseSave["Species",
 {"Name","I.C.","Units", "Derived Units", "Charge", "Compartment","Var/B.C."},Transpose[{speciesNames, speciesIC,speciesunits,derivedunits, speciescharge,speciesCompartment,BCorNot}]
];

,

verboseSave["Species", 
{"Name","I.C.","Units", "Derived Units", "Charge", "Compartment","Var/B.C."},
Transpose[{Map[ToString,speciesNames]//decontextify, speciesIC,speciesunits,derivedunits, speciescharge,speciesCompartment//decontextify,BCorNot}]
];
]; 
]; 
speciesoptions=MapThread[{"name"-> #1, "boundaryCondition"-> #2}&,
{speciesNames,speciesBC}];

$SBML$FrozenVariables=getAttributeValues["boundaryCondition","true","name",speciesoptions];

defineParameter[Map[ToString,$SBML$FrozenVariables]];
MapThread[definef[SBMLIC,ToString[#1],ToString[InputForm[#2]]]&, {speciesNames, speciesIC}];

addReplacementRule[Map[ToString,$SBML$FrozenVariables]];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[ToExpression[#1]-> ToExpression[#2]&, {speciesNames,speciesunits}]];


Return[];
];


getSBMLcompartments[opt___?OptionQ]:= Module[{m, c,cc,names,volumes, units,derivedunits, outsides, outside,notok,dbg, unitsNotOK ,defaultAttributes={"volume"-> "1", "units"-> "volume"}},
dbg = $SBML$debug;

m = $SBML$Models; 

c = Cases[$SBML$Models,XMLElement["listOfCompartments",___],3]; 

cc= Cases[c,XMLElement["compartment",___],3]; 
If[Length[c]<1  \[Or] Length[cc]<1,
Switch[$SBML$Level$Version ,
"1.1",printWarning["SBML level 1.1 must contain at least one compartment"];Abort[];
,
"1.2",
names = {ToString[$SBML$IndeterminateValue ]};
volumes={"1"};
units = {"volume"};
outsides={ ToString[$SBML$IndeterminateValue ]};
,
_,printWarning["SBML level"<>ToString[$SBML$Level$Version]<>"must contain at least one compartment"];Abort[];
];

(* this is the else clause, i.e, Length[c]>= 1 *) 
,

c = cc;
c = Map[extractXMLOptions, c];

(* get names and check outsides for consistency *) 

names = Map["name"/.#&,c];
outsides = Map["outside"/.#&,c];
outside = outsides; 
outsides = Complement[outsides, {"outside"}]; 

(* check names of outside compartments *) 
notok=Complement[outsides,names];
printWarning[Length[notok]>0, 
"Unknown outside compartment "<>list2CommaSeparatedString[notok]
];

(* convert names and outside names to mathematica names *) 

names = Map[removeUnderscore, names];
outsides = Map[removeUnderscore, outside/.{"outside"-> ToString[$SBML$IndeterminateValue (* $Universal$OutsideCompartment*) ] }];

names = contextify[names];
outsides = Map[If[ToString[#]!= ToString[$SBML$IndeterminateValue], contextify[#], #]&, outsides];

defineParameter[names];
defineParameter[Complement[outsides, {ToString[$SBML$IndeterminateValue]}]];

(* get volumes and units *) 
volumes = Map["volume"/.#/.{"volume"-> 1} &, c];

(* volumes= Map[fromEForm, volumes];
debugPrint[dbg,"getSBMLcompartments:: volumes",volumes];
volumes = Map[ToString,volumes];
*) 
volumes = fromEForm/@volumes;

debugPrint[dbg,"getSBMLcompartments:: volumes",volumes];

units = Map["units"/.#/.{"units"-> "volume"}&,c];
units = unitsContextify/@units;


unitsNotOK = Select[units,(!unitDefinedQ[#])&]; 
printWarning[Length[unitsNotOK]>0,
"Invalid units specified in <compartment> definition: "<>
list2CommaSeparatedString[unitsNotOK]
];

$SBML$UnitAssociations=Join[$SBML$UnitAssociations,MapThread[ToExpression[#1]-> ToExpression[#2]&, {names,units}]];

]; (* end of if Length[c]<1 ...*) 

(* save globals *) 
$SBML$CompartmentNames=names; 
$SBML$CompartmentVolumes=MapThread[Symbol[#1]-> ToExpression[#2]&,{names,volumes}]; 
$SBML$CompartmentUnits=units; 
$SBML$CompartmentOutsides=outsides;

debugPrint[dbg,"getSBMLcompartments:: $SBML$CompartmentNames",$SBML$CompartmentNames];
debugPrint[dbg,"getSBMLcompartments:: $SBML$CompartmentVolumes",$SBML$CompartmentVolumes];


c=MapThread[
{"name"-> #1, "volume"-> #2, "units"-> #3, "outside"-> #4}&,
{names, volumes, units, outsides}
];
$SBML$NCompartments = Length[c];
debugPrint[dbg,"getSBMLcompartments:: c",c];


If[saveVerboseData,
derivedunits=units/.$SBML$UnitRules;
If[$SBML$verboseContext,
verboseSave["Compartments",
{"Name","Volume","Units","Derived Units", "Outside"},
Transpose[{names,volumes,units,derivedunits,outsides}]
];

,
verboseSave[ "Compartments",
 {"Name","Volume","Units","Derived Units", "Outside"},
Transpose[{decontextify[names],volumes,units,derivedunits,decontextify[outsides]}]];
];
]; 

MapThread[definef[SBMLIC,#1,#2]&, {names,ToString/@InputForm/@volumes}];


Map[addReplacementRule, names];
If[dbg, Print["getSBMLcompartments - done"]]; 

Return[];
];



removeVariable[z_]:= Module[{p},

SBMLVariables=Complement[SBMLVariables,{z}];
SBMLVariableQ[z]=False;
(* Print[z, " no longer a variable"]; *) 
]; (* end removeVariable *) 


defineParameter[x_?StringQ]:= Module[{},
If[SBMLVariableQ[x], removeVariable[x]]; 
SBMLParameterQ[x]=True; 
SBMLVariableQ[x]=False;
SBMLConstants=Append[SBMLConstants,x]; 
];
defineParameter[x_?ListQ]:= Map[defineParameter,x];
defineParameter[x_]:= Module[{},
printWarning["defineParameter: program error: argument not a String or List: "<>ToString[x]];
];


defineVariable[x_?StringQ]:= Module[{removeConstant, dbg=False},
removeConstant[z_]:= Module[{p},
p=Position[SBMLConstants, z];
While[Length[p]>0,
p = Map[First,p];
p =First[p]; 
SBMLConstants= Drop[SBMLConstants, {p}];
p=Position[SBMLConstants, z];
];
]; (* end removeConstant *) 


If[dbg, Print["defineVariable: x: ", x]]; 
If[stringer[decontextify[x]]=="t", Return[]]; 

If[SBMLVariableQ[x], Return[]]; (* already a variable *) 

(* SBMLConstants = Complement[SBMLConstants,{x}]; *) 
If[SBMLparameterQ[x], removeConstant[x]]; 

SBMLParameterQ[x]=False; 
SBMLVariableQ[x]=True;
SBMLVariables = Append[SBMLVariables, x];
(* Print[x, " added as a variable"]; *)
];

defineVariable[x_?ListQ]:= Map[defineVariable,x];
defineVariable[x_]:= Module[{},
printWarning["defineVariable: program error: argument not a String or List: "<>ToString[x]];
];


getSBMLunits[opt___?OptionQ]:= Module[{
c,cc,dbg=False,defaultUnitsNeeded,defaultUnitRules,
defaultSpecTable5={"substance"-> "mole","volume"-> "liter", "time"-> "second"}, 
specTable5, 
defaultbuiltInQuantities={"substance","volume","time"},
builtInQuantities,
getSBMLUnitDefinition,
unitDefinitions,names,defs,
defaultAllowedKinds={"ampere","becquerel","candela","celsius","coulomb","dimensionless","farad","gram","gray","henry","hertz","item","joule","katal","kelvin","kilogram","liter","litre","lumen","lux","meter","metre","mole","newton","ohm","pascal","radian","second","siemens","sievert","steradian","tesla","volt","watt","weber"},
allowedKinds
},

allowedKinds = unitsContextify/@defaultAllowedKinds;
builtInQuantities=unitsContextify/@defaultbuiltInQuantities;
specTable5 = Map[unitsContextify[#[[1]]]-> unitsContextify[#[[2]]]&, defaultSpecTable5]; 
debugPrint[dbg, "getSBMLunits: specTable5 ",specTable5];


getSBMLUnitDefinition[z_]:= Module[{opts,units,listofunits,name, unitspecs,kinds,exponents, scales,disallowedKinds,unitdef,unitdefinition,dbg=True},

unitdef[{kind_, exp_, scale_}]:=
ToExpression["10^"<>ToString[scale]<>"*("<>ToString[kind]<>")^"<>ToString[exp]];

opts = extractXMLOptions[z];
name = "name"/.Flatten[{opts}]/.{"name"-> "Indeterminate"};
name = unitsContextify[name]; 
debugPrint[dbg, "getSBMLUnitDefinition: input ",z];
debugPrint[dbg, "getSBMLUnitDefinition: opts ",opts];

listofunits = Cases[z,XMLElement["listOfUnits",___],3]; 
debugPrint[dbg, "getSBMLUnitDefinition: listofunits ",listofunits];

If[Length[listofunits]>0,
units =Cases[listofunits,XMLElement["unit",___],3];
debugPrint[dbg, "getSBMLUnitDefinition: units ",units];

If[Length[units]>0, 
unitOptions = Map[extractXMLOptions,units];

unitspecs = Map[{"kind","exponent","scale"}/.#/.{"kind"-> "Indeterminate","exponent"-> "1", "scale"-> "0"}&, unitOptions]//ToLowerCase;
{kinds,exponents,scales}=Transpose[unitspecs];
kinds = unitsContextify/@kinds;
unitspecs = Transpose[{kinds, exponents,scales}]; 

disallowedKinds=Complement[kinds,allowedKinds];

printWarning[Length[disallowedKinds]>0,
"Invalid Kinds :"<>list2CommaSeparatedString[disallowedKinds]<>" in unitDefinition for '"<>ToString[name]<>"'."];
,
unitOptions={};
kinds={ToString[name]/.specTable5/.{ToString[name]-> "Indeterminate"}};
exponents={"1"};
scales={"0"};
unitspecs = Transpose[{kinds,exponents,scales}];
printWarning["no <unit> tags given in unitDefinition for '"<>ToString[name]<>"'."];
];
debugPrint[dbg, "getSBMLUnitDefinition: unitspecs ",unitspecs];
debugPrint[dbg, "getSBMLUnitDefinition: unitOptions ",unitOptions];
debugPrint[dbg, "getSBMLUnitDefinition: kinds ",kinds];


unitdefinition=Apply[Times,Map[unitdef,unitspecs]]//InputForm//ToString;
debugPrint[dbg, "getSBMLUnitDefinition: unitdefinition ",unitdefinition];

,

printWarning["No listOfUnits given in the unitDefinition for '"<>ToString[name]<>"'."];
unitdefinition="Indeterminate";
]; 

Return[{name,unitdefinition}];
]; (* end getSBMLUnitDefinition *)


$SBML$UnitsDefined =allowedKinds;
debugPrint[dbg, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];

c = Cases[$SBML$Models,XMLElement["listOfUnitDefinitions",___],3]; 
cc= Cases[c,XMLElement["unitDefinition",___],3]; 

debugPrint[dbg, "getSBMLunits: listOfUnitDefinitions: ",c];
debugPrint[dbg, "getSBMLunits: unitDefition's: ",cc];

unitDefinitions=Map[getSBMLUnitDefinition,cc];
debugPrint[dbg, "getSBMLunits: unitDefinitions ",unitDefinitions];

If[Length[unitDefinitions]>0, {names, defs} = Transpose[unitDefinitions];
$SBML$UnitsDefined = Join[$SBML$UnitsDefined, names]//Union;
debugPrint[dbg, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];

$SBML$UnitRules=MapThread[#1->#2&,{names,defs}];

(* remove indeterminate rules *) 

$SBML$UnitRules = Select[$SBML$UnitRules,Last[#]!= "Indeterminate"&]; 
debugPrint[dbg, "getSBMLunits: $SBML$UnitRules ",$SBML$UnitRules];

defaultUnitsNeeded = Complement[builtInQuantities,names];
debugPrint[dbg, "getSBMLunits: defaultUnitsNeeded ",defaultUnitsNeeded];


defaultUnitRules=Map[#-> (#/.specTable5)&,defaultUnitsNeeded];
debugPrint[dbg, "getSBMLunits: defaultUnitRules ",defaultUnitRules];

debugPrint[dbg,"getSBMLUnits: defaultUnitRules ",defaultUnitRules];
$SBML$UnitRules=Join[$SBML$UnitRules, defaultUnitRules];

,
$SBML$UnitRules= specTable5;
];
$SBML$UnitsDefined=Join[$SBML$UnitsDefined,builtInQuantities]//Union;

debugPrint[dbg, "getSBMLunits: $SBML$UnitsDefined ",$SBML$UnitsDefined];
debugPrint[dbg, "getSBMLunits: $SBML$UnitRules ",$SBML$UnitRules];

If[saveVerboseData,
verboseSave["Unit Definitions",{"Name", "Formula"}, unitDefinitions];
];

Return[];
];


unitDefinedQ[x_]:= (x==  "Indeterminate") \[Or] (MemberQ[$SBML$UnitsDefined, x]);


extractXMLOptions[
XMLElement[x_, optionList_, stuff___]]:= Module[{}, Return[optionList]];


extractXMLSubElements[XMLElement[_, {___}, x_]]:=x;


getXMLElement[XMLElement[name_, {opt___},x_]]:= (name->{opt});


extractSBMLtag[xml_, tag_, level_:Infinity]:= 
Cases[xml,XMLElement[ToString[tag],___],level];


contextify[x_?StringQ,context_:""]:=Module[{s,c},
If[x=="" \[Or] x=="Indeterminate", Return[x]];

(* reversed the following two lines in 2.7.0.2 10-15-07 *)
(* and add check for ValueQ of $SBML$Context *)
(* possible for external program to set $SBML$Context to a non-string! *)

c=context;
If[c=="", 
If[ValueQ[$SBML$Context],
c=$SBML$Context,
Print["Warning:"//boldRed, " contextify: "//boldBlue, " $SBML$Context has not been initialized. x = "//boldBlack, x//boldBlue]; 
c="None"
]
];
c = ToString[c];

If[c=="None" \[Or] c=="None`", Return[x]]; 
If[StringTake[c,-1]!= "`", 
s=c<>"`"<>x,
s=c<>x;
];
Return[s];
];
contextify[x_-> y_, context_:""]:= (contextify[x,context]-> contextify[y,context]);

contextify[x_?ListQ,context_:""]:= Map[contextify[#,context]&, x];
contextify[x_[y___],context_:""]:= contextify[x,context][y];
contextify[x_, context_:""]:= Module[{},
If[ToString[Head[x]]=="Symbol",
contextify[ToString[x],context]//ToExpression//Return;
];
Print["Error: "//boldRed, "contextify: "//boldBlue, "The argument to contextify must be a string or a symbol; argument used: "//boldBlack, x//boldRed];
Return[x];
] ;

unitsContextify[x_]:= contextify[x, $SBML$UnitsContext]; 


decontextify::usage="decontextify[x] returns the symbol or string x representing a symbol with all context references removed.\ndecontextify[{x1,x2,...}] applies decontextify to each of x1, x2, .. and returns a list with the context removed from  each symbol or string. ";
decontextify[x_?StringQ]:= Module[{p,q},
p = StringPosition[x,"`"];
If[Length[p]<1, Return[x]];
p=Map[First,p];
p = Last[p];
q= StringDrop[x,p];
Return[q];
];
decontextify[x_?ListQ]:= Map[decontextify,x];
decontextify[x_]:= Module[{s},
decontextify[ToString[InputForm[x]]]//ToExpression//Return;
(* mod 7/29/03 *) 
(*
If[ToString[Head[x]]=="Symbol",decontextify[ToString[x]]//ToExpression//Return];
 printWarning["The argument to decontextify must be a string, symbol, or list thereof: "<>ToString[InputForm[x]]];
Return[x];
*) 
];

decontextify[x_?StringQ, context_?StringQ]:= StringReplace[x, {context-> ""}]; 
decontextify[x_?ListQ, context_?StringQ]:= Map[decontextify[#,context]&,x]; 
decontextify[x_, context_?StringQ]:= Module[{},
decontextify[ToString[InputForm[x]],context]//ToExpression//Return;
(* mod 7/29/03 *) 
(*
If[ToString[Head[x]]=="Symbol",decontextify[ToString[x],context]//ToExpression//Return];
printWarning["The argument to decontextify must be a string, symbol, or list thereof: "<>ToString[InputForm[x]]];
Return[x];
*) ]; 

unitsDecontextify[x_]:= decontextify[x, $SBML$UnitsContext]; 



functionate[f_?StringQ, arg_:"t"]:=Module[{tvariable},
tvariable = ToString[arg];
Return[f<>"["<>tvariable<>"]"];
];
functionate[f_?ListQ,arg_:"t"]:= Map[functionate[#,arg]&, f];

 functionate[f_, arg_:"t"]:= Module[{g},
(* If[ToString[Head[f]]=="Symbol", *)
g=functionate[ToString[f], ToString[arg]];
Return[ToExpression[g]];
(* ];
 Print["Warning: "//boldRed, "functionate: "//boldBlack, " input must be a string or symbol. Actual input: "//boldBlack, f//boldBlue, " Notify developer of possible program bug."//boldRed]; 
Return[f]; *)
];



defunctionate[f_[t_]]:=f;
defunctionate[f_?StringQ]:=StringReplace[f, "["~~___~~"]"-> ""];
defunctionate[f_]:=f;

functionize[f_?StringQ]:= functionize[f, "t"];
functionize[f_?StringQ, arg_?StringQ]:= f<>"\[LeftDoubleBracket]"<>arg<>"\[RightDoubleBracket]"; 
defunctionize[f_?StringQ]:= StringReplace[f, {"\[LeftDoubleBracket]"-> "[", "\[RightDoubleBracket]"-> "]"}];


initialize[x_?StringQ]:=functionate[x,"0"]<>"=="<> SBMLIC[x];
initialize[x_?ListQ]:= Map[initialize,x];
initialize[x___]:= printWarning["initialize:: program error: argument must be string or list of strings: \""<>ToString[x]<>"\""];


parameterate[x_?StringQ]:= x<>"\[Rule]"<>SBMLIC[x]; 
parameterate[x_?ListQ]:= Map[parameterate, x];
parameterate[x___]:= printWarning["parameterate:: program error: argument must be string or list of strings: \""<>ToString[x]<>"\""];


differentize[f_, arg_:"t"]:= Module[{g},
g= StringReplace[functionate[stringer[f], arg], "["-> "'["]; 
If[StringQ[f], Return[g]];
Return[ToExpression[g]]; 
]; 


addReplacementRule[x_?StringQ]:= Module[{newrule},
(* if its there, remove old rule *) 

removeReplacementRule[x]; 

(* don't create a replacement rule unless there is something to replace - don't add rules of the form x->Indeterminate *) 
(* Print["x=",x," ic=", SBMLIC[x]]; *) 
If[SBMLIC[x]!= ToString[$SBML$IndeterminateValue], 
newrule =parameterate[x];
SBMLReplacementRules=Append[SBMLReplacementRules, ToExpression[newrule]];
(* Print["replacement rule: ",newrule]; *) 
(* Print[newrule," added."]; *) 
];
];
addReplacementRule[x_?ListQ]:= Map[addReplacementRule,x];

addReplacementRule[x___]:= printWarning["addReplacementRule: program error: argument must be a string: \""<>ToString[InputForm[x]]<>"\""];

addLocalReplacementRule[x_?StringQ]:= Module[{newrule},
newrule =parameterate[x];
SBMLReplacementRules=Append[SBMLReplacementRules, ToExpression[newrule]];
];
addLocalReplacementRule[x___]:= printWarning["addLocalReplacementRule: program error: argument must be a string: \""<>x<>"\""];

removeReplacementRule[y_?StringQ]:= Module[{p,x},
(* following line added 7-28-03; previously, x was argument; but SBMLReplacementRules are all expressions and not strings*) 
x= ToExpression[y];
(* inefficient but elegant algorithm *) 
(* SBMLReplacementRules=Select[SBMLReplacementRules,(ToString[First[#]]!= x)&]; *) 

(* inelegant but optimized algorithm *) 
(* while loop is used because there may be more than one rule! *) 
p=Position[First/@SBMLReplacementRules,x];
(* Print["removeReplacementRule before:",y,",",SBMLReplacementRules,",",p]; *) 
While[Length[p]>0,
p=Map[First,p];
p = First[p]; 
(* following line changed 7-28-03 from Drop[r,{p}]; r is undefined ??!? *)
SBMLReplacementRules=Drop[SBMLReplacementRules,{p}];
p=Position[First/@SBMLReplacementRules,x];
];
(* Print["removeReplacementRule after:",SBMLReplacementRules]; *) 

]; 


removeReplacementRule[x___]:= printWarning["removeReplacementRule: program error: argument must be a string: \""<>x<>"\""
];

evaluateReplacementRules[expression_?StringQ]:= Module[{s},
If[$SBML$evaluateParameters, 
s= ToExpression[expression];
s = (s/.SBMLReplacementRules);
s=ToString[InputForm[s]];
Return[s]; 

];
Return[expression];
];

evaluateReplacementRules[expression_]:= Module[{s},
If[$SBML$evaluateParameters, 
s = (expression/.SBMLReplacementRules);
Return[s]; 
]; 
Return[expression]; 
];


evaluateConstantValues[expression_]:= Module[{ConstantValue,s,v},
ConstantValue[x_]:= Module[{v,sx},
sx =If[StringQ[x], x,  ToString[x]]; 
If[!MathSBML`Private`SBMLParameterQ[sx], Return[x]]; 
v= MathSBML`Private`SBMLIC[sx];

If[v=="Indeterminate",
Return[x]]; 
Return[ToExpression[v]]; 
]; 

s= ToString[InputForm[expression]];
s = StringReplace[s, {"*"-> ",","/"-> ",", "^"-> ",", "+"-> ",", "-"-> ",","("-> ",", ")"-> ",", "["-> ",", "]"-> ","}];
While[StringTake[s,1]==",", s = StringDrop[s,1]];
While[StringTake[s,-1]==",",s=StringDrop[s,-1]];
s="{"<>s<>"}";
s= StringReplace[s," "-> ""]; 

While[Length[StringPosition[s,",,"]]>0,
s=StringReplace[s,",,"-> ","]; 
]; 

s = ToExpression["{"<>s<>"}"]//Flatten;
s = Select[s, !NumberQ[#]&]//Union;
s = Select[s, MathSBML`Private`SBMLParameterQ[ToString[#]]&]; 
v = Map[ConstantValue,s];
r= MapThread[#1-> #2&, {s,v}];
expression/.r
]; 



translateFormula[f_]:= translateFormula[f, $SBML$Context]; 
translateFormula[f_,context_]:=  Module[
{dbg=False,
s,p,p1,sbmlSymbols={"(",")","-","^","*","/","+",","},
level1pdf={"abs","acos","asin","atan","ceil","cos","exp","floor","log","log10","pow","sqr","sqrt","sin","tan","mass","uui","uur","uuhr","isouur","hilli","hillr","hillmr","hillmmr","usii","usir","uai","ucii","ucir","unii","unir","uuci","uucr","umi","umr","uaii","uar","ucti","uctr","umai","umar","uhmi","uhmr","ualii","ordubr","ordbur","ordbbr","ppbr"},
allowedCharacters = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","(",")","-","^","*","/","+",",","."},
exponentCharacters={"E","e","D","d","Q","q"},
isAFunction,
isANumber,
isASymbol,
symbolRules,ctxt,punctuation,bracketLocations,n,findMatch,closing, isAVariable, badCharacters, cc,isTime,endsWithExponentCharacter,possiblemantissaQ,i,ch,cnext,pnext
},
(* cpuSet[]; *) 

isAFunction[x_]:= MemberQ[level1pdf,x];
isANumber[x_]:= MemberQ[CharacterRange["0","9"],StringTake[x,1]];
isTime[x_]:= (x=="t"); 
isASymbol[x_]:= \[Not](isAFunction[x] \[Or]isANumber[x]\[Or]isTime[x]);
isAVariable[x_]:= (isASymbol[x] \[And] SBMLVariableQ[x]);
endsWithExponentCharacter[x_]:= MemberQ[exponentCharacters,StringTake[x,-1]];
possiblemantissaQ[x_]:= isANumber[x] \[And] endsWithExponentCharacter[x]; 

ctxt = context;
If[StringTake[ctxt,-1]!= "`", ctxt = ctxt<>"`"];

ff=StringReplace[f," "-> ""];

(* Check for bad characters*) 
cc = Characters [ff]; 
badCharacters = Complement[cc, allowedCharacters];
badCharacters = Complement[badCharacters, {$SBML$Underscorecharacter}];  
If[Length[badCharacters]>0,
printWarning["translateFormula: the formula \""<>f<>"\" contains the following invalid characters: "<>list2CommaSeparatedString[badCharacters]];
];

(* make sure that there are at least some delimiters! *) 

ff="("<>ff<>")";

(* determine where the non-punctuation characters are *)
p= Flatten[Map[Union,StringPosition[ff,sbmlSymbols]]];
p1= Partition[p,2,1];
p1 =Prepend[ Append[p1, {Last[p],1+StringLength[ff]}],{0,First[p]}];
p1= Select[p1,(Last[#]-First[#]>1)&];
p1 = Map[{First[#]+1, Last[#]-1}&,p1];
debugPrint[dbg,"translateFormula: p1",p1];
s = Map[StringTake[ff,#]&,p1];
debugPrint[dbg,"translateFormula: s",s,Length[s]];

(* determine where the punctuation characters are *) 
punctuation = Append[Prepend[Flatten[p1],0],1+StringLength[ff]];
punctuation = Partition[punctuation,2];
punctuation = Map[{1+First[#],Last[#]-1}&, punctuation];
punctuation=Map[StringTake[ff,#]&, punctuation];
debugPrint[dbg,"translateFormula: punctuation",punctuation];

(* add context and function-dependence *) 
s=Map[If[isASymbol[#],contextify[#,ctxt],#]&, s];
debugPrint[dbg,"translateFormula: contextified s=",s];

s=Map[If[isAVariable[#],functionize[#],#]&, s];
debugPrint[dbg,"translateFormula: functionized s=",s];

(* check for split exponential: 1.5E-17 will be split into 1.5E, -, 17. Repalce the 1.5E with 1.5E-17 and the 17 with zero.  *) 

cnext=s[[1]];
For[i=1,i< Length[s],i++, 
cn = cnext;
cnext=s[[i+1]];
pnext = punctuation[[i+1]];
If[pnext== "+" \[Or] pnext== "-", 
If[possiblemantissaQ[cn] \[And] isANumber[cnext],
s= ReplacePart[s, cn<>pnext<>cnext,i];
s=ReplacePart[s,"0",i+1]; 
cnext = "0"; (* replace with +0 or -0 *) 
]; 
]; 
]; 

(* take care of E-form constants *) 
s=Map[If[isANumber[#],ToString[InputForm[fromEForm[#]]],#]&, s];
debugPrint[dbg,"translateFormula: Eformed s=",s];


(* add opening function brackets *) 
s = Map[If[isAFunction[#], #<>"[",#]&, s];
debugPrint[dbg, "translateFormula: leading [ s=",s];

(* turn formula back into a single string *)

s=Append[Transpose[{Drop[punctuation,-1],s}],Last[punctuation]]//Flatten//StringJoin;
(* the only place there could have been a [ is if we just put it there. If there is not a parenthesis right away then the formula is ill-formed *)
s = StringReplace[s,"[("-> "["];

bracketLocations= StringPosition[s,"["];
bracketLocations=Map[First,bracketLocations];
debugPrint[dbg,"translateFormula: brackets at ", bracketLocations];
n=StringLength[s];

(* for each function opening, find the function closing, and replace the parenthesis with a bracket *)
findMatch[istart_]:= Module[{i,pcount},
pcount = 1;
i = istart;
While[i<n,
i++;
Switch[StringTake[s,{i}],
"(",pcount++,
"[",pcount++,
")",pcount--
];
If[pcount==0,Return[i]];
];
Return[n];
]; (* end findMatch *) 

closing = Map[findMatch,bracketLocations];
closing = Transpose[{closing,closing}];

s = StringReplacePart[s,"]",closing];
debugPrint[dbg,"translateFormula: closing brackets", s];
s = defunctionize[s];
debugPrint[dbg, "------------ translateFormula: return value: ",s];
(* cpuReport["translateFormula"];  *) 

s=applyLevel1MathFunctions[s];

Return[s];
];


applyLevel1MathFunctions[formula_]:=Module[{ mylog10,mysquare, r={Global`abs-> Abs, Global`acos-> ArcCos, Global`asin-> ArcSin, Global`atan-> ArcTan,Global`ceil-> Ceiling, Global`cos-> Cos, Global`exp-> Exp, Global`floor-> Floor, Global`log-> Log ,Global`log10-> mylog10, Global`pow-> Power, Global`sqr-> mysquare,Global`sqrt-> Sqrt, Global`sin-> Sin, Global`tan-> Tan },f},

mylog10[x_]:= Log[10.,x];
mysquare[x_]:= x*x;
f=stringer[formula];
f=ToExpression[f];
f=(f/.r);
f=stringer[f];
Return[f];
];


abortIfNoTag[xml_, tag_]:= If[Length[xml]<1,
Print["Error: "//boldRed, "No "//boldBlack,quote[ stringer[tag]]//boldBlue, " found."//boldBlack];
 Abort[] 
];


list2CommaSeparatedString[l_,opt___?OptionQ]:= Module[{ll,commaValue,lcomma},
commaValue = (comma/.{opt}/.{comma-> ","})//ToString;
lcomma = StringLength[commaValue]; 

ll = Flatten[{l}];
If[Length[ll]<1, Return[""]];
ll = Map[ToString, ll];
ll = Map[StringJoin[#,commaValue]&,ll];
ll = Apply[StringJoin,ll];
ll = StringDrop[ll,-1*lcomma];
Return[ll];
]


getAttributeValue[desiredAttribute_, 
valueOfDesiredAttribute_, 
unknownAttribute_, 
opt___?OptionQ]:= Module[{c, valueOfUnknownAttribute},
c = Cases[opt,{___,desiredAttribute-> valueOfDesiredAttribute,___}];
If[Length[c]>1,
Print["Warning: The attribute\[Rule]value pair "<>ToString[desiredAttribute]<>"\[Rule]"<>ToString[valueOfDesiredAttribute]<>" occurs more than once." ];
c = Last[c];
];
c=Flatten[c];
valueOfUnknownAttribute=unknownAttribute/.c;
Return[valueOfUnknownAttribute];
]


getAttributeValues[desiredAttribute_, 
valueOfDesiredAttribute_, 
unknownAttribute_, 
opt___?OptionQ]:= Module[{c, valueOfUnknownAttribute},
c = Cases[opt,{___,desiredAttribute-> valueOfDesiredAttribute,___}];
valueOfUnknownAttribute=Map[
unknownAttribute/.#&, c];
Return[valueOfUnknownAttribute];
]


SBMLLogPlot[q_?InterpolationSetListQ,   opt___?OptionQ]:= Module[
{dbg=False, vars, data, getvars, times, tbegin, tend, legends, colors, n, p, selectRealPositives},
getvars[InterpolationSet[t1_,t2_,sol_]]:= Module[{vars},
vars = First/@sol;
vars = StringReplace[stringer/@vars,"[t]"-> ""]//ToExpression;
If[dbg, Print["SBMLLogPlot: Interpolation Set: getVars: "//boldBlue,"{t1,t2}="//boldBlack,{t1,t2}//boldRed, "vars="//boldBlack,vars//boldRed]];

Return[{{t1,t2}, vars}];
];
vars = getvars/@q;
times = First/@vars;
vars = Last/@vars;
tbegin = Min[times]; tend = Max[times]; 
vars = Intersection[vars]//Flatten; (* might loose variables if the sets are different *) 
legends = decontextify[stringer/@vars];
n=Length[legends];
colors = Map[Hue,Range[n]/(1.0*n)];
MultiPlot$Colors=colors;
MultiPlot$Styles=colors;
MultiPlot$Legends = legends;



If[dbg, 
Print["SBMLLogPlot: Interpolation Set:"//boldBlue, "vars="//boldBlack,vars//boldRed];
Print["SBMLLogPlot: Interpolation Set:"//boldBlue, "times="//boldBlack,times//boldRed, " tbegin="//boldBlack, tbegin//boldRed, " tend="//boldBlack, tend//boldRed];
];

data = dataTable[#,{Global`t,tbegin, tend, (tend-tbegin)/50.}, q]&/@vars;
data = Rest/@data; 

selectRealPositives[z_]:= 
Select[z, (Im[Last[#]]==0 && Re[Last[#]]>SBML$LogPlotZero)&];
data = selectRealPositives/@data;


Off[Graphics::gptn];
p=MapThread[
Graphics`Graphics`LogListPlot[#1,opt, PlotJoined-> True, PlotStyle-> #2, DisplayFunction-> Identity]&, {data, colors}];
On[Graphics::gptn];
Return[Show[p, opt, PlotRange-> All]];
];



SBMLLogPlot[soln_,var_?ListQ, {tbegin_, tend_},opt___?OptionQ]:= Module[{n,p,colors, legend, autoscale, man,mans,exps, dbg=False},

(* add autoscaling 6-2-04 *) 
(* figure out the max & minimum value plotted *)

plottable=var;
autoscale=findMiniMax[soln, #, {tbegin,tend}, filterNonPositives-> True,opt]&/@var;
autoscale = Select[Flatten[autoscale],Positive];
autoscale = {Min[autoscale], Max[autoscale]};
n = Length[plottable]; 
colors = Map[Hue,Range[n]/(1.0*n)];

(* now round off the mantissa *)

man = MantissaExponent/@autoscale;
{mans,exps} = Transpose[man];

mans = 10*mans;
mans = {Floor[mans[[1]]], Ceiling[mans[[2]]]};
mans = mans/10.;
man = Transpose[{mans,exps}];

autoscale = #[[1]]*(10^#[[2]])&/@man;

If[autoscale[[2]]<0 ,
Print["Warning:"//boldOrange, " unable to autoscale logarithmic plot due to all data values being negative. Range of data values is "//boldBlack, autoscale//boldRed];
autoscale={autoscale[[1]], 1};
];

If[autoscale[[1]]<0, 
Print["Warning:"//boldOrange, " unable to fully autoscale logarithmic plot due to negative data value. Range of data values is: "//boldBlack, autoscale//boldRed];
autoscale={autoscale[[2]]*0.1, autoscale[[2]]};
];


If[dbg, Print["SBMLLogPlot: autoscale = ", autoscale]]; 
If[dbg, Print["SBMLLogPlot: opt = ", {opt}]]; 

p = MapThread[SBMLLogPlot[soln, #1[Global`t], {tbegin,tend}, PlotStyle-> #2, DisplayFunction-> Identity, opt, PlotRange-> autoscale]&,{plottable,colors}];

If[dbg, Print["SBMLLogPlot: p generated."]]; 

p=Show[p];
legend ={MapThread[{Graphics[{#1,Line[{{0,0},{1,0}}]}],decontextify[ToString[#2]]}&,{colors,plottable}]};
legend = Append[legend, LegendPosition-> {1,-.5}]; 
p=ShowLegend[
p,
legend
]; 
Return[p];
]; 

SBMLLogPlot[soln_, var_, {tbegin_, tend_},opt___?OptionQ]:= Module[{dbg=False},
If[dbg, Print["SBMLLogPlot: SBMLogPlot-var: opt ", {opt}]]; 

Graphics`Graphics`LogPlot[Evaluate[var/.soln], {Global`t,tbegin,tend},opt]//Return;
]; 


findMiniMax[n_, var_, {tbegin_, tend_}, opt___?OptionQ]:= Module[{npts,ops, dt, max,min,i,x,times,if,positiveOnly,msave},

ops = Flatten[{opt}];

positiveOnly = filterNonPositives/.ops/.{filterNonPositives-> False};

npts = (PlotPoints/.ops/.{PlotPoints-> 50});
dt =Abs[ (tbegin-tend)/(1.0*npts)];
times = Range[Min[tbegin, tend], Max[tbegin,tend], dt];
if = var[Global`t]/.n;
max = Evaluate[if/.{Global`t-> #}]&/@times;
max = Flatten[max];

If[positiveOnly,
msave=max;
max = Select[max,Positive];
If[Length[max]<1, Print["Warning:"//boldOrange," unable to plot the variable "//boldBlack,var//boldRed," on a logarithmic scale because it never takes on a positive value."//boldBlack]; max=msave;
plottable=Complement[plottable, {var}];
];
If[Length[max]!= Length[msave],
Print["Warning:"//boldOrange, " Some values of the variable "//boldBlack,var//boldRed," can not be plotted on a logarithmic scale because they do not evaluate to a positive number."//boldBlack]
]; 

];

min = Min[max];
max = Max[max];
Return[{min,max}];
]


$Debug$MessageColor=Red;
$Debug$ValueColor=Blue;
$Debug$DebugColor=Green;
debugPrint[flag_, str_, value_]:= Module[{msg,s},
If[flag,
s= ToString[str]<>":: ";
Print[
MyStyle[">>>debug:: ",FontColor->$Debug$DebugColor, FontWeight-> "Bold"],
MyStyle[s, FontColor->$Debug$MessageColor,
FontWeight-> "Bold"],
MyStyle[value,FontColor-> $Debug$ValueColor, FontWeight-> "Bold"]
];
];
];
debugPrint[flag_, str_]:= Module[{msg,s},
If[flag,
s= ToString[str]<>":: ";
Print[
MyStyle[">>>debug:: ",FontColor->$Debug$DebugColor, FontWeight-> "Bold"],
MyStyle[s, FontColor->$Debug$MessageColor,
FontWeight-> "Bold"]
];
];
];


printWarning[x_]:= Module[{s},

(* Increment counters even if printing is inhibited to keep a record of the fact that a warning was issued *)

$SBML$SessionWarnings++;
$SBML$FileWarnings++;

If[$SBML$warnings,

Print[
MyStyle[">>Warning: "<>ToString[x],
FontColor-> $Warning$Color, 
FontWeight-> "Bold"]
];
];
];
printWarning[test_,x_]:= If[test, printWarning[x]];


headerPrint[x_]:= MyStylePrint[x,
Background-> GrayLevel[.929688],
TextAlignment->$SBML$VerboseAlign,
FontSize-> \[Cent]Header$Size,
FontFamily-> \[Cent]Header$Font,
FontColor-> \[Cent]Header$Color,
FontWeight-> \[Cent]Header$Weight];


verboseSave[title_,columnHeaders_,  table_]:= Module[{new},
new=table/.{"Indeterminate"-> "\[CenterEllipsis]",""-> "\[CenterEllipsis]",{}-> "\[CenterEllipsis]", $SBML$IndeterminateValue-> "..."};
SBML$VerboseData = Append[SBML$VerboseData, {title, columnHeaders, new}];
];


verbosePrint[]:= Module[{headerOnly,prtable},
headerOnly[{x_, y_, z_}]:= (Length[y]<1) \[And] (Length[z]<1);
prtable[{x_, y_, z_}]:= If[headerOnly[{x,y,z}],
headerPrint[x],
printTable[z,columnHeaders-> y, title-> x]
];
prtable[x_]:= prtable[{x[[1]], x[[2]], x[[3]]}];
Map[prtable, SBML$VerboseData];
];



printTable[data_, opt___?OptionQ]:= Module[{t,h,ncol},
t=title/.{opt}/.{title-> "Table Header"};
headerPrint[t];
If[Length[data]<1,
MyStylePrint["----- None -----",  FontFamily-> "Times", (* FontSize-> $Column\[Cent]HeaderSize, *) FontColor->RGBColor[0.`,0.`,0.`], TextAlignment->$SBML$VerboseAlign];
 Return[]
];

ncol = Length[data[[1]]];

h = columnHeaders/.{opt}/.{columnHeaders-> {}};
h = PadRight[h,ncol,"column header"];
t=Prepend[data,Map[MyStyle[#,FontWeight->"Bold", FontVariations-> {"Underline"-> True}, FontFamily-> "Times",FontColor->$Column\[Cent]Header$Color, FontSize-> $Column\[Cent]HeaderSize]&,h]];
MyStylePrint[TableForm[t, TableAlignments-> {Left,Top}],TextAlignment-> $SBML$VerboseAlign];


];


makeIntoValidSId[inputString_?StringQ, hold___]:= Module[{inputCharacters, outputCharacters,replacement,replacements, changedCharacters,interestingChange,outputString,letterOrUnderscore, held},

If[StringLength[inputString]== 0, Return[inputString]]; 
held = {hold,"\[NumberSign]",$SBML$Underscorecharacter  }//Flatten; 

replacement[x_]:= Module[{},
If[DigitQ[x], Return[x]];
If[LetterQ[x],Return[x]];
If[x=="_", Return[$SBML$Underscorecharacter]]; 
If[MemberQ[held,x], Return[x]]; 
Return["\[NumberSign]"<>ToString[First[ToCharacterCode[x]]]<>"\[NumberSign]"]; 
]; (* end replacement *) 

letterOrUnderscore[x_]:= LetterQ[x] \[Or] (x==MathSBML`Private`$SBML$Underscorecharacter);

inputCharacters = Characters[inputString];
outputCharacters=Map[replacement,inputCharacters];

If[!letterOrUnderscore[outputCharacters[[1]]], 
outputCharacters=ReplacePart[outputCharacters,MathSBML`Private`$SBML$Underscorecharacter<>outputCharacters[[1]],1];
];

outputString = Apply[StringJoin,outputCharacters];
changedCharacters = MapThread[(#1!= "_")\[And](#1!= #2)&, {inputCharacters,outputCharacters}];
interestingChange = Apply[Or, changedCharacters]; 
If[interestingChange,
Print["Warning:"//boldRed, " The invalid identifier "//boldBlack, inputString//boldBlue," has been replaced with "//boldBlack, outputString//boldBlue,"\nThis may violate the model's intent."//boldRed]
];
Return[outputString]; 
];


removeUnderscore[x_, opt___?OptionQ]:= Module[{replacement, result,cc,badCharacters,replacements,rr,
allowedCharacters = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","(",")","-","^","*","/","+",",","."," "}
},
replacement =  replaceWith/.{opt}/.{replaceWith->$SBML$Underscorecharacter}; 
result = StringReplace[ToString[x], "_"-> replacement];

cc = Characters [result]; 
badCharacters = Complement[cc, allowedCharacters];
badCharacters = Complement[badCharacters, {$SBML$Underscorecharacter}];  

If[Length[badCharacters]>0,
replacements = Map["\[NumberSign]"<>ToString[First[ToCharacterCode[#]]]<>"\[NumberSign]"&,badCharacters];
rr = MapThread[#1->#2&, { badCharacters,replacements}]; 
result = StringReplace[result,
MapThread[#1->#2&, { badCharacters,replacements}]]; 

printWarning["\""<>x<>"\" contains the following characters that are not permitted in SBML: "<>list2CommaSeparatedString[badCharacters]<>".  The following string has been used instead: \""<>result<>"\""];
];


Return[result];
];


fromEForm[x_]:= Module[{},
If[$VersionNumber>5, Return[getEForm[stringer[x]]]];
Return[getEFormV4[x]];
];




rationalNumberFormQ[x_?StringQ]:= StringMatchQ[x, RegularExpression["-?\\d+/\\d+"]];
rationalNumberFormQ[x___]:= False;

SNFormQ[x_?StringQ]:= StringMatchQ[x, 
RegularExpression["(\\d*\\.?\\d*\\*)?(10)?\\^-?\\d+"]
]
SNFormQ[x___]:= False;


mantissaForm="(\\-?\\d*\\.?\\d*|\\+?\\d*\\.?\\d*)";
exponentForm="(\\-?\\d+|\\+?\\d+)";
mantissaFormQ[x_?StringQ]:= StringMatchQ[x,RegularExpression[mantissaForm]];
mantissaFormQ[x___]:=False;
exponentFormQ[x_?StringQ]:= StringMatchQ[x, RegularExpression[exponentForm]];
exponentFormQ[x___]:=False;
(* eFormQ[x_?StringQ]:= StringMatchQ[x,RegularExpression["("<>mantissaForm<>"e"<>exponentForm<>")"]]; *)
eFormQ[x_?StringQ]:= Or[eFormQ[x,"e"], eFormQ[x,"E"]];
eFormQ[x_?StringQ,sep_?StringQ]:= StringMatchQ[x,RegularExpression[mantissaForm<>sep<>exponentForm]];
eFormQ[x___]:=False;
FortranEFormQ[x_?StringQ]:= Or@@(eFormQ[x,#]&/@{"d","D","q","Q"});
FortranEFormQ[x___]:= False;
numericalFormQ[x_?StringQ]:=mantissaFormQ[x]\[Or]exponentFormQ[x]\[Or]eFormQ[x];
numericalFormQ[x_]:= NumberQ[x];
numberFormQ[x_]:= mantissaFormQ[x]\[Or]exponentFormQ[x];
IntegerFormQ[x_]:= exponentFormQ[x];
isanumber[x_]:= numberFormQ[x] \[Or] eFormQ[x]; 
notanumber[x_]:= !isanumber[x]; 


eForm2MantissaExponent[x_?eFormQ]:= Module[{m,e,p,p1,p2,sep="e"},
p=StringPosition[x,sep];
If[Length[p]==0, Print["Error: "//boldRed," eForm2MantissaExponent: separator "//boldBlack,sep//boldBlue," not found in string "//boldBlack,x//boldBlue];
Return[{0,0}];
];
If[Length[p]!= 1, Print["Error: "//boldRed," eForm2MantissaExponent: separator "//boldBlack,sep//boldBlue," found in multiple locations in string "//boldBlack,x//boldBlue];
Return[{0,0}];
];
p=First[p];
{p1,p2}=p;
m=StringTake[x,p1-1];
e=StringDrop[x,p2];
Return[{m,e}];
];
eForm2MantissaExponent[x_?FortranEFormQ]:= eForm2MantissaExponent[FortranEFormToEform[x]];

eForm2MantissaExponent[x___]:= Print["Error: "//boldRed," eForm2MantissaExponent: invalid argumment:  "//boldBlack,x," is not a string in e-format "//boldBlack]

getEForm["Indeterminate"]:= Indeterminate; 


(* convert rationals to reals v. 2.7.5 *) 
getEForm[x_?rationalNumberFormQ]:= Module[{v},
v= getEForm[ToString[InputForm[1.0*ToExpression[x]]]];
Return[v]; 
]; 
 

getEForm[x_?mantissaFormQ]:= ToExpression[x];

getEForm[xin_?eFormQ]:= Module[{e,x,y,m,exp},
x=StringReplace[xin,"E"-> "e"]; 
e=StringPosition[x,"e"]//Flatten//Union//First;
m=StringTake[x,e-1]//ToExpression;
exp=StringDrop[x,e]//ToExpression;
y=m*10^exp;
If[Head[y]===Rational, y=1.*y];
Return[y];
];

FortranEFormToEform[x_?FortranEFormQ]:= StringReplace[
x,{"E"-> "e","d"-> "e","D"-> "e","Q"-> "e","q"-> "e"}
];
FortranEFormToEform[x___]:= x;

getEForm[x_?SNFormQ]:= Module[{y}, 
y=ToExpression[x]; 
y=1.0*y;
y=deFortranize[y]; 
Return[y];
]

getEForm["INF"]:= Infinity;

getEForm[x___]:= Module[{y=Indeterminate},
If[FortranEFormQ[x],
y=FortranEFormToEform[x];
Print["Error:"//boldRed," getEForm: the expression "//boldRed,x//boldBlue," appears to be a FORTRAN scientific notation that is not supported by MathML. Scientific notation in MathML only permits the lower case \"e\" to be used as the exponential separator. Attempting recovery as "//boldBlack, y//boldBlue ];
y=getEForm[y];
Return[y];
];

(* At this point assume its some form of string number and try to convert  *)

Print["Error: "//boldRed," getEForm: the expression "//boldRed, x//boldBlue," is not a valid string numeric expression and was replaced with "//boldBlack, y//boldBlue, " \nPlease check to make sure all numbers in scientific notation were expressed as real numbers, e.g., 3.0*10^-16 rather than rationals, e.g., 3*10^-16"//boldBlack];
Return[y];
];





getEFormV4[str_]:= Module[{s,p,np,ns,v, maybeFortran},

If[(ToString[str]==ToString[$SBML$IndeterminateValue]), v=ToString[$SBML$IndeterminateValue];
v=StringReplace[v,{"\""-> ""}];
Return[v];
];

maybeFortran[x_]:=Module[{c},
c=Intersection[Characters[x],{"E","d","D","q","Q"}];
Return[Length[c]==1];
];

If[maybeFortran[ToString[str]],
Print["Error: "//boldRed," getEFormV4: The expression "//boldBlack,str//boldBlue," appears to be a Fortran-formatted scientific notation, which is not permitted in MathML. Scientific notation requires the use of the character \"e\" to delimit the exponent and does not allow \"E\",\"d\",\"D\",\"q\",or\"Q\"."//boldBlack];
Return[str];
];

(* s=StringReplace[ToString[str],{"e"-> ",", "E"-> ",", "d"-> ",","D"-> ",","q"-> ",", "Q"-> ","}]; *)
s=StringReplace[ToString[str],{"e"-> ","}];

(* q, Q is Fortran quadruple precision *) 

(* This won't catch all errors *) 
p=StringPosition[s,","];
np=Length[p];
ns=StringLength[s];
p=Map[First,p];
(* check for too many e's or exponents (mantissas) w/o mantissas (exponents) *)
If[np> 1 \[Or] MemberQ[p,1] \[Or] MemberQ[p,ns], 
Print["Error: "//boldRed,"getEFormV4: The value "//boldBlack,str//boldBlue," does not appear to be a correctly formated value, and was replaced with "//boldBlack,ToString[$SBML$IndeterminateValue]//boldRed
];

Return[$SBML$IndeterminateValue];
];


s = "{"<>s<>"}";
s=ToExpression[s];
s = PadRight[Flatten[s],2,0];

(* check for aEb where either a or b or non-numeric *) 
If[ ! Apply[And,Map[NumberQ,s]],
Print["Error: "//boldRed,"getEFormV4: The value "//boldBlack,str//boldBlue," does not appear to be a correctly formated value, and was replaced with "//boldBlack,ToString[$SBML$IndeterminateValue]//boldRed];
Return[$SBML$IndeterminateValue];
];

(* Multiply 1.0 so that 5e-3 = 0.005 and not 1/200 *)

s =s[[1]]*(10^s[[2]]);

If[s==Round[s], Return[Round[s]]]; (* keep as an integer added 2.3.36*)
If[!$SBML$Rationals, s=1.0*s];  (* force to be real and not a fraction *)

Return[s]

]


deFortranize[s_?StringQ]:= fromEForm[s];
deFortranize[x_?NumberQ]:= 1.0*x; 
deFortranize[x_]:= x;


(* mathSBMLHelpReference[opt___?OptionQ]:= Module[{usg,usgstr,pdfusg,
predef={"mass","uui","uur","uuhr","isouur","hilli","hillr","hillmr","hillmmr","usii","usir","uai","ucii","ucir","unii","unir","uuci","uucr","umi","umr","uaii","uar","ucti","uctr","umai","umar","uhmi","uhmr","ualii","ordubr","ordbur","ordbbr","ppbr"},
modelBuilder={"addCompartment", "addEvent", "addFunction","addParameter","addReaction", "addRule","addSpecies",
"annotationToSBML", "annotationToSymbolicSBML",
"compartmentToSBML","compartmentToSymbolicSBML","eventToSBML","eventToSymbolicSBML","functionToSBML","functionToSymbolicSBML", "InfixToMathML", "loadModelBuilder","loadSimulator","MathMLToInfix","modifyCompartment","modifyEvent","modifyFunction","modifyModel","modifyParameter","modifyReaction","modifyRule", "modifySpecies","newModel","parameterToSBML","parameterToSymbolicSBML","reactionToSBML","reactionToSymbolicSBML","removeCompartment","removeEvent", "removeFunction", "removeParameter", "removeReaction","removeRule", "removeSpecies","ruleToSBML","ruleToSymbolicSBML","setAnnotationNamespace","setAnnotationPackage","showModel", "speciesToSBML","speciesToSymbolicSBML","unitToSBML", "unitToSymbolicSBML"},
mbusg},
usg=Map[{#,ToExpression[#<>"::usage"]}&,Names["MathSBML`*"]];
usgstr=Select[usg,StringQ[Last[#]]&];

pdfusg = Map[{#,ToExpression[#<>"::usage"]}&,predef];
mbusg = Map[{#,ToExpression[#<>"::usage"]}&,modelBuilder];


If[Global`pdf/.{opt}/.{Global`pdf-> False},
usgstr = pdfusg, 
If[Global`modelBuilder/.{opt}/.{Global`modelBuilder-> False},
usgstr = mbusg,
usgstr =Complement[ Complement[usgstr, pdfusg],mbusg];
]
];

Map[(MyStylePrint[First[#],"Section"];
Print[Last[#]])&,usgstr];
];
*)



Jacob[f_?ListQ, vars_?ListQ]:= Module[{row,J},
row[x_]:= Map[D[x,#]&, vars];
J=Map[row,f];
Return[J];
];


Get["MathSBML-SBMLWrite-Special-Formats.m"];
Get["MathSBML-Level1-Predefined.m"]; 
 Get["MathSBML-Level2.m"]; 
Get["MathSBML-Computation.m"]; 
Get["MathSBML-MathML.m"];
Get["MathSBML-Visualization.m"];
Get["MathSBML-Simulation.m"]; 
Get["MathSBML-ModelBuilder.m"]; Get["MathSBML-Help.m"];


If[Length[Names["FLAGS`ECHOLOAD"]]>0,
MathSBML`Private`msgflag=ToExpression["FLAGS`ECHOLOAD"],
MathSBML`Private`msgflag=True;
];

VR=" (Version "<>ToString[$VersionNumber]<>", Release "<>ToString[$ReleaseNumber]<>")";
rightnow=DateString[{"Day"," ","MonthName", " ", "Year", " at ", "Hour24",":", "Minute", " ", "TimeZone"}];

closing$message="MathSBML Version "<>ToString[$MathSBML$Version]<>" using Mathematica Version "<>$Version<>VR<>" loaded "<>rightnow; 

If[MathSBML`Private`msgflag,
If[TEMP$FIRST \[Or] (!TEMP$FIRST \[And] !Equal[ToString[$MathSBML$Version], TEMP$OLDVERSION]),
Print[MyStyleForm[closing$message, FontWeight-> Bold, FontColor-> Black]];,

Print[MyStyleForm[closing$message<>"(--reloaded--)", FontWeight-> Bold, FontColor-> Black]];

];

];
If[!TEMP$FIRST \[And] !Equal[ToString[$MathSBML$Version], TEMP$OLDVERSION],Print[
MyStyleForm["MathSBML: warning: loading a different version of MathSBML may cause unexpected results.\ncurrent version of MathSBML: "<>ToString[$MathSBML$Version]<>"\nprevious version of MathSBML:"<>TEMP$OLDVERSION,FontWeight-> Bold, FontColor-> Red]
]]; 

If[MathSBML`Private`msgflag,
Print["Please report MathSBML issues to the MathSBML Tracker, (Please include the above text) at "//boldBlack, Hyperlink["http://sourceforge.net/tracker/?atid=984327&group_id=71971&func=browse"]//boldBlue]
]; 
FLAGS`ECHOLOAD=MathSBML`Private`msgflag;
Remove[MathSBML`Private`msgflag];

End[];

Remove[TEMP$OLDVERSION];
Remove[TEMP$FIRST];
Remove[rightnow]; 
 
EndPackage[];
