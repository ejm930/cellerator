(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input:: *)
BeginPackage["xlr8r`"];


If[Length[Names["FLAGS`ECHOLOAD"]]>0,
xlr8r`Private`msgflag=ToExpression["FLAGS`ECHOLOAD"],
xlr8r`Private`msgflag=True;
];
FLAGS`ECHOLOAD=False; 
(* Needs["MathSBML`"]; *)
Needs["XML`"]; 
FLAGS`ECHOLOAD=xlr8r`Private`msgflag;
If[$VersionNumber<6, 
Needs["Utilities`FilterOptions`"];
]; 
Needs["DifferentialEquations`InterpolatingFunctionAnatomy`"]; 
(*Quiet[Needs["PlotLegends`"]; ]; *)


$xlr8r$Version = "0.95";
$xverdate$ = "28-Feb-2014";


TextArrow::usage="TextArrow[reaction] returns a pyxlr8r compatible reaction."


Flux::usage="Flux[lower-bound, fluxvar, upperbound, fluxval:0, objcoef:0]";
StoichiometryMatrix::usage="StoichometryMatrix[Model] returns the Stoichiometry Matrix of a Flux Model. If any kinetic reactions are included an error is returned.";
OptimizeFluxModel::usage="OptimizeFluxModel[model] returns a list {maximum of objective function, {v1->val, v2->val, v3->val,...}} where val's give a maximum, found using a Nelder Mead Simplex Algorithm.  All of the reactions in the Flux Model must be Cellerator Flux reactions (not kinetic reactions).";


Bind::usage="Bind is an uninstantiated function that is used to indicate intermediate complexes formed during a reaction, e.g., A+E\[RightArrowLeftArrow]Bind[A,E]\[RightArrowLeftArrow]B+E, for an enzymatic reaction. When Bind[A,B] is gnerated by interpret, the arguments will be alphabetized, i.e., Bind[B,A] will be converted to Bind[A,B]. If Bind[B,A] is sent to interpret, the order of the arguments will not be changed. The user should ensure that Bind[A,B] and Bind[B,A] are treated equivalently.";
dbgArrows=False;


interpret::usage="interpret[] converts a list of reactions into differential equations of the form {{ode for variable 1, ode for variable 2, ...}, {variable 1, variable 2, ...}}.\nThe variable Global`t is used for the time argument.\nA reaction has the format {arrow-form, rateConstants}.\n\nOptions:\n\"Frozen\"->List of variables whose values are to be held constant.";
debugflag::usage="debug is a flag used for debugging";
frozen::usage="frozen is a deprecated option for interpret and run that gives a list of variables to hold constant, default is frozen->{}. The preferred option is \"Frozen\"";
rates::usage="rates is an option for interpret that gives a list of rate constant replacement rules. Default is rates-> {}"; 
Options[interpret]={frozen-> {}, "frozen"-> {},  rates-> {}};
ODE::usage="ODE[reaction] returns the first ODE found by interpret\nODE[{reactions}] returns the first ODE\nODE[{reactions}, n] returns the nth ODE\nODE[{reactions},X] returns the ODE for X\nODE[{reactions},{X,Y,...}] returns the ODEs for X, Y, ..."; 


Comp::usage="Comp[] is an uninstantiated function to indicate the Complement of a variable with respect to 1, Comp[x][t]=1-x[t]";


lowLevelReactions::usage="lowLevelReactions[reactions, options] returns a list of basic reactions in a reaction list, by breaking down complex mass-action reations into their simplest forms.\nThe format for reactions is the same as the input to interpret.\n\nOptions:\nrates->False - If True, return rate constants.";
Options[lowLevelReactions]={rates-> False};


jacobianMatrix::usage="jacobianMatrix will calculate the jacobian of either the input to or the output from interpret";
Options[jacobianMatrix]={};


steadyState::usage="steadyState[r, t] returns a list of rule lists giving the steady state of the system, if possible.\nr may be either a list of reactions, or have the same format as the output of interpret, {{eq1,eq2,...}, {var1, var2,...}}.Each eqi is an expression involving vari'[t]. \nEach rule list returned represents a different steady state.\nExample:\nsteadyState[{{x'[t]\[Equal]x[t]^2-y[t], y'[t]\[Equal]y[t]+3x[t]}, {x[t],y[t]}},t]\nreturns:\n{{y[t]\[Rule]0,x[t]\[Rule]0},{y[t]\[Rule]9,x[t]\[Rule]-3}}";


eq1="  \!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v \((b + T\\\ \*SuperscriptBox[\(A[t]\), \(n\)]\\\ \[ScriptCapitalE][t])\)\), \(\*SuperscriptBox[\(K\), \(n\)] + \*SuperscriptBox[\(A[t]\), \(n\)]\)]\)==-A'[t]";
eq2=" \!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v \((b + T \*SuperscriptBox[\((\*UnderscriptBox[\(\[Sum]\), \(i\)]A[t])\), \(n\)]\\\ \[ScriptCapitalE][t])\)\), \(\*SuperscriptBox[\(K\), \(n\)] + \*SuperscriptBox[\((\*UnderscriptBox[\(\[Sum]\), \(i\)]A[t])\), \(n\)]\)]\)==-\!\(\*SubscriptBox[\(A\), \(i\)]\)'[t] ";
eq3="  \!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v \((b + T \(\*UnderscriptBox[\(\[Product]\), \(i\)]\*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), \(n\)]\\\ \[ScriptCapitalE][t]\))\)\), \(\*SuperscriptBox[\(K\), \(n\)] + \*UnderscriptBox[\(\[Product]\), \(i\)]\*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), \(n\)]\)]\)==-\!\(\*SubscriptBox[\(A\), \(i\)]\)'[t]";
eq4=" \!\(\*SuperscriptBox[\(X\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v \*SuperscriptBox[\((b + TA[t])\), \(n\)]\), \(\*SuperscriptBox[\(K\), \(n\)] + \*SuperscriptBox[\((b + T\\\ A[t])\), \(n\)]\)]\)";
eq5=" \!\(\*SuperscriptBox[\(X\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v \*SuperscriptBox[\((b + T1\\\ A[t] + T2\\\ B[t] + \[CenterEllipsis])\), \(n\)]\), \(\*SuperscriptBox[\(K\), \(n\)] + \*SuperscriptBox[\((b + T1\\\ A[t] + T2\\\ B[t] + \[CenterEllipsis])\), \(n\)]\)]\)";
hill::usage="hill is an uninstantiated function used to indicate parameter values for a hill-function based reaction.\n\nThe typical format for a Catalytic Hill Function is:"<>"\n{\!\(\*OverscriptBox[\(A \[RightTeeArrow] B\), \(\[ScriptCapitalE]\)]\), hill[T,K,n,b,v]} gives"<>eq1<>"\n{\!\(\*OverscriptBox[\({\*SubscriptBox[\(A\), \(1\)], \*SubscriptBox[\(A\), \(2\)], \[Ellipsis]} \[RightTeeArrow] B\), \(\[ScriptCapitalE]\)]\), hill[\[Ellipsis]]} and {\!\(\*OverscriptBox[\(\*SubscriptBox[\(A\), \(1\)] + \*SubscriptBox[\(A\), \(2\)] + \[CenterEllipsis] \[RightTeeArrow] B\), \(\[ScriptCapitalE]\)]\), hill[\[Ellipsis]]} give "<>eq2<>"\n{\!\(\*OverscriptBox[\({SubscriptBox[A, 1] SubscriptBox[A, 2] SubscriptBox[A, 3] \[CenterEllipsis]} \[RightTeeArrow] B\), \(\[ScriptCapitalE]\)]\), hill[\[Ellipsis]]} gives"<>eq3<>"\n\nIn regulatory hill reactions, the concentrations of the reactants do not change. Typical Formats for Regulatory Hill Functions are:\n"<>"\n{A\[RightTeeArrow]X,hill[T,K,n,b,v]} gives "<>eq4<>"\n{{A,B,\[Ellipsis]}\[RightTeeArrow]X,hill[{T1,T2}, K,n,b,v]} or {A\[RightTeeArrow]X,hill[T1,K,n,b,b]},{B\[RightTeeArrow]X,hill[T2,\[Ellipsis]]},\[Ellipsis]} give "<>eq5<>"\nNotes:\nDefault values are T:1, K:1, n:1, b:0 (basal production), v:1 (rate)\nIf multiple regulatory hill reactions have the same product, the values of K, n, b, and v are ignored after the first reaction.\nDifferent types of regulatory reactions (e.g., hill, GRN, S-System,\[Ellipsis]) with the same product cannot not be combined.";
Hill::usage="Hill[] is an alternative form for hill[].";

Remove[eq1,eq2,eq3,eq4];


eq1="\!\(\*FractionBox[\(1\), \(2\)]\) (1+\!\(\*FractionBox[\(x\), SqrtBox[\(1 + \*SuperscriptBox[\(x\), \(2\)]\)]]\))";
sigma::usage="sigma[x] returns the value"<>eq1;
eq2="\!\(\*FractionBox[\(1\), \(1 + \*SuperscriptBox[\(\[ExponentialE]\), \(-x\)]\)]\)";
sigmoid::usage="sigmoid [x] returns the value "<>eq2;
eq3="\!\(\*FractionBox[\(r\), \(1 + \*SuperscriptBox[\(\[ExponentialE]\), \(\(-h\) - T\\\ \*SuperscriptBox[\(x\), \(n\)]\)]\)]\)";
grnsigmoid::usage="grnsigmoid[x, r:1, T:1, n:1, h:0] returns the value "<>eq3;
eq4="\!\(\*FractionBox[\(r\), \(1 + \*SuperscriptBox[\(\[ExponentialE]\), \(\(-h\) - T\\\ \*SuperscriptBox[\(A[t]\), \(n\)]\)]\)]\)";
eq5="\!\(\*FractionBox[\(r\), \(1 + \*SuperscriptBox[\(\[ExponentialE]\), \(\(-h\) - T1\\\ \*SuperscriptBox[\(A1[t]\), \(n1\)] - T2\\\ \*SuperscriptBox[\(A2[t]\), \(n2\)] - \[CenterEllipsis]\)]\)]\)";
GRN::usage="GRN[r, T, n, h] is an uninstantiated function used to represent neural network based Genetic Regulatory Networks. The canonical forms are\n"<>"{A\[RightTeeArrow]B, GRN[r, T, n, h]} "<>" which means B'[t]=="<>eq4<>"\n{{A1,A2,...}\[RightTeeArrow]B, GRN[r, {T1,T2,...}, {n1,n2,...}, h]} which means B'[t]="<>eq5<>"= r * sigma[h*T.(x^n)], where T={T1,T2,...}, x={A1,A2,...}, n={n1,n2,...}"<>"\nGRN[r,T,n,h,f] is a user-defined GRN reaction, with "<>"canonical form  {A\[RightTeeArrow]B, mygrn[r, T, n, h, f]}, where mygrn is any uninstantiated function that the user chooses, and f is any function of a single argument"<>"\nGRN[r,T,n,h], GRN[r,T,n,h,sigma], and mygrn[r,T,n,h,sigma] will produce the same results. However, GRN and mygrn reactions can not be combined with the same product, even if the same function is used.";
Remove[eq1,eq2,eq3,eq4,eq5];


rational::usage=""


eq1="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v\\\ A[t]\), \(A[t] + \*SubscriptBox[\(K\), \(M\)]\)]\)==-\!\(\*SuperscriptBox[\(A\), \(\[Prime]\),\nMultilineFunction->None]\)[t]";
eq2="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(A[t]\\\ \*SubscriptBox[\(v\), \(1\)]\), \(A[t] + \*SubscriptBox[\(K\), \(M, 1\)]\)]\)-\!\(\*FractionBox[\(B[t]\\\ \*SubscriptBox[\(v\), \(2\)]\), \(B[t] + \*SubscriptBox[\(K\), \(M, 2\)]\)]\)==-\!\(\*SuperscriptBox[\(A\), \(\[Prime]\),\nMultilineFunction->None]\)[t]";
eq3="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v\\\ A[t]\\\ En[t]\), \(A[t] + \*SubscriptBox[\(K\), \(M\)]\)]\)==-\!\(\*SuperscriptBox[\(A\), \(\[Prime]\),\nMultilineFunction->None]\)[t]";
eq4="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(A[t]\\\ En[t]\\\ \*SubscriptBox[\(k\), \(3\)]\), \(A[t] + \*FractionBox[\(\*SubscriptBox[\(k\), \(2\)] + \*SubscriptBox[\(k\), \(3\)]\), SubscriptBox[\(k\), \(1\)]]\)]\)==-\!\(\*SuperscriptBox[\(A\), \(\[Prime]\),\nMultilineFunction->None]\)[t]";
eq5="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(A[t]\\\ EF[t]\\\ \*SubscriptBox[\(v\), \(F\)]\), \(A[t] + \*SubscriptBox[\(K\), \(D, F\)]\)]\)-\!\(\*FractionBox[\(B[t]\\\ ER[t]\\\ \*SubscriptBox[\(v\), \(R\)]\), \(B[t] + \*SubscriptBox[\(K\), \(D, R\)]\)]\)==-A'[t]";
eq6="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(A[t]\\\ EF[t]\\\ \*SubscriptBox[\(k\), \(3, f\)]\), \(A[t] + \*FractionBox[\(\*SubscriptBox[\(k\), \(2, f\)] + \*SubscriptBox[\(k\), \(3, f\)]\), SubscriptBox[\(k\), \(1, f\)]]\)]\)-\!\(\*FractionBox[\(B[t]\\\ ER[t]\\\ \*SubscriptBox[\(k\), \(6, f\)]\), \(B[t] + \*FractionBox[\(\*SubscriptBox[\(k\), \(5, f\)] + \*SubscriptBox[\(k\), \(6, f\)]\), SubscriptBox[\(k\), \(4, 5\)]]\)]\)==-A'[t]";
MM::usage="MM is an uninstantiated function used to define parameters for a Michaelis-Menten type of reaction."<>"\n{A\[DoubleLongRightArrow]B,MM[\!\(\*SubscriptBox[\(K\), \(M\)]\),v]} means" <>eq1<>"\n{A\[DoubleLongLeftRightArrow]B,MM[\!\(\*SubscriptBox[\(K\), \(M, 1\)]\),\!\(\*SubscriptBox[\(v\), \(1\)]\), \!\(\*SubscriptBox[\(K\), \(M, 2\)]\),\!\(\*SubscriptBox[\(v\), \(2\)]\)]} means "<>eq2<>"\n{\!\(\*OverscriptBox[\(A\[DoubleLongRightArrow]B\), \(En\)]\),MM[\!\(\*SubscriptBox[\(K\), \(M\)]\),v]} means "<>eq3<>"\n{\!\(\*OverscriptBox[\(A\[DoubleLongRightArrow]B\), \(En\)]\),MM[\!\(\*SubscriptBox[\(k\), \(1\)]\),\!\(\*SubscriptBox[\(k\), \(2\)]\),\!\(\*SubscriptBox[\(k\), \(3\)]\)]} means "<>eq4<>"\n{\!\(\*UnderoverscriptBox[\(A\[DoubleLongLeftRightArrow]B\), \(ER\), \(EF\)]\),MM[\!\(\*SubscriptBox[\(K\), \(D, F\)]\),\!\(\*SubscriptBox[\(v\), \(F\)]\),\!\(\*SubscriptBox[\(K\), \(D, R\)]\),\!\(\*SubscriptBox[\(v\), \(R\)]\)]} means "<>eq5<>"\n{\!\(\*UnderoverscriptBox[\(A\[DoubleLongLeftRightArrow]B\), \(ER\), \(EF\)]\),MM[\!\(\*SubscriptBox[\(k\), \(1, f\)]\),\!\(\*SubscriptBox[\(k\), \(2, f\)]\),\!\(\*SubscriptBox[\(k\), \(3, f\)]\),\!\(\*SubscriptBox[\(k\), \(4, 5\)]\),\!\(\*SubscriptBox[\(k\), \(5, f\)]\),\!\(\*SubscriptBox[\(k\), \(6, f\)]\)]} means "<>eq6;
Remove[eq1, eq2,eq3,eq4,eq5];



eq1="\[Tau]B'[t]=\!\(\*SuperscriptBox[\(k\), \(+\)]\)A[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[\(c\), \(+\)]]\)-\!\(\*SuperscriptBox[\(k\), \(-\)]\)A[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[\(c\), \(-\)]]\)";
eq2="\[Tau]B'[t]=\[Tau]B'[t]=\!\(\*SuperscriptBox[\(k\), \(+\)]\)\!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SubscriptBox[\(A\), \(i\)]\)[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[SubscriptBox[\(c\), \(i\)], \(+\)]]\)-\!\(\*SuperscriptBox[\(k\), \(-\)]\)\!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SubscriptBox[\(A\), \(i\)]\)[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[SubscriptBox[\(c\), \(i\)], \(-\)]]\)";
eq3="\n{{A1,A2,\[Ellipsis]}\[RightTeeArrow]B,SSystem[\[Tau],\!\(\*SuperscriptBox[\(k\), \(+\)]\), \!\(\*SuperscriptBox[\(k\), \(-\)]\),{\!\(\*SuperscriptBox[\(c\), \(+\)]\),\[Ellipsis]},{\!\(\*SuperscriptBox[\(c\), \(-\)]\),\[Ellipsis]}]}";
eq4="SSystem[\[Tau], \!\(\*SuperscriptBox[\(k\), \(+\)]\), \!\(\*SuperscriptBox[\(k\), \(-\)]\), \!\(\*SuperscriptBox[\(c\), \(+\)]\),\!\(\*SuperscriptBox[\(c\), \(-\)]\)]";
SSystem::usage=eq4<>" is an uninstantiated function used to specify parameters for Synergestic System (S-System) interactions. The canonical form is"<>"\n{A\[RightTeeArrow]B, SSystem[\[Tau], \!\(\*SuperscriptBox[\(k\), \(+\)]\), \!\(\*SuperscriptBox[\(k\), \(-\)]\), \!\(\*SuperscriptBox[\(c\), \(+\)]\),\!\(\*SuperscriptBox[\(c\), \(-\)]\)]}"<>
"\n which means "<>eq1<>eq3<>
"\n which means"<>eq2<>"\n{A1,A2,\[Ellipsis]}\[RightTeeArrow]B is the same as A1+A2+\[Ellipsis]\[RightTeeArrow]B. S-Systems are a special case of Generalized Mass Action interactions.";
Remove[eq1,eq2, eq3, eq4]



eq1="\[Tau]B'[t]=\!\(\*SuperscriptBox[\(k\), \(+\)]\)A[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[\(c\), \(+\)]]\)-\!\(\*SuperscriptBox[\(k\), \(-\)]\)A[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[\(c\), \(-\)]]\)";
eq2="\[Tau]B'[t]=\!\(\*UnderscriptBox[\(\[Sum]\), \(j\)]\)\!\(\*SubsuperscriptBox[\(k\), \(j\), \(+\)]\)\!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SubscriptBox[\(A\), \(i\)]\)[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[SubscriptBox[\(c\), \(ij\)], \(+\)]]\)-\!\(\*UnderscriptBox[\(\[Sum]\), \(j\)]\)\!\(\*SuperscriptBox[\(k\), \(-\)]\)\!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SubscriptBox[\(A\), \(i\)]\)[t\!\(\*SuperscriptBox[\(]\), SuperscriptBox[SubscriptBox[\(c\), \(ij\)], \(-\)]]\)";
eq3="\n{{A1,A2,\[Ellipsis]}\[RightTeeArrow]B,GMA[\[Tau],(\!\(\*SuperscriptBox[\(k\), \(+\)]\),\[Ellipsis]}, {\!\(\*SuperscriptBox[\(k\), \(-\)]\),\[Ellipsis]},{\!\(\*SuperscriptBox[\(c\), \(+\)]\),\[Ellipsis]},{\!\(\*SuperscriptBox[\(c\), \(-\)]\),\[Ellipsis]}]}";
eq4="GMA[\[Tau], \!\(\*SuperscriptBox[\(k\), \(+\)]\), \!\(\*SuperscriptBox[\(k\), \(-\)]\), \!\(\*SuperscriptBox[\(c\), \(+\)]\),\!\(\*SuperscriptBox[\(c\), \(-\)]\)]";
GMA::usage=eq4<>" is an uninstantiated function used to specify parameters for Generalized Mass Action (GMA) interactions. The canonical form is"<>"\n{A\[RightTeeArrow]B, GMA[\[Tau], \!\(\*SuperscriptBox[\(k\), \(+\)]\), \!\(\*SuperscriptBox[\(k\), \(-\)]\), \!\(\*SuperscriptBox[\(c\), \(+\)]\),\!\(\*SuperscriptBox[\(c\), \(-\)]\)]}"<>
"\n which means "<>eq1<>eq3<>
"\n which means"<>eq2<>"\n{A1,A2,\[Ellipsis]}\[RightTeeArrow]B is the same as A1+A2+\[Ellipsis]\[RightTeeArrow]B. When the k's are scalars then GMA interactions reduce to Synergistic System (S-System) interactions.";
Remove[eq1,eq2, eq3, eq4]



GMWC::usage="";
MWC::usage="";



eq1="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v\\\ \*SuperscriptBox[\((1 + T\\\ \*SuperscriptBox[\(A[t]\), \(n\)]\\\ \[CapitalTheta][T])\), \(m\)]\), \(k\\\ \*SuperscriptBox[\((1 + T\\\ \*SuperscriptBox[\(A[t]\), \(n\)]\\\ \[CapitalTheta][\(-T\)])\), \(m\)] + \*SuperscriptBox[\((1 + T\\\ \*SuperscriptBox[\(A[t]\), \(n\)]\\\ \[CapitalTheta][T])\), \(m\)]\)]\)";
eq2="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v\\\ \*SuperscriptBox[\((1 + TP\\\ \*SuperscriptBox[\(A[t]\), \(n\)])\), \(m\)]\), \(k\\\ \*SuperscriptBox[\((1 + TM\\\ \*SuperscriptBox[\(A[t]\), \(n\)])\), \(m\)] + \*SuperscriptBox[\((1 + TP\\\ \*SuperscriptBox[\(A[t]\), \(n\)])\), \(m\)]\)]\)";
eq3="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal]\!\(\*FractionBox[\(v \(\*UnderscriptBox[\(\[Product]\), \(i\)]\*SuperscriptBox[\((1 + SubscriptBox[TP, i] \*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), SubscriptBox[\(n\), \(i\)]])\), \(m\)]\)\), \(k\\\ \(\*UnderscriptBox[\(\[Product]\), \(i\)]\*SuperscriptBox[\((1 + SubscriptBox[TM, i] \*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), SubscriptBox[\(n\), \(i\)]])\), \(m\)]\) + \*UnderscriptBox[\(\[Product]\), \(i\)]\*SuperscriptBox[\((1 + SubscriptBox[TP, i] \*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), SubscriptBox[\(n\), \(i\)]])\), \(m\)]\)]\)";
eq4="\!\(\*SuperscriptBox[\(B\), \(\[Prime]\),\nMultilineFunction->None]\)[t]\[Equal](v \!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SuperscriptBox[\((1 + SubscriptBox[T, i] \[CapitalTheta][\*SubscriptBox[\(T\), \(i\)]] \*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), SubscriptBox[\(n\), \(i\)]])\), \(m\)]\))/(k \!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SuperscriptBox[\((1 + SubscriptBox[T, i] \[CapitalTheta][\(-\*SubscriptBox[\(T\), \(i\)]\)] \*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), SubscriptBox[\(n\), \(i\)]])\), \(m\)]\)+\!\(\*UnderscriptBox[\(\[Product]\), \(i\)]\)\!\(\*SuperscriptBox[\((1 + SubscriptBox[T, i] \[CapitalTheta][\*SubscriptBox[\(T\), \(i\)]] \*SuperscriptBox[\(\(\*SubscriptBox[\(A\), \(i\)]\)[t]\), SubscriptBox[\(n\), \(i\)]])\), \(m\)]\))";
NHCA::usage="NHCA is an uninstantiated function used to specify parameters for SSystem reactions. The canonical forms are\n{A\[RightTeeArrow]B,NHCA[v,T,n,m,k] which means "<>eq1<>" where \[CapitalTheta][u] is UnitStep[u]"<>"\n{A\[RightTeeArrow]B, NHCA[v,{TP,TM},n,m,k] which means "<>eq2<>"\nMultiple Reactions with the same product combine vectorally and are equivalent to "<>"{A1,A2,\[Ellipsis]}\[RightTeeArrow]B and A1+A2+\[Ellipsis]\[RightTeeArrow]B, as "<>eq3<>" or "<>eq4;
Remove[eq1,eq2,eq3,eq4];
Null


run::usage="run[sys, {t, tstart, tend}, options]"<>"\nrun[sys, {tstart, tend}, options]: gets t from timeVariable"<>"\nrun[sys,options]: gest times from timeSpan"<>"\n\nOptions:
\"IC\"->{}, initial conditions, Missing initial conditions are set to zero. 
initialConditions->{}.  (deprecated version of \"IC\")
\"plot\"->False -   To plot (gridplot) automatically, the option \"plot\"->True is required, and either  \"plotVariables\" or \"gridPlotVariables\" must be set to a list of variables (or All). More precise control of the format of the plots is available by using runPlot or gridPlot as a separate step.
\"gridPlotVariables\"-> {}
\"plotVariables\"->{}
\"Parameters\"->{}, values of all constants in model as a rule list. Unassigned rate constants are set to 1. 
rates-> {} (deprecated version of \"Parameters\")
\"Frozen\"->{}, list of variables whose values are held fixed
\"TimeSpan\"->100 (run duration)\ntimeVariable->Global`t\n\"BoundaryConditions\"\[Rule]{\!\(\*SubscriptBox[\(X\), \(1\)]\)[t]\[Rule]\!\(\*SubscriptBox[\(f\), \(1\)]\)[t],\!\(\*SubscriptBox[\(X\), \(2\)]\)[t]\[Rule]\!\(\*SubscriptBox[\(f\), \(2\)]\)[t], \[Ellipsis]}] - replace each of the variables \!\(\*SubscriptBox[\(X\), \(i\)]\) with the explicity function \!\(\*SubscriptBox[\(f\), \(i\)]\)\n\"Quiet\"\[Rule]True";

simulate::usage="same as run but used SBMLNDSolve and returns result in SBMLNDSolve format.";
rates::usage="rates->{} is a deprecated option for run. A list of replacement rules, typically giving the values used for parameters such as rate constants. The prefered option is \"Parameters\"\n\n"<>"rates->False is an option for lowLevelReactions. If True, the rates will also be returend.";
initialConditions::usage="initialConditions->{} is a deprecated option for run. It gives the initial conditions used in the integration. \nFormat 1: {a[0]==a0, ...}\nFormat 2: {a->a0, ...}. The prefered option is \"IC\"";
plot::usage="A deprecated option for run. The preferred option is \"plot\"->True or False.";
plotVariables::usage="A deprecated option for run. The preferred option is \"plotVariables\".";
timeSpan::usage="timeSpan->{0,100} is an option for run.\nIt is ignored unless run is invoked by run[sys, options]. \ntimeSpan->{} or not specified means {timeVariable, tstart, tend} = {Global`t, 0, 100}\ntimeSpan->x or {x} means {timeVariable, tstart, tend}={Global`t, 0, x}"<>"\ntimeSpan->{x,y} means {timeVariable, tstart, tend}={Global`t, x, y}"<>"\ntimeSpan->{z, x, y} means {timeVariable, tstart, tend} = {z, x, y}"; 
timeVariable::usage="timeVariable->Global`t is an option for run. It is the name of the time variable in the equations solved by run. ";
gridPlotVariables::usage="";
Options[run]={rates->{}, "Parameters"-> {},  
"IC"-> {}, initialConditions->{}, 
plot-> False, "plot"-> False, 
plotVariables-> {},"plotVariables"-> False,  
timeSpan->{0,100}, timeVariable-> Global`t, 
gridPlotVariables-> None, "gridPlotVariables"-> None, "Quiet"-> True, "Debug"-> False};

runPlot::usage="runPlot[sys,options] plots all variables in sys (output of interpret) for the entire solution time span.
\nrunPlot[sys,{var1,var2,...},options] plots the requested variables for the entire solution time span\nrunPlot[sys, {var1,var2,...}, {tstart, tend},options] plots the requested variables for the specified time span\n\nOptions:\nAny option for Plot or Graphics may be used.";
gridPlot::usage="gridPlot[sys, vars,{tstart, tend}, options]\nvars is either a list of variables or the symbol All.\nsys is the output of run.\n\nOptions:\n\"Columns\"->3\n\"styles\"->{},list of styles to add to each plot (same style for each plot, such as Thick or Dotted)\n\"Options\"->{PlotRange-> All}, applied to each plot\n\"Width\"-> 300 (default plot width, pixels)\n\"Aspect\"->1.0/GoldenRatio, default plot aspect ratio\nAny additional Plot options will be passed to the overall grid. ";
plotColumns::usage="";
Options[gridPlot]={plotColumns-> 3, "styles"-> {}};


arrayGridPlot::usage="arrayGridPlot[system,n, tmax, {\!\(\*SubscriptBox[\(var\), \(1\)]\),\!\(\*SubscriptBox[\(var\), \(2\)]\),...}, options]\ngenerates a grid of plots of each array on a separate plot. Then \!\(\*SubscriptBox[\(var\), \(1\)]\)[1],...,\!\(\*SubscriptBox[\(var\), \(1\)]\)[n] are plotted on the first plot, \!\(\*SubscriptBox[\(var\), \(2\)]\)[1],..,\!\(\*SubscriptBox[\(var\), \(2\)]\)[n] are plotted on the second plot, and so forth. \n\nOptions:\nplotColumns\[Rule]3.";

PhasePlot::usage="PhasePlot[solution, {v1, v2}, {tbegin, tend}, options] is a wrapper for ParametricPlot. Here solution is the output of run."; 

PredictTransferFunction::usage="PredictTransferFunction[system, {time, tbegin, tend}, {input, min, max, delta}, output, options]\nrepeatedly executes run, varying the value of input=min, min+delta, min+2delta, ..., max. \nThe symbol input may refer to either a chemical species in a reaction or a rate constant. \nThe symbol output is either the name of a single variable, or a list of variables. Returns a table in the form of a list of values of all the variables in output for each value of input.\n\nOptions:\n\"Integrate\"\[Rule]False, if True, integrates the output variables from tbegin to tend; otherwise, just returns the value of the variable.\n\"Function\"\[Rule]optional function to be applied to either the values of variable (if \"Integrate\"\[Rule]False) or the variable before integration (if \"Integrate\"\[Rule]True).\n\nPredictionTransferFunction[net, {t,0,100}, {A, 1,10, .5}, {P, Q, R}]\nreturns\n{{list-of-column-headers}\n{1, P[100], Q[100], R[100]}, \n{1.5, P[100], Q[100], R[100]},\n ...\n{10, P[100], Q[100], R[100]} "; 
ParametricVariation::usage=""; 

snapshot::usage="";

Options[BifurcationPlot]={PlotPoints->2000,PlotStyle->{Black,PointSize[0.001]}};
BifurcationPlot::usage="BifurcationPlot[f, {r, rmin, rmax}, {x, x0}, {i, ishow}, options], where f[x,r] is a function of x that depends on a parameter r, which undergoes a period doubling bifurcation between rmin and rmax; i is the total number of iterations; ishow is the number to actually show. ";

InterpolationSet::usage=""; 



vmax::usage="vmax is a Cellerator option for hill[] or NHCA[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
nhill::usage="nhill is a Cellerator option for hill[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
khalf::usage="khalf is a Cellerator option for hill[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
basalRate::usage="basalRate is a Cellerator option for hill[]. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
Thill::usage="Thill is a Cellerator option for hill[].Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
Options[hill]= {vmax-> 1, nhill-> 1, khalf-> 1, basalRate-> 0, Thill-> 1};
RGRN::usage="RGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter r (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
TGRN::usage="TGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter T (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
nGRN::usage="nGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter n (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
hGRN::usage="hGRN is a Cellerator option for GRN[]. It corresponds to the GRN positional parameter h (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance.";
Sigmoid::usage="Sigmoid is a Cellerator option for GRN[]. It represents a user-defined function, corresponding to the optional positional parameter f in GRN (see GRN). Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. In particular, user-defined sigmoids should be defined with user-defined arrows rather than the Sigmoid option. Not to be confused with the functions sigmoid, grnsigmoid, and sigma. ";
Options[GRN]={TGRN-> 1, RGRN-> 1, nGRN-> 1, hGRN-> 0, Sigmoid-> sigmoid};
grn::usage="grn is an alternate spelling for GRN[]."
TNHCA::usage="TNHCA is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
TPLUS::usage="TPLUS  is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
TMINUS::usage="TMINUS  is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
nNHCA::usage="nNHCA  is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
kNHCA::usage="kNHCA is a Cellerator option for NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
mNHCA::usage="mNHCA is a Cellerator option for  NHCA. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
Options[NHCA]={TNHCA-> 1, TPLUS-> {}, TMINUS-> {}, nNHCA-> 1, kNHCA-> 1, mNHCA-> 1, vmax-> 1};
KGMWC::usage="KGMWC is a Cellerator option for GMWC. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
cGMWC::usage="cGMWC is a Cellerator option for GMWC. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
LGMWC::usage="LGMWC is a Cellerator option for GMWC. Cellerator options may not be combined with positional parameters and are discouraged becuase they can significantly degrade performance. ";
kcatGMWC::usage="kcatGMWC is a Cellerator option for GMWC. ";
Options[GMWC]:= {KGMWC-> 1, cGMWC-> 1, LGMWC-> 1, nGMWC-> 1, kcatGMWC-> 1};


Begin["`Private`"];


(*

tovernum[u_?StringQ]:=  Module[{vs, num}, 
vs=u;
vs = StringReplace[vs,"-"\[Rule] "."]; 
While[StringLength[vs]>0,

num=StringMatchQ[vs, RegularExpression["\\d+\\.?\\d*"]];

If[num, Return[ToExpression[vs]]]; 
vs=StringDrop[vs, -1];
];
Return[0];
];
tovernum[x___]:= Return[0]; 

mver[]:= Module[{vs}, 
vs=tovernum[MathSBML`$MathSBML$Version]; 
Return[vs];
];


If[$VersionNumber>5.999 and $VersionNumber < 8, 
If[tovernum[$xlr8r$Version]>0.59, 
If[tovernum[MathSBML`$MathSBML$Version]<2.8, 
Print["Warning: this version of xlr8r requies MathSBML version 2.8 or higher. Version loaded: ", MathSBML`$MathSBML$Version];
];
]; 
]; 

If[$VersionNumber \[GreaterEqual] 8.0,
If[ToExpression[StringTake[MathSBML`$MathSBML$Version,4]]< 2.1,
Print["Warning: For this version of Mathematica, at least version 2.10 of MathSBML is required. Version found: ", MathSBML`$MathSBML$Version]
];
]

*)



MyTextStyle[x___]:= If[$VersionNumber<6, TextStyle[x], Style[x]]; 
MyStyle[x___]:= If[$VersionNumber<6, StyleForm[x], Style[x]]; 
MyDate[x___]:= If[$VersionNumber<6, Date[], DateList[]];
MyStylePrint[x___]:= If[$VersionNumber<6, StylePrint[x], Print[Style[x]]]; 
MyStyleForm[x___]:= If[$VersionNumber<6, StyleForm[x], Style[x]]; 
MyGraphicsArray[x___]:=If[$VersionNumber<6, GraphicsArray[x], 
GraphicsGrid[x]
]; 


MyFilterOptions[f_, opt___?OptionQ]:= 
If[$VersionNumber<6,
Utilities`FilterOptions`FilterOptions[f, opt]
,
Sequence@@FilterRules[Flatten[{opt}],Options[f]]
];


If[$VersionNumber<6,
 MyAngleBracket[x___]:=ToExpression["Global`AngleBracket"]@@{x};
MyRightArrowLeftArrow[x___]:=ToExpression["Global`RightArrowLeftArrow"]@@{x};
ExportXMLString[x_]:= ExportString[x, "XML", ConversionOptions-> {"AttributeQuoting"-> "\""}]
,
MyAngleBracket[x___]:=ToExpression["System`AngleBracket"]@@{x};
MyRightArrowLeftArrow[x___]:=ToExpression["System`RightArrowLeftArrow"]@@{x}; 
ExportXMLString[x_]:= ExportString[x,"XML", "AttributeQuoting"-> "\""]
]; 


Which[
$VersionNumber<6, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber ==6 \[And] $ReleaseNumber<2,
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x, "Semantics"-> True, "Presentation"-> False], 

$VersionNumber ==6 \[And] $ReleaseNumber>1, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber==7, 
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}],

$VersionNumber>7,
Xpression2SymbolicMathML[x_]:= XML`MathML`ExpressionToSymbolicMathML[x,"Formats"-> {"ContentMathML"}]


];



boldRed[x_]:=MyStyleForm[x,FontColor->RGBColor[1,0,0],FontWeight->Bold];
boldBlack[x_]:=MyStyleForm[x,FontColor->GrayLevel[0],FontWeight->Bold];
boldBlue[x_]:=MyStyleForm[x,FontColor->RGBColor[0,0,1],FontWeight->Bold];
boldGreen[x_]:=MyStyleForm[x,FontColor->RGBColor[0,1,0],FontWeight->Bold];
boldOrange[x_]:=MyStyleForm[x,FontColor->RGBColor[1,.5,0],FontWeight->Bold];


now::usage="now[] returns the date and time as a string";

now[]:=DateString[{"Day","-","MonthName", "-", "Year", " ", "Hour24",":", "Minute", ":","Second", ".", "Millisecond"}];
nower[]:=DateString[{"Day"," ","MonthName", " ", "Year", " at ", "Hour24",":", "Minute", " ", "TimeZone"}];


symbolQ[x_]:=SameQ[Head[x],Symbol];


NonIntegerQ[x_]:= Not[IntegerQ[x]]


NonListQ[x_]:= Not[ListQ[x]]


getSingleValue[k_,kdefault_,  message_,reaction_]:= Module[{K},
K=Flatten[{k}];
Switch[Length[K],
0, K=kdefault;, 
1, K=First[K];,
_,  
Print["Error: extra ",message," ",Drop[K,1], " in ", reaction," ignored."];
K=First[K];
];

Return[K];
];
getnValues[n_,v_,message_,reaction_]:= Module[{V,lastv},
V=Flatten[{v}];
lastv=Last[V];
While[Length[V]<n, V=Append[V,lastv]];
If[Length[V]>n, Print["Error: extra ",message," ",Drop[V,n]," in reaction ",reaction," ignored."];];
V=Take[V,n];
Return[V];
];
getnListValues[n_,v_,message_,reaction_]:= Module[{V,lastv},
If[ListQ[v], V=v, V={v}]; 
V=Flatten/@List/@V;

lastv=Last[V];
While[Length[V]<n, V=Append[V,lastv]];
If[Length[V]>n, Print["Error: extra ",message," ",Drop[V,n]," in reaction ",reaction," ignored."];];
V=Take[V,n];
Return[V];
];


functionArguments[f_[x___]]:= {x};


sigma[x_]:= 1/2 (1+x/Sqrt[1+x^2]);
sigmoid[x_]:= 1/(1+Exp[-x]);
grnsigmoid[x_,r_:1,T_:1, n_:1,h_:0]:= r*sigmoid[h+T*x^n];

(* The following expansion is done to handle negative exponents on hill functions near x=0. This is becausex^-n/(1+x^-n) has a 1/0 form in both the numerator and denominator, whereas the mathematically equivalent form  1/(1+x^n) has neither. The x^-n is actually part of the denominator, i.e., Matheamtica treats it as  1/(x^n(1+x^-n)), which is why this should work. *)

hillFunction[x_,K_,n_,v_, r_]:= Module[{num,den,quotient}, 
quotient=(r+v*x^n)/(K^n+x^n);
num=Expand[Numerator[quotient]]; 
den = Expand[Denominator[quotient]]; 
quotient=num/den;
Return[quotient]
]; 


BifurcationPlot[f_,{r_,a_,b_},{x_,x0_},{iter0_,iterShow_},opts___]:=Module[{sty,n,makePts,cf,rVals,data},{sty,n}={PlotStyle,PlotPoints}/.{opts}/.Options[BifurcationPlot];
makePts[{s_,v_}]:=({s,#}&)/@v;
cf=Compile[{{r,_Real,1},{x,_Real,1}},Evaluate[f]];
rVals=Range[N[a],b,(b-a)/(n-1)];
data=Transpose[{rVals,Transpose[NestList[cf[rVals,#]&,Nest[cf[rVals,#1]&,Array[x0&,n],iter0],iterShow]]}];
Graphics[Append[Flatten[{sty}],Point[Flatten[makePts/@data,1]]],Sequence@@FilterRules[{opts},Options[Graphics]],AspectRatio->1/3,Frame->True,FrameTicks->{Automatic,Range[0,1,.5],None,None},Axes->None]]


functionate[f_?StringQ,arg_:Global`t]:=Module[{tvariable, result},
tvariable=ToString[arg];
result=f<>"["<>tvariable<>"]"; 
Return[result];
]; 

functionate[f_?ListQ,arg_:Global`t]:=(functionate[#1,arg]&)/@f; 

functionate[f_,arg_:Global`t]:=Module[{g},
g=functionate[ToString[f],ToString[arg]];
Return[ToExpression[g]];
];

defunctionate[f_[t_]]:=f;
defunctionate[f_?StringQ]:=StringReplace[f,"["~~___~~"]"->""];
defunctionate[f_]:=f;


getSymbols[exp_]:=Module[{v,expr,myxml,dbg=False},expr=exp;
If[StringQ[expr],expr=ToExpression[expr]];
myxml["ci",{___},{x_}]:=x;
myxml["csymbol",___]:={};
myxml[_,{___},{z___}]:={z};
v=Xpression2SymbolicMathML[expr];
If[dbg,Print["getSymbols: v(1):",v]];
v=ToExpression/@((v/.{XMLElement->myxml})//Flatten//Union);
If[dbg,Print["getSymbols: v(2):",v]];
v=Select[v,!(NumberQ[#])&];
v=Complement[v,{If}];
If[dbg,Print["getSymbols: exp: ",exp," v: ",v];];
Return[v];
];


decontextify[x_?StringQ]:=Module[{p,q},p=StringPosition[x,"`"];
If[Length[p]<1,Return[x]];
p=Map[First,p];
p=Last[p];
q=StringDrop[x,p];
Return[q];];
decontextify[x_?ListQ]:=Map[decontextify,x];
decontextify[x_]:=Module[{s},decontextify[ToString[InputForm[x]]]//ToExpression//Return;
];

decontextify[x_?StringQ,context_?StringQ]:=StringReplace[x,{context->""}];
decontextify[x_?ListQ,context_?StringQ]:=Map[decontextify[#,context]&,x];
decontextify[x_,context_?StringQ]:=Module[{},decontextify[ToString[InputForm[x]],context]//ToExpression//Return;
];




contextify[x_?StringQ,context_: ""]:=Module[{s,c},If[x==""\[Or]x=="Indeterminate",Return[x]];
c=context;
c=ToString[c];
If[c=="None"\[Or]c=="None`" \[Or]c=="",Return[x]];
If[StringTake[c,-1]!="`",s=c<>"`"<>x,s=c<>x;];
Return[s];];
contextify[x_->y_,context_: ""]:=(contextify[x,context]->contextify[y,context]);

contextify[x_?ListQ,context_: ""]:=Map[contextify[#,context]&,x];
contextify[x_[y___],context_: ""]:=contextify[x,context][y];
contextify[x_,context_: ""]:=Module[{},If[ToString[Head[x]]=="Symbol",contextify[ToString[x],context]//ToExpression//Return;];
Print["Error: "//boldRed,"contextify: "//boldBlue,"The argument to contextify must be a string or a symbol; argument used: "//boldBlack,x//boldRed];
Return[x];];



nonOptionQ[x_]:=Not[OptionQ[x]];


stringer[x_]:=If[StringQ[x],x,ToString[InputForm[x]]];


argument[f_[x_]]:=x;



reactionStoich[LHS_, RHS_]:= Module[{input, output, netStoichiometry, species, stoics}, 
input=parseReactants[True,LHS];
output=parseReactants[True, RHS];

species=Union[First/@input, First/@output]; 

netStoichiometry[x_]:= Module[{in,out},
in = Cases[input,{x,_}];
If[Length[in]<1, 
in = 0, 
in = Transpose[in];
in=Plus@@in[[2]];
];

out=Cases[output,{x,_}];
If[Length[out]<1, 
out = 0, 
out = Transpose[out];
out=Plus@@out[[2]];
];
(out-in)
];
stoics = netStoichiometry/@species;
{species, stoics}
];
reactionStoich[other___]:=( Print["Error:ReactionStoich."]; Abort[];)


parseArrowForm[{ShortRightArrow[substrateExpression_,productExpression_ ],Flux[stuff__]}]:= Module[{parseExpression, reaction, input, output, klaw,stoics, species, nspecies, dbg=False, netStoichiometry, rates,odes, k},

reaction = ShortRightArrow[substrateExpression,productExpression];
If[dbgArrows,Print["parseArrowForm:", reaction]]; 

{reaction,k}=expandArrows[{reaction,Flux[stuff]}][[1]];
{species, stoics} = reactionStoich[substrateExpression, productExpression]; 

rates = k*stoics;


If[dbg,
 Print["input stoichiometry:",input]; 
Print["klaw=",klaw];
Print["output stoichiometry:",output];
Print["species:", species];
Print["rates:",rates];
];

odes = {species,rates}//Transpose;

If[dbg, Print["------------------------------------------>Flux Model: ", odes]];

Return[odes];
]


expandArrows[{ShortRightArrow[substrateExpression_,productExpression_ ],Flux[stuff__]}]:= Module[{reaction, k, lhs, rhs, input,denominator, dbg=False},

lhs = ListToSum[substrateExpression]; 
rhs=ListToSum[productExpression]; 
reaction = ShortRightArrow[lhs,rhs];
input=parseReactants[True,substrateExpression];
denominator = Times@@Map[Power@@#&,input];



k={stuff}//Flatten;
If[dbg,Print["expandArrows:", reaction, " k=", k]]; 

If[Length[k]<2, 
(iFluxArrows = iFluxArrows+1; 
k = Unique["v"<>ToString[iFluxArrows]]; 
Print["Error: no flux variable given for Flux Reaction ", reaction, " using ", k]; 
)
,
k = k[[2]]
]; 

Return[{{reaction,k/denominator}}];
]


ListToSum[x_]:= Plus@@Flatten[{x/.{Plus->List}}];


setBinding[A_, B_]:= Module[{r1,r2},
{r1,r2}=Sort[{A,B}];
Return[Bind[r1,r2]];
]; 


parseReactants[functionForm_,Plus[x___]]:= Module[{r, parseStoichiometry},

If[functionForm,
parseStoichiometry[Times[n?NumberQ,var_]]:= {var[Global`t],n};
parseStoichiometry[Times[var_,n_?NumberQ]]:= {var[Global`t],n};
parseStoichiometry[var_]:= {var[Global`t],1};
,
parseStoichiometry[Times[n?NumberQ,var_]]:= {var,n};
parseStoichiometry[Times[var_,n_?NumberQ]]:= {var,n};
parseStoichiometry[var_]:= {var,1};
];

r=Plus[x]/.{Plus-> List};
If[!ListQ[r], r={r}];
r = parseStoichiometry/@r;
If[functionForm,
r=Complement[r,{{Global`\[EmptySet][Global`t],1}}];,
r=Complement[r,{{Global`\[EmptySet],1}}]; 
];

Return[r];
]; 

parseReactants[x__]:= Module[{},
Print["Unable to parse the expression:", x, " in the reaction ", reaction]; 
Abort[];
]; 


expandArrows[{ShortRightArrow[substrateExpression_,productExpression_] ,rate___:1}]:= Module[{reaction, k},

reaction = substrateExpression\[ShortRightArrow]productExpression;
If[dbgArrows,Print["expandArrows:", reaction]]; 

k={rate}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 
Return[{{reaction,k}}];
]


expandArrows[{ShortRightArrow[substrateExpression_,productExpression_ ],rate___:1}]:= Module[{reaction, k, lhs, rhs},

lhs = ListToSum[substrateExpression]; 
rhs=ListToSum[productExpression]; 
reaction = ShortRightArrow[lhs,rhs];
If[dbgArrows,Print["expandArrows:", reaction]]; 

k={rate}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 
Return[{{reaction,k}}];
]


parseArrowForm[{ShortRightArrow[substrateExpression_,productExpression_ ],rate___:1}]:= Module[{parseExpression, reaction, input, output, klaw,species, nspecies, dbg=False, netStoichiometry, rates,odes, k},

reaction = ShortRightArrow[substrateExpression,productExpression];
If[dbgArrows,Print["parseArrowForm:", reaction]]; 

{reaction,k}=expandArrows[{reaction,rate}][[1]];

If[dbg, Print["reaction: " ,reaction, "\nsubstrateExpression: ", substrateExpression, "\nproductExpression: ", productExpression]]; 

input=parseReactants[True,substrateExpression];
output=parseReactants[True, productExpression];
klaw=k*Times@@Map[Power@@#&,input];
klaw = klaw/.{Global`\[EmptySet][Global`t]-> 1};

If[dbg, Print["input: ", input,"\noutput:", output, "\nklaw: ", klaw]]; 

netStoichiometry[x_]:= Module[{in,out},
in = Cases[input,{x,_}];
If[Length[in]<1, 
in = 0, 
in = Transpose[in];
in=Plus@@in[[2]];
];

out=Cases[output,{x,_}];
If[Length[out]<1, 
out = 0, 
out = Transpose[out];
out=Plus@@out[[2]];
];

Return[out-in];

]; (* end netStoichiometry *)

species=Union[First/@input, First/@output]; 
rates=klaw*netStoichiometry/@species;

If[dbg,
Print["input stoichiometry:",input];
Print["klaw=",klaw];
Print["output stoichiometry:",output];
Print["species:", species];
Print["rates:",rates];
];

odes = {species,rates}//Transpose;
Return[odes];
]


expandArrows[{RightArrowLeftArrow[X_,Y_ ],k___}]:= Module[{forward, reverse,kf,kr,rates,reaction},
reaction={RightArrowLeftArrow[X,Y],k};
If[dbgArrows,Print["expandArrows:", reaction]];
rates=Flatten[{k}];
While[Length[rates]<2, rates=Append[rates,1]];
If[Length[rates]>2, Print["Warning: extra rate constants ", Drop[rates,2]," in the reaction ", reaction, " will be ignored."]]; 
rates=Take[rates,2];
{kf,kr}=rates;

forward={ShortRightArrow[X, Y],kf};
reverse={ShortRightArrow[Y,X],kr};
If[dbgArrows,Print["expandArrows:", {forward, reverse}]];

Return[{forward, reverse}];
]


parseArrowForm[{RightArrowLeftArrow[X_,Y_ ],k___}]:= Module[{forward, reverse, odes,reaction},
reaction={RightArrowLeftArrow[X,Y],k};
{forward, reverse}=parseArrowForm/@expandArrows[reaction];
odes = Join[forward, reverse];
Return[odes];
]


expandArrows[{ShortRightArrow[X_,Y_ , Z__],rates___}]:= Module[{ reaction,reactants, k, nreactions,reactions, nrates},

reactants={X,Y,Z};
reaction={ShortRightArrow@@reactants,rates};
If[dbgArrows,Print["parseArrowForm:", reaction]];

reactions=Partition[reactants,2,1];
nreactions=Length[reactions];

k={rates};
If[Length[k]>nreactions,
 Print["Warning: Extra rate constants ", Drop[k,nreactions]," in the reaction ", reaction, " will be ignored."]; 
k=Take[k,nreactions]
];
k=PadRight[k,nreactions,1];
reactions=MapThread[{ShortRightArrow@@#1,#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{ShortRightArrow[X_,Y_ , Z__],rates___}]:= Module[{ odes,reactions},
reactions=expandArrows[{ShortRightArrow[X,Y, Z],rates}];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{RightArrowLeftArrow[X_,Y_ , Z__],rates___}]:= Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates},

reactants={X,Y,Z};
reaction={RightArrowLeftArrow@@reactants,rates};
If[dbgArrows,Print["expandArrows:", reaction]];

reactions=Partition[reactants,2,1];
nreactions=Length[reactions];

k={rates};
If[Length[k]>2*nreactions,
 Print["Warning: Extra rate constants ", Drop[k,2*nreactions]," in the reaction ", reaction, " will be ignored."]; 
k=Take[k,2*nreactions]
];
k=PadRight[k,2*nreactions,1];
k=Partition[k,2];
reactions=MapThread[{RightArrowLeftArrow@@#1,Sequence@@#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{RightArrowLeftArrow[X_,Y_ , Z__],rates___}]:= Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates},
reactions=expandArrows[{RightArrowLeftArrow[X,Y , Z],rates}];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Overscript[ShortRightArrow[X_,Y_ ],Z_],rates___}]:= Module[{reaction,k},
reaction={Overscript[ShortRightArrow[X,Y],Z],rates};
If[dbgArrows,Print["expandArrows:", reaction]];

k={rates}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 

reaction={ShortRightArrow[X+Z, Y+Z],k};
Return[{reaction}];
]


parseArrowForm[{Overscript[ShortRightArrow[X_,Y_ ],Z_],rates___}]:= Module[{ odes,reaction},
reaction=expandArrows[{Overscript[ShortRightArrow[X,Y],Z],rates}];
odes=parseArrowForm[reaction];
Return[odes];
]


expandArrows[{Overscript[ShortRightArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ reaction,reactants, k, nreactions,reactions, nrates,modifierList,nmods,m1},

reactants={X,Y,Z};
reaction={Overscript[ShortRightArrow@@reactants,modifiers],rates};
If[dbgArrows,Print["expandArrows:", reaction]];
modifierList={modifiers}//Flatten;
If[Length[modifierList]<1, Print["Error: At least one modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[modifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[modifierList,nreactions]," in the reation ", reaction," will be ignored."];
modifierList=Take[modifierList,nreactions];
];
m1=First[modifierList];
(* modifierList=PadRight[modifierList,nreactions, m1];*)
While[Length[modifierList]<nreactions, AppendTo[modifierList, m1]];

k={rates};
If[Length[k]>nreactions,
 Print["Warning: Extra rate constants ", Drop[k,nreactions]," in the reaction ", reaction, " will be ignored."]; 
k=Take[k,nreactions]
];
k=PadRight[k,nreactions,1];
reactions=MapThread[{Overscript[ShortRightArrow@@#1,#2],#3}&,{reactions,modifierList,k}];
reactions=Join@@(expandArrows/@reactions);
Return[reactions];
]


parseArrowForm[{Overscript[ShortRightArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reactions},
reactions=expandArrows[{Overscript[ShortRightArrow[X,Y, Z],modifiers],rates}];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Overscript[RightArrowLeftArrow[X_,Y_ ],En_],k___}]:= 
Module[{a,d,kf,kr,r1,r2,r3,r4, reactions, rates},
reaction={Overscript[RightArrowLeftArrow[X,Y],En],k};
If[dbgArrows,Print["expandArrows (single input):", reaction]];

rates={k}//Flatten;
While[Length[rates]<3, rates=Append[rates,1]];
While[Length[rates]<4, rates=Append[rates,0]];
If[Length[rates]>4, Print["Warning: the extra rate constants ",Drop[rates,4]," will be ignored in the reaction ",reaction];
]; 
rates=Take[rates,4];
{a,d,kf,kr}=rates;
If[dbgArrows,Print["expandArrows (single rates):", rates]];
If[dbgArrows,Print["expandArrows single (X, Length[X], Y, Length[Y]):",{X, Length[X], Y, Length[Y]}]];
If[dbgArrows,Print["expandArrows single (X, Length[X/.{Plus\[Rule] List}], Y, Length[Y/.{Plus\[Rule] List}]):",{X, Length[X/.{Plus-> List}], Y, Length[Y/.{Plus-> List}]}]];

If[Length[({X}//Flatten)/.{Plus-> List}]>1 \[Or] Length[({Y}//Flatten)/.{Plus-> List}]>1, 
Print["The reaction ",Overscript[RightArrowLeftArrow[X,Y],En]," is not correctly formatted: too many reactants or products."];
Return[{}];
];
r1={ShortRightArrow[X+En,setBinding[X,En]],a};
r2={ShortRightArrow[setBinding[X,En], X+En],d};
r3={ShortRightArrow[setBinding[X,En], Y+En],kf};
reactions={r1,r2,r3};
If[\[Not](kr===0),
r4={ShortRightArrow[Y+En,setBinding[X,En]],kr};
reactions=Append[reactions,r4];
]; 
If[dbgArrows,Print["expandArrows (single: return reactions):", reactions]];
Return[reactions];
];


parseArrowForm[{Overscript[RightArrowLeftArrow[X_,Y_ ],En_],k___}]:= 
Module[{reaction,reactions,odes},
reaction={Overscript[RightArrowLeftArrow[X,Y],En],k};
reactions = expandArrows[reaction];
odes =Join@@( parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{Overscript[RightArrowLeftArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates,modifierList,nmods,m1,lastset},

reactants={X,Y,Z};
reaction={Overscript[RightArrowLeftArrow@@reactants,modifiers],rates};
If[dbgArrows,Print["expandArrows (cascade):", reaction]];

modifierList={modifiers}//Flatten;
If[dbgArrows,Print["expandArrows (cascade: modifierList):", modifierList]];
If[Length[modifierList]<1, Print["Error: At least one modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[modifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[modifierList,nreactions]," in the reation ", reaction," will be ignored."];
modifierList=Take[modifierList,nreactions];
];
m1=Last[modifierList];
(* modifierList=PadRight[modifierList,nreactions, m1]; *)
While[Length[modifierList]<nreactions, AppendTo[modifierList, m1]];


If[dbgArrows,Print["expandArrows (cascade: modifierList):", modifierList]];


k={rates}//Flatten;
If[Length[k]==0, k={1,1,1,0}];
If[Length[k]<3, k=PadRight[k,3,1]];
If[Length[k]<4, k=PadRight[k,4,0]];
If[Length[k]>4*nreactions, k=Take[k,4*nreactions]]; 
If[Mod[Length[k],4]!= 0,
While[Mod[Length[k]+1,4]!= 0, k=Append[k,1]]; 
k=Append[k,0];
];
lastset=Take[k,-4];
While[Length[k]<4*nreactions,k=Join[k,lastset]];  
k=Flatten[k]; 


k = Partition[k,4];
reactions=MapThread[{Overscript[RightArrowLeftArrow@@#1,#2],Sequence@@#3}&,{reactions,modifierList,k}];
reactions=Join@@(expandArrows/@reactions);
Return[reactions];
]


parseArrowForm[{Overscript[RightArrowLeftArrow[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactions},
reactants={X,Y,Z};
If[dbgArrows, Print["*** parseArrowForm (cascade): {reactants}:", {reactants}]];
reaction={Overscript[RightArrowLeftArrow@@reactants,modifiers],rates};
If[dbgArrows, Print["*** parseArrowForm (cascade): {reaction}:", {reaction}]];
reactions=expandArrows[reaction];
If[dbgArrows, Print["*** parseArrowForm (cascade): {reactions}:", {reactions}]];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Underoverscript[RightArrowLeftArrow[X_,Y_ ],Rev_,Fwd_],k___}]:= 
Module[{nk,nrk,k1,k2,r1,r2, reactions,rates,reaction,nrates,
defrates={1,1,1,0,1,1,1,0}}, 
reaction={Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],k};
If[dbgArrows,Print["expandArrows:", reaction]];

rates=Flatten[{k}];
nk=Length[Flatten[rates]];

If[!(nk==6 \[Or]nk==8),
nrates=Take[rates,Min[8,nk]];
nrk=Length[nrates];
If[nrk<8, nrates=Join[nrates,Drop[defrates,nrk]]]; 

Print["Unable to unambiguously parse the rate constants in the reaction :",{ Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],Sequence@@rates}," ", nk, " rates were found; the number of rates should be either 6 or 8; the following values were used instead: ",{ Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],Sequence@@nrates}];
rates=nrates;
nk=Length[rates];
];
k1=Take[rates, nk/2];
k2=Drop[rates,nk/2];

r1={Overscript[RightArrowLeftArrow[X,Y],Fwd],Sequence@@k1};
r2={Overscript[RightArrowLeftArrow[Y,X],Rev],Sequence@@k2};

reactions=Join@@expandArrows/@{r1,r2};

Return[reactions];
];


parseArrowForm[{Underoverscript[RightArrowLeftArrow[X_,Y_ ],Rev_,Fwd_],k___}]:= 
Module[{nk,nrk,k1,k2,r1,r2, odes,rates,reaction,nrates,
defrates={1,1,1,0,1,1,1,0}}, 
reaction={Underoverscript[RightArrowLeftArrow[X,Y],Rev,Fwd],k};
reactions=expandArrows[reaction];
odes = Join@@parseArrowForm/@reactions;
Return[odes];
];


expandArrows[{Underoverscript[RightArrowLeftArrow[X_,Y_ , Z__],bottomModifiers_,topModifiers_],rates___}]:= 
Module[{ reaction,reactants, k, nreactions,reactions, nrates,bottommodifierList,topmodifierList,nmod,lastset,m1, dbg=False, dPrint},

dPrint[x___]:= If[dbg, Print["expandArrows: ", x]]; 

reactants={X,Y,Z};
reaction={Underoverscript[RightArrowLeftArrow@@reactants,bottomModifiers,topModifiers],rates};
If[dbgArrows,Print["expandArrows (cascade):", reaction]];
topmodifierList={topModifiers}//Flatten;
bottommodifierList={bottomModifiers}//Flatten;
dPrint["top:", topmodifierList]; 
dPrint["bottom:", bottommodifierList]; 
If[Length[topmodifierList]<1, Print["Error: At least one forward modifier must be specified for:",reaction];
Return[{}]
];
If[Length[bottommodifierList]<1, Print["Error: At least one reverse modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[topmodifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[topmodifierList,nreactions]," in the reation ", reaction," will be ignored."];
topmodifierList=Take[topmodifierList,nreactions];
];
nmod=Length[bottommodifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[bottommodifierList,nreactions]," in the reation ", reaction," will be ignored."];
bottommodifierList=Take[bottommodifierList,nreactions];
];
dPrint["nmod: ", nmod]; 

m1=Last[bottommodifierList];
dPrint["m1 (bottom):", m1]; 

(* bottommodifierList=PadRight[bottommodifierList,nreactions, m1];*)
While[Length[bottommodifierList]<nreactions, AppendTo[bottommodifierList, m1]];
dPrint["bottom: ", bottommodifierList]; 

m1=Last[topmodifierList];
dPrint["m1 (top):", m1]; 
(* topmodifierList=PadRight[topmodifierList,nreactions, m1]; *)
While[Length[topmodifierList]<nreactions, AppendTo[topmodifierList, m1]];
dPrint["top: ", topmodifierList]; 

k={rates};
If[Length[k]==0, k={1,1,1,0,1,1,1,0}]; 
If[Length[k]==6, k=Join[Take[k,3],{0}, Take[k,-3],{0}]]; 
If[Length[k]<3, k=PadRight[k,3,1]]; 
If[Length[k]<4, k=PadRight[k,4,0]];
If[Length[k]<7, k=PadRight[k,7,1]];
If[Length[k]<8, k=PadRight[k,8,0]];

If[Mod[Length[k],6]==0 \[And] Length[k]!= 8*nreactions, 
If[Mod[Length[k],8]==0,
Print["Warning: unable to unambiguously parse the rates constants for ", reaction];
]; 
If[Length[k]>6*nreactions, k=Take[k, 6*nreactions]]; 

lastset=Take[k,-6];
While[Length[k]<6*nreactions, k=Join[k,lastset]]; 
k=Flatten[k];
k=Partition[k,3];
k=Map[Append[#,0]&,k]//Flatten;
,
If[Mod[Length[k],8]==0, 


If[Length[k]>8*nreactions, k=Take[k,8*nreactions]]; 
lastset=Take[k,-8];
While[Length[k]<8*nreactions,k=Join[k,lastset]]; 
k=Flatten[k];
,
Print["Warning: unable to unambiguously parse the rate constsnt for ", reaction]; 
If[Length[k]>8*nreactions,k=Take[k,8*nreactions]]; 
k=PadRight[k,8*nreactions];
];
]; 



k = Partition[k,8];
dPrint["k=",k ]; 

(* the following line revised 0.74 to remove application of Sequence@@ to #2 and #3 which was a bug*)

reactions=MapThread[{Underoverscript[RightArrowLeftArrow@@#1,#2, #3], Sequence@@#4}&,{reactions,bottommodifierList,topmodifierList,k}];

dPrint["reactions: ", reactions]; 

reactions=Join@@expandArrows/@reactions;
Return[reactions];
]


parseArrowForm[{Underoverscript[RightArrowLeftArrow[X_,Y_ , Z__],bottomModifiers_,topModifiers_],rates___}]:= 
Module[{ odes,reaction,reactants, reactions},

reactants={X,Y,Z};reaction={Underoverscript[RightArrowLeftArrow@@reactants,bottomModifiers,topModifiers],rates};
reactions = expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Overscript[Equilibrium[X_,Y_ ],En_],k___}]:= 
Module[{a,d,kf,kr,r1,r2,r3, reactions, rates,nrates, XEN, YEN},
reaction={Overscript[Equilibrium[X,Y],En],k};
If[dbgArrows,Print["expandArrows:", reaction]];

rates={k}//Flatten;
nrates=Length[rates];
If[nrates<6, Print["Missing rate constants in the reaction ", reaction," set to a value of 1"]]; 
If[Length[rates]>6,
Print["The extra rate constants ",Drop[rates,6]," in the reaction ", reaction, " will be ignored."];
];
rates=PadRight[rates,6,1];
rates=Take[rates,6];
{a,d,k1,k2, kf,kr}=rates;

If[Length[X/.{Plus-> List}]>1 \[Or] Length[Y/.{Plus-> List}]>1, 
Print["The reaction ",Overscript[Equilibrium[X,Y],En]," is not correctly formatted: too many reactants or products."];
Return[{}];
];

XEN=setBinding[X, En];
YEN=setBinding[Y,En];

r1={RightArrowLeftArrow[X+En,XEN],a,d};
r2={RightArrowLeftArrow[XEN, YEN],k1,k2};
r3={RightArrowLeftArrow[YEN, Y+En],kf,kr};

reactions=Join@@(expandArrows/@{r1,r2,r3});
Return[reactions];
];


parseArrowForm[{Overscript[Equilibrium[X_,Y_ ],En_],k___}]:= 
Module[{reaction, odes},
reaction={Overscript[Equilibrium[X,Y],En],k};
odes = Join@@(parseArrowForm/@expandArrows[reaction]);
Return[odes];
];


expandArrows[{Overscript[Equilibrium[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactants, k, nreactions,reactions, nrates,modifierList,nmods,m1},

reactants={X,Y,Z};
reaction={Overscript[Equilibrium@@reactants,modifiers],rates};
If[dbgArrows,Print["expandArrows:", reaction]];
modifierList={modifiers}//Flatten;
If[Length[modifierList]<1, Print["Error: At least one modifier must be specified for:",reaction];
Return[{}]
];
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nmod=Length[modifierList];
If[nmod>nreactions, Print["Warning: Extra modifiers ", Drop[modifierList,nreactions]," in the reation ", reaction," will be ignored."];
modifierList=Take[modifierList,nreactions];
];
m1=Last[modifierList];
(* modifierList=PadRight[modifierList,nreactions, m1];*)
While[Length[modifierList]<nreactions, AppendTo[modifierList, m1]];


k={rates};

k={rates}//Flatten;

If[Length[k]==0, 
Print["Warning: missing rate constants in the reaction ",reaction, " set to default values."]; 
k={1,1,1,1,1,1}]; 
If[Length[k]>6*nreactions,
Print["Warning: the extra rate constants ",Drop[k,6*nreactions]," in the reaction ",reaction," will be ignored."];
k=Take[k,6*nreactions];
];

If[Mod[Length[k],6]!= 0,
Print["Warning: Only ",Length[k]," or the required ",6*nreactions," rate constants found for the reaction ", reaction, " Default assumptions will be applied to determine the missing rates."];
While[Mod[Length[k],6]!= 0, k=Append[k,1]]; 
];
If[Length[k]<6*nreactions,
last6=Take[k,-6];
While[Length[k]<6*nreactions, k=Join[k,last6]]; 
];
k=Partition[Flatten[k],6];
reactions=MapThread[{Overscript[Equilibrium@@#1,#2],Sequence@@#3}&,{reactions,modifierList,k}];
reactions=Join@@(expandArrows/@reactions);
Return[reactions];
]


parseArrowForm[{Overscript[Equilibrium[X_,Y_ , Z__],modifiers_],rates___}]:= 
Module[{ odes,reaction,reactions},

reactants={X,Y,Z};
reaction={Overscript[Equilibrium@@reactants,modifiers],rates};
reactions = expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
]


expandArrows[{Rule[x_,y_], rates___}]:= 
Module[{r, reactants, products},

reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=expandArrows[{r,rates}];
Return[r];
]


parseArrowForm[{Rule[x_,y_],rates___}]:= 
Module[{r, reactants, products},
reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=parseArrowForm[{r,rates}];
Return[r];
]


expandArrows[{Overscript[Rule[x_,y_], z_], rates___}]:= 
Module[{r, reactants, products},
reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=expandArrows[{Overscript[r,z],rates}];
Return[r];
]


parseArrowForm[{Overscript[Rule[x_,y_],z_],rates___}]:= 
Module[{r, reactants, products},
reactants  = ListToSum[x]; 
products  = ListToSum[y]; 

r=Rule[reactants,products];
r=ShortRightArrow@@((r/.{Rule-> List})//Flatten);
r=parseArrowForm[{Overscript[r,z],rates}];
Return[r];
]


expandArrows[{DoubleLongRightArrow[X_,Y_ ],MM[rates__]}]:= 
Module[{odes,rateLaw, r},
r={rates};
While[Length[r]<2, AppendTo[r,1]]; 
If[Length[r]>3, r=Take[r,3]]; 

reaction={DoubleLongRightArrow[X,Y],MM[Sequence@@r]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];


parseArrowForm[{DoubleLongRightArrow[X_,Y_ ],MM[rates__]}]:= 
Module[{odes,rateLaw, r, KD, v, k1,k2,k3},
reaction={Overscript[DoubleLongRightArrow[X,Y],En],MM[rates]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
r={rates};
If[Length[r]==2, {KD,v}=r]; 
If[Length[r]==3, {k1,k2,k3}=r; KD=(k2+k3)/k1; v=k1]; 


rateLaw=v*X[Global`t]/(KD+X[Global`t]);
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes={{X[Global`t],-rateLaw},{Y[Global`t], rateLaw}};
Return[odes];
];


expandArrows[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[KD_:1,v_:1]}]:= 
Module[{reaction},
reaction={Overscript[DoubleLongRightArrow[X,Y],En],MM[KD,v]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];


parseArrowForm[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[KD_:1,v_:1]}]:= 
Module[{odes,rateLaw},
reaction={Overscript[DoubleLongRightArrow[X,Y],En],MM[KD,v]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

rateLaw=v*X[Global`t]En[Global`t]/(KD+X[Global`t]);
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes={{X[Global`t],-rateLaw},{Y[Global`t], rateLaw}, {En[Global`t],0}};
Return[odes];
];


expandArrows[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[k1_,k2_, k3_]}]:= 
Module[{reaction},
reaction=expandArrows[{Overscript[DoubleLongRightArrow[X,Y],En],MM[(k2+k3)/k1, k3]}];
Return[reaction];
];


parseArrowForm[{Overscript[DoubleLongRightArrow[X_,Y_ ],En_],MM[k1_,k2_, k3_]}]:= 
Module[{odes},
odes=parseArrowForm[{Overscript[DoubleLongRightArrow[X,Y],En],MM[(k2+k3)/k1, k3]}];
Return[odes];
];


expandArrows[{DoubleLongLeftRightArrow[X_,Y_ ],MM[k___]}]:= 
Module[{reactions ,r1,r2, rates, reaction,K1,K2,v1,v2},
rates={k}//Flatten;
reaction={DoubleLongLeftRightArrow[X,Y],MM[Sequence@@rates]};
If[Length[rates]>4, Print["The extra rates ",Drop[rates,4]," in the reaction ", reaction, " will be ignored."]];

While[Length[rates]<4, rates=Append[rates,1]];
rates=Take[rates,4];
{K1,v1,K2,v2}=rates;


r1={DoubleLongRightArrow[X,Y],MM[K1,v1]};
r2={DoubleLongRightArrow[Y,X],MM[K2,v2]};

reactions={r1,r2};
Return[reactions];
];


parseArrowForm[{DoubleLongLeftRightArrow[X_,Y_ ],MM[k___]}]:= 
Module[{odes ,rates, reaction,reactions},
rates={k}//Flatten;
reaction={DoubleLongLeftRightArrow[X,Y],MM[Sequence@@rates]};
reactions=expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{Underoverscript[DoubleLongLeftRightArrow[X_,Y_ ],REn_,FEn_],MM[k___]}]:= 
Module[{ r1,r2,rates, reaction, kf, kr,n, reactions},
rates=Flatten[{k}];
reaction={Underoverscript[DoubleLongLeftRightArrow[X,Y],REn,FEn], MM@@rates};
n=Length[rates];
Switch[n,
4,
kf=Take[rates,2];
kr=Drop[rates,2];
,
6,
kf=Take[rates,3];
kr=Drop[rates,3];
,
_
, 
Print["The reaction ",reaction," should have precisely 4 or 6 rate constants."]; 
Return[{}];
];

r1={Overscript[DoubleLongRightArrow[X,Y],FEn], MM@@kf};
r2={Overscript[DoubleLongRightArrow[Y,X],REn],MM@@kr};
reactions={r1,r2};
Return[reactions];
];


parseArrowForm[{Underoverscript[DoubleLongLeftRightArrow[X_,Y_ ],REn_,FEn_],MM[k___]}]:= 
Module[{odes ,rates, reaction,reactions},
rates=Flatten[{k}];
reaction={Underoverscript[DoubleLongLeftRightArrow[X,Y],REn,FEn], MM@@rates};
reactions = expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{DoubleLongRightArrow[X_,Y_ ,Z__],MM[rates___]}]:= Module[{reactants, reactions,nreactions,k,reaction,default},
reaction = {DoubleLongRightArrow[X,Y,Z],MM[rates]};
reactants={X,Y,Z};
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nreactants=Length[reactants];
reactions=DoubleLongRightArrow@@#&/@reactions;
k={rates}//Flatten;
Switch[Length[k],
0,
k=Table[{},{nreactions}],
2,
default=k;
While[Length[k]<2*nreactions,k=Join[k,default]];
k=Partition[k,2];
,
2*nreactions,k=Partition[k,2],
_,
If[Length[k]<2*nreactions,
Print["Error: Some (possibly incorrect) assumptions were made to determine the missing rate constants in the reaction ", reaction];
If[OddQ[Length[k]],k=Append[k,1]];
default=Take[k,-2];
While[Length[k]<2*nreactions,k=Join[k,default]];
,
Print["Error: extra rate constants ",Drop[k,2*nreactions]," ignored in the reaction ",reaction];
k=Take[k,2*nreactions];
];
k=Partition[k,2];
];
reactions=MapThread[{#1,MM@@#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{DoubleLongRightArrow[X_,Y_ ,Z__],MM[rates___]}]:= Module[{ reactions,reaction,odes},
reaction = {DoubleLongRightArrow[X,Y,Z],MM[rates]};
reactions=expandArrows[reaction];
odes=Join@@(parseArrowForm/@reactions);
Return[odes];
];


expandArrows[{Overscript[DoubleLongRightArrow[X_,Y_ ,Z__],\[ScriptCapitalE]_], MM[rates___]}]:= Module[{reactants, reactions,nreactions,k,reaction,default,modifiers},
reaction = {Overscript[DoubleLongRightArrow[X,Y,Z],\[ScriptCapitalE]],MM[rates]};
reactants={X,Y,Z};
reactions=Partition[reactants,2,1];
nreactions=Length[reactions];
nreactants=Length[reactants];
reactions=DoubleLongRightArrow@@#&/@reactions;
modifiers={\[ScriptCapitalE]}//Flatten;
default=Last[modifiers];
If[Length[modifiers]>nreactions, Print["Warning: excess modifiers ",Drop[modifiers,nreactions]," ignored in the reaction ",reaction]];
modifiers=PadRight[modifiers,nreactions,default];
modifiers=Take[modifiers,nreactions];
reactions = MapThread[Overscript,{reactions,modifiers}];

k={rates}//Flatten;
Switch[Length[k],
0,k=Table[{},{nreactions}],

2,
default=k;
While[Length[k]<2*nreactions,k=Join[k,default]];
k=Partition[k,2];
,

3,
default=k;
While[Length[k]<3*nreactions,k=Join[k,default]];
k=Partition[k,3];
,

2*nreactions,k=Partition[k,2],


3*nreactions,k=Partition[k,3],

_,

Print["Warning: Unable to unambiguously parse the rate constants in the reaction ", reaction];

If[Length[k]<2*nreactions,
If[OddQ[Length[k]],k=Append[k,1]];
default=Take[k,-2];
While[Length[k]<2*nreactions,k=Join[k,default]];
,
k=Take[k,2*nreactions];
];



k=Partition[k,2];
];
reactions=MapThread[{#1,MM@@#2}&,{reactions,k}];
Return[reactions];
]


parseArrowForm[{Overscript[DoubleLongRightArrow[X_,Y_ ,Z__],\[ScriptCapitalE]_], MM[rates___]}]:= Module[{ reactions,reaction,odes},
reaction = {Overscript[DoubleLongRightArrow[X,Y,Z],\[ScriptCapitalE]],MM[rates]};

reactions = expandArrows[reaction];
odes=Join@@( parseArrowForm/@reactions);
Return[odes];

];



expandArrows[{DoubleLongRightArrow[{{Activator__}, {Inhibitor__}}, product_], rational[{act__}, {inh__}]}]:= 
expandArrows[{DoubleLongRightArrow[{{Activator}, {Inhibitor}}, product], rational[{act}, {inh}, Table[1, {Length[{Activator}]}], Table[1, {Length[{Inhibitor}]}]]}]; 

expandArrows[{DoubleLongRightArrow[{{Activator__}, {Inhibitor__}}, product_], rational[{act__}, {inh__}, {n__}]}]:= 
expandArrows[{DoubleLongRightArrow[{{Activator}, {Inhibitor}}, product], rational[{act}, {inh}, {n},Table[1, {Length[{Inhibitor}]}]]}]; 

expandArrows[{DoubleLongRightArrow[{{Activator__}, {Inhibitor__}}, product_], rational[{act__}, {inh__}, {n__},{m__}]}]:= 
Module[{reaction, acts, NA, NI, inhs, nvals, mvals},
NA = Length[{Activator}]; NI=Length[{Inhibitor}]; 
acts = {act};While[Length[acts]<= NA, AppendTo[acts,1]];  acts=Take[acts,NA+1];
inhs={inh}; While[Length[inhs]<= NI, AppendTo[inhs, 1]]; inhs=Take[inhs, NI+1];
nvals={n}; While[Length[nvals]<NA, AppendTo[nvals, 1]];  nvals=Take[nvals,NA];
mvals={m}; While[Length[mvals]<NI, AppendTo[mvals, 1]]; mvals=Take[mvals, NI]; 

reaction={DoubleLongRightArrow[{{Activator}, {Inhibitor}}, product], rational[acts, inhs, nvals, mvals]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{DoubleLongRightArrow[x___],rational[y___]}]:= Module[{},
Print["Error: invalid format for rational function activation."];
Return[{}]
]; 


parseArrowForm[{DoubleLongRightArrow[{{Activator__}, {Inhibitor__}}, product_], rational[{act__}, {inh__}]}]:= 
parseArrowForm[{DoubleLongRightArrow[{{Activator}, {Inhibitor}}, product], rational[{act}, {inh}, {1},{1}]}];

parseArrowForm[{DoubleLongRightArrow[{{Activator__}, {Inhibitor__}}, product_], rational[{act__}, {inh__}, {n__}]}]:= 
parseArrowForm[{DoubleLongRightArrow[{{Activator}, {Inhibitor}}, product], rational[{act}, {inh}, {n},{1}]}];

parseArrowForm[{DoubleLongRightArrow[{{Activator__}, {Inhibitor__}}, product_], rational[{act__}, {inh__}, {n__}, {m__}]}]:= 
Module[{avars, ivars, navars, nivars, nvals, mvals, arates, irates, myTimes,
dummy,
odes,rateLaw, functionize},
reaction={DoubleLongRightArrow[{{Activator}, {Inhibitor}}, product], rational[{act}, {inh}, {n}, {m}]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

functionize[myTimes[x__]]:= Apply[myTimes,functionize/@List[x]]; 
functionize[x_]:= x[Global`t]; 


avars = {Activator}//Flatten;
ivars = {Inhibitor}//Flatten;

dummy =Union[Flatten[Join[avars,ivars]/.{Times-> List}]]; 
dummy = {Rule[#,#],1}&/@dummy;
dummy  = Join@@(parseArrowForm/@dummy);

avars =( functionize/@(avars/.{Times->myTimes}))/.{myTimes-> Times};
ivars = (functionize/@(ivars/.{Times->myTimes}))/.{myTimes-> Times}; 


navars=Length[avars]; 
nivars= Length[ivars]; 

nvals = {n}; 
While[Length[nvals]<navars, AppendTo[nvals,1]]; 
nvals=Take[nvals,navars]; 
avars = avars^nvals;
PrependTo[avars, 1]; 

mvals={m};
While[Length[mvals]<nivars, AppendTo[mvals, 1]] ; 
mvals=Take[mvals, nivars]; 
ivars = ivars^mvals;
PrependTo[ivars, 1];

(* for rates, include leading constant *)
arates={act};
While[Length[arates]<= navars, AppendTo[arates,1]];  
arates = Take[arates, navars+1]; 
irates={inh};
While[Length[irates]<= nivars, AppendTo[irates,1]]; 
irates = Take[irates, nivars+1]; 

rateLaw = avars.arates/ivars.irates;


rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

If[SameQ[product,Global`\[EmptySet]], 
odes=Map[{#,-rateLaw}&,vars]; 
,
odes = {{product[Global`t], rateLaw}};
];

odes = Join@@{odes,dummy}; 

Return[odes];
];


expandArrows[{Overscript[RightTeeArrow[X_,Y_ ],En_],hill[v_:1,n_:1,K_:1,a_:0,T_:1, v1_:0]}]:= 
Module[{reaction},
reaction={Overscript[RightTeeArrow[X,Y],En],hill[v,n,K,a,T, v1]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];


parseArrowForm[{Overscript[RightTeeArrow[Plus[X_,X1__],Y_ ],En_],hill[v_:1,n_:1,K_:1,r_:0,m_:1, v1_:0]}]:= 
Module[{odes,rateLaw, vars,x},
reaction={Overscript[RightTeeArrow[Plus[X],Y],En],hill[v,n,K,r,m,v1]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
odes = parseArrowForm[{Overscript[RightTeeArrow[vars,Y],En],hill[v,n,K,r,m,v1]}];
Return[odes];
];

(* this module sig. revised v.0.81 *)
parseArrowForm[{Overscript[RightTeeArrow[X_,Y_ ],En_],hill[v_:1,n_:1,k_:1,r_:0,m_:1, v1_:0]}]:= 
Module[{odes,rateLaw, vars,x, nvars, V, K, nn, rr, multiplier, enzyme,inhrate},
reaction={Overscript[RightTeeArrow[X,Y],En],hill[v,n,k,r,m,v1]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

vars={X}//Flatten;
vars=(#[Global`t]&)/@vars;
nvars = Length[vars];
V=getnValues[nvars,m,"Hill rates",reaction];
K=getSingleValue[k,1,"Hill constants", reaction];
nn=getSingleValue[n,1,"Hill exponents",reaction];
rr=getSingleValue[r,0,"Basal rate", reaction];
multiplier=getSingleValue[v,1,"multiplier",reaction];
inhrate=getSingleValue[v1, 0, "Inhibition Rate", reaction]; 

(*x=rr+Plus@@(V*vars);*)
x=rr + V.vars;

(* let \[EmptySet] act as a Unit Catalyst rather than Zero Catalyst *)
enzyme = En[Global`t]/.{Global`\[EmptySet][Global`t]-> 1};

rateLaw=enzyme*multiplier*hillFunction[x,K, nn,1,0]+enzyme*hillFunction[x,K,nn,0,v1];
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

(*rateLaw=m*hillFunction[x,k, n,v*En[Global`t],r];
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]\[Rule] 0};
*)

odes = Join[{#,-rateLaw}&/@vars,{{Y[Global`t], rateLaw}, {En[Global`t],0}}];
Return[odes];
];



expandArrows[{RightTeeArrow[X_,Y_ ],hill[v_:1,n_:1,K_:1,r_:0,m_:1, \[Beta]_:0]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],hill[v,n,K,r,m, \[Beta]]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],hill[v_:1,n_:1,K_:1,r_:0,m_:1, \[Beta]_:0]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],hill[v,n,K,r,m, \[Beta]]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];



parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],hill[v_:1,n_:1,K_:1,r_:0,m_:1, \[Beta]_:0]}]:= 
Module[{odes,rateLaw, vars,x, reaction},
vars={X,X1}//Flatten;
odes = parseArrowForm[{RightTeeArrow[vars,Y],hill[v,n,K,r,m,\[Beta]]}];
Return[odes];
];

parseArrowForm[{RightTeeArrow[X_,Y_ ],hill[v_:1,n_:1,k_:1,r_:0,mult_:1, \[Beta]_:0]}]:= 
Module[{odes,rateLaw, vars,x,nvars,V, K,nn,rr,multiplier, reaction, dummy, basalinh},
reaction={RightTeeArrow[X,Y],hill[v,n,k,r,mult,\[Beta]]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

vars={X}//Flatten;
dummy= {Rule[#,#],1}&/@vars;

vars=(#[Global`t]&)/@vars;
nvars=Length[vars];
V=getnValues[nvars,mult,"Hill rates",reaction];
K=getSingleValue[k,1,"Hill constants", reaction];
nn=getSingleValue[n,1,"Hill exponents",reaction];
rr=getSingleValue[r,0,"Basal rate", reaction];
multiplier=getSingleValue[v,1,"multiplier",reaction];
basalinh=getSingleValue[\[Beta], 0, "Basal Inhibition Rate", reaction];

(*x=rr+Plus@@(V*vars); *)
x=rr+(V.vars);

rateLaw=multiplier*hillFunction[x,K, nn,1,0] + hillFunction[x, K, n, 0, basalinh];
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

If[SameQ[Y,Global`\[EmptySet]], 
odes=Map[{#,-rateLaw}&,vars]; 
,
odes = {{Y[Global`t], rateLaw}};
];

dummy =Join@@( parseArrowForm/@dummy); 

Return[Join[odes,dummy]];
];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{hill[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],hill[z]}];



hill[opt___?OptionQ]:= Module[{v,K,n,r,m,ret, 
incorrect, allow},

v=vmax/.{opt}/.Options[hill];
K=khalf/.{opt}/.Options[hill];
n=nhill/.{opt}/.Options[hill];
r=basalRate/.{opt}/.Options[hill];
m=Thill/.{opt}/.Options[hill];
ret=hill[v,K,n,r,m];

incorrect= Complement[First/@{opt},First/@ Options[hill]];
Print["Warning: hill[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect; 

Return[ret];
];


Hill[x___]:=hill[x];


hillListQ[{h__}]:=SameQ[Union[Head/@{h}],{hill}];
hillListQ[x___]:= False;

GRNListQ[{h__}]:=SameQ[Union[Head/@{h}],{GRN}];
GRNListQ[x___]:= False;

NHCAListQ[{h__}]:=SameQ[Union[Head/@{h}],{NHCA}];
NHCAListQ[x___]:= False;

SSystemListQ[{h__}]:=SameQ[Union[Head/@{h}],{SSystem}];
SSystemListQ[x___]:= False;

listTypes[{h__}]:= Union[Head/@h];




regulatoryQ[{RightTeeArrow[A_,B_],r___}]:= True;
regulatoryQ[x___]:= False;
massActionQ[ShortRightArrow[A_,B_], r___]:= True;
massActionQ[x___]:= False;
regulatoryProduct[{RightTeeArrow[A_,B_],r___}]:= B;
regulatoryProduct[x___]:= {};
regulatorOf[{RightTeeArrow[A_,B_],r___}]:= A;
regulatorOf[x___]:= {};


combineRegulatoryReactions[r_]:= Module[{reg,deg,nonreg,prods,products,dbg=False, reacts,meths, consolidate, dPrint},

dPrint[x___]:= If[dbg, Print["combineRegulatoryReactions: ", x]]; 

consolidate[{reaction_, controls___}]:= Module[{dbg=False,n,heads,firsthead,unheads,nheads,ok,consolidated,dPrint,
consolidateHill, consolidateUser, consolidateSSystem,consolidateNHCA},

dPrint[x___]:= If[dbg, Print["consolidate: ", x]]; 


consolidateNHCA[pars_]:= Module[{args,v,T,n,m,k},

(* NHCA will always have 5 arguments SSystem[v,T,n,m,k], *)
(* as a result of preprocessing. *)

args = functionArguments/@pars;
args = Transpose[args];
{v,T,n,m,k}=args;
If[Length[Union[v]]>1, 
Print["Warning: NHCA reactions with different v: reaction: ",reaction," v:",v]];
If[Length[Union[m]]>1, 
Print["Warning: NHCA reactions with different m: reaction: ", reaction," m:",m]];
If[Length[Union[k]]>1, 
Print["Warning: NHCA reactions with different k: reaction: ",reaction," k:",k]];

v=First[v];
m=First[m];
k=First[k];
args = {v,T,n,m,k};
Return[NHCA@@args];
];(* end consolidateNHCA *) 


consolidateSSystem[pars_]:= Module[{args,theTau, theKp,theKm,theCp,theCm},

(* SSystem will always have four arguments SSystem[tau,kplus,kminus,cplus,cminus], *)
(* as a result of preprocessing. *)

args = functionArguments/@pars;
args = Transpose[args];
{theTau,theKp,theKm, theCp, theCm}=args;
theTau=First[theTau];
theKm=First[theKm];
theKp=First[theKp];
args = {theTau,theKp,theKm, theCp, theCm};
Return[SSystem@@args];
];(* end consolidateSSystem *) 


consolidateHill[pars_]:= Module[{args, T, most, fixargs,result},
fixargs[{vh_}]:= (Print["Warning: Incomplete parameter set in reaction ", pars]; {vh,1,1,0,1});
fixargs[{vh_,nh_}]:= (Print["Warning: Incomplete parameter set in reaction ", pars];{vh,nh,1,0,1}); 
fixargs[{vh_,nh_,Kh_}]:= {vh,nh,Kh,0,1};
fixargs[{vh_, nh_, Kh_, Offh_}]:= {vh, nh, Kh, Offh, 1};
fixargs[{vh_, nh_, Kh_, Offh_, Th_}]:= {vh, nh, Kh, Offh, Th}; 
fixargs[l_?ListQ]:= If[Length[l]>5, l=Take[l, 5], l]; 
(* hill will always have four arguments hill[v,K,n,r], *)
(* as a result of preprocessing. *)
(* except for v, only the first is used *)

args = functionArguments/@pars;
args = fixargs/@args; 
dPrint["consolidateHill: args: ", args]; 

T=Last/@args;
dPrint["consolidateHill: T: ", T]; 

most = Most[First[args]];
result = hill@@Append[most,T];
dPrint["consolidateHill: result: ", result]; 

Return[result];
];(* end consolidateHill *) 

consolidateUser[pars_]:= Module[{args,
nargs,v, T, n,h, f,name,rval, dbg=False},

(* user should  always have five arguments user[r,T,n,h,f], *)
(* This should be handled in the preprocessing *) 
(* r, T, n can vary from one to another *)
(* h and f must be the same *)

If[dbg, Print["consolidateUser: pars=",pars]];
name=((Head/@pars)//Union )//First;
args = functionArguments/@pars;
nargs=Union[Length/@args];
If[Length[nargs]>1 \[Or] (Length[nargs]==1 \[And] nargs[[1]]!= 5),
Print["Error: all user defined regulator rates should have five arguments: user[r,T,n,h,f], not ", Union[pars]];
];

If[dbg,Print["consolidateUser: args=",args]];
{v,T,n,h,f}=Transpose[args];
If[dbg, Print["v=",v,"\nT=",T,"\nn=",n,"\nh=",h,"\nf=",f]];
h=Union[h];

If[Length[h]>1, Print["Error: can not combine user reactions ",name,"  with different thresholds: ", h, " unable to unambiguaously determine which threshold to use. The value ", First[h], " was assumed." ];
];
h=First[h];

f=Union[f];
If[Length[f]>1, Print["Error: can not combine user reactions ",name,"  with different rate functions: ", f, " unable to unambiguaously determine which function to use. The function ",First[f], " was assumed." ];
];
f=First[f];


rval  =name[v, T, n, h, f];
If[dbg, Print["consolidateUser: rval=",rval]];
Return[rval];


];(* end consolidateUser *) 

(* begin main code for consolidate *)
n=Length[controls];
dPrint[reaction," : ",controls," n=",n]; 
If[n<= 1, Return[{reaction,controls}]];
heads=Head/@controls;
firsthead=First[heads];
unheads=Union[heads];
nheads=Length[unheads];
If[nheads>1, Print["Error: different regulatory methods cannot be mixed for a single product: Reaction: ",reaction," Regulatory controls: ",controls," assumed: ",firsthead];
ok = Select[controls,SameQ[firsthead,Head[#]]&];,
ok=controls;
];
dPrint["ok: ", ok]; 
Switch[firsthead,
hill,
consolidated={reaction,consolidateHill[ok]};
,
SSystem,
consolidated= {reaction, consolidateSSystem[ok]};
,
NHCA,
consolidated= {reaction, consolidateNHCA[ok]};
,
_, 

consolidated={reaction,consolidateUser[ok]};

]; 

If[dbg, Print["consolidated---->",consolidated]];
Return[consolidated];
]; (* end consolidate *) 

consolidate[errorInput_]:= Module[{},
Print["Error: combineRegulators: ",errorInput];
Return[errorInput];
]; (* end errorInput consolidate *)

(* main code combineRegulatorityReactions *)

dPrint["r: ", r]; 

reg=Cases[r,{RightTeeArrow[_,_],_}];
(* allow degradation to be treated separately *) 
deg = Cases[r,{RightTeeArrow[_,Global`\[EmptySet]],_}];
reg=Complement[reg,deg]; 

dPrint["reg reactions:",reg];
dPrint["deg reactions:",deg];

(* Can't use Complement becasue that removes duplicates, which we want to keep! *)
(* nonreg=Complement[r,reg]; *)
(* revised v0.75 *)
nonreg = Select[r, !MemberQ[reg, #]&]; 
dPrint["nonreg: ", nonreg]; 

prods = regulatoryProduct/@reg;
dPrint["prods:",prods];
products=Union[prods];
dPrint["products:",products];
reacts=Map[Cases[reg,{RightTeeArrow[_,#],_}]&,products];
dPrint["reactions:\n",reacts];
meths=Map[Last,#]&/@reacts;

dPrint["meths:",meths];
reacts=Map[regulatorOf,#]&/@reacts;
dPrint["regulators:",reacts];

reacts=MapThread[{RightTeeArrow[#1,#2],#3}&,{reacts,products,meths}];
dPrint["reactions: ",reacts];
reacts=consolidate/@reacts;

reacts=Join[nonreg,reacts]; 
 Return[reacts]; 

];


expandArrows[{RightTeeArrow[X_,Y_ ],GRN[r_:1, T_:1, n_:1, h_:0]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],GRN[r, T, n, h,sigmoid]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],GRN[r_:1, T_:1,n_:1, h_:0]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],GRN[r,T,n,h]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];



parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],GRN[r_:1, T_:1, n_:1, h_:0]}]:= 
Module[{odes, vars, reaction},

reaction={RightTeeArrow[Plus[X],Y],GRN[r,T,n,h]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
odes = parseArrowForm[{RightTeeArrow[vars,Y],GRN[r,T,n,h]}];
Return[odes];
];

parseArrowForm[{RightTeeArrow[X_,Y_ ],GRN[r_:1, T_:1, n_:1, h_:0]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],GRN[r, T, n, h, sigmoid]};

Return[parseArrowForm[reaction]];
];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{GRN[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],GRN[z]}];



GRN[opt___?OptionQ]:= Module[{r, T, n, h,ret, f, incorrect},
r=RGRN/.{opt}/.Options[GRN];
T=TGRN/.{opt}/.Options[GRN];
n=nGRN/.{opt}/.Options[GRN];
h=hGRN/.{opt}/.Options[GRN];
f=Sigmoid/.{opt}/.Options[GRN];
If[SameQ[f,sigmoid], 
ret=GRN[r, T, n, h],
ret=GRN[r, T, n, h, f]
]; 
incorrect= Complement[First/@{opt},First/@ Options[GRN]];
Print["Warning: GRN[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect;
Return[ret];
];


grn[x___]:=GRN[x];


expandArrows[{RightTeeArrow[X_,Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],SSystem[tau, kplus, kminus, cplus, cminus]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],SSystem[tau, kplus, kminus, cplus, cminus]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[X_,Y_ ],SSystem[x___]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],SSystem[x]};
Print["Error: expandArrows: incorrect arrow format in ",reaction," correct format is SSystem[tau,kplus,kminus,cplus,cminus]"];
Return[{reaction}];
];


parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{ vars, reaction, rateLaw},

reaction={RightTeeArrow[Plus[X,X1],Y],SSystem[tau, kplus, kminus, cplus, cminus]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],SSystem[tau, kplus, kminus, cplus, cminus]};
Return[parseArrowForm[reaction]];
];

parseArrowForm[{RightTeeArrow[X_,Y_ ],SSystem[tau_, kplus_, kminus_, cplus_, cminus_]}]:= 
Module[{reaction,rateLaw, vars, nvars, odes,k\[UnderBracket]p,k\[UnderBracket]m,cplusses,cminuses,\[Tau], dummy},
reaction={RightTeeArrow[X,Y],SSystem[tau, kplus, kminus, cplus, cminus]};

vars={X}//Flatten;
dummy={Rule[#,#],1}&/@vars; 
vars=(#[Global`t]&)/@vars;
nvars=Length[vars];

\[Tau]=getSingleValue[tau, 1, "SSystem Time Constant", reaction];
k\[UnderBracket]p=getSingleValue[kplus, 1, "SSystem kplus", reaction];
k\[UnderBracket]m=getSingleValue[kminus, 1, "SSystem kminus", reaction];
cplusses=getnValues[nvars,cplus,"SSystem cplus's",reaction];
cminuses=getnValues[nvars,cminus,"SSystem cminus's",reaction];
rateLaw= (1/\[Tau])(k\[UnderBracket]p*Times@@(vars^cplusses) - k\[UnderBracket]m*Times@@(vars^cminuses));
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes = {{Y[Global`t], rateLaw}};
dummy = Join@@(parseArrowForm/@dummy);
odes = Join@@{odes,dummy}; 

Return[odes];


];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{SSystem[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],SSystem[z]}];



expandArrows[{RightTeeArrow[X_,Y_ ],NHCA[v_:1,T_:1,n_:1,m_:1,k_:1]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],NHCA[v,T,n,m,k]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],NHCA[v_:1,T_:1,n_:1,m_:1,k_:1]}]:= 
Module[{reaction, vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],NHCA[v,T,n,m,k]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[X_,Y_ ],NHCA[x___]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],NHCA[x]};
Print["Error: expandArrows: incorrect arrow format in ",reaction," correct format is NHCA[v,T,n,m,k] or NHCA[v,{TP,TM},n,m,k]"];
Return[{reaction}];
];


parseArrowForm[{RightTeeArrow[X_,Y_ ],NHCA[v_, T_,n_,m_,k_]}]:= 
Module[{reaction,rateLaw, vars, nvars, odes,
vvalue,Tvalues,nvalues,mvalue,nT, QP, QM,dummy},
reaction={RightTeeArrow[X,Y],NHCA[v,T,n,m,k]};

vars={X}//Flatten;
dummy={Rule[#,#],1}&/@vars;
vars=(#[Global`t]&)/@vars;
nvars=Length[vars];

vvalue = getSingleValue[v, 1, "NHCA v", reaction];

Tvalues=T;
If[Length[vars]==1, Tvalues=List[Tvalues]]; 
Tvalues=getnListValues[nvars,Tvalues,"NHCA {TP,TM}",reaction]; 

nT=Union[Length/@Tvalues];
If[Length[nT]>1, Print["Error: invalid NHCA T values can not be combined: ", reaction];
Return[{}];
]; 

nT=First[nT]; 
nvalues=getnValues[nvars,n,"NHCA n",reaction];
mvalue=getSingleValue[m,1,"NHCA m", reaction];
kvalue=getSingleValue[k,1,"NHCA k", reaction];



Switch[nT,
1, 
Tvalues = First/@Tvalues;
QP=Tvalues*UnitStep[Tvalues];
QM=Tvalues*UnitStep[-Tvalues];
,
2,{QP, QM}=Transpose[Tvalues];
,
_, Print["Error: invalid format for NHCA T"]; 
]; 

QP=Times@@((1+#)&/@(QP*(vars^nvalues)));
QM=Times@@((1+#)&/@(QM*(vars^nvalues)));

rateLaw=vvalue*(QP^mvalue)/(kvalue*QM^mvalue+QP^mvalue);
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

odes = {{Y[Global`t], rateLaw}};
dummy=Join@@(parseArrowForm/@dummy);
odes = Join@@{odes, dummy}; 

Return[odes];


];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{NHCA[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],NHCA[z]}];



NHCA[opt___?OptionQ]:= Module[{v,T,TP,TM,n,m,k, incorrect},
v=vmax/.{opt}/.Options[NHCA];
T=TNHCA/.{opt}/.Options[NHCA];
TM=TMINUS/.{opt}/.Options[NHCA];
TP=TPLUS/.{opt}/.Options[NHCA];
n=nNHCA/.{opt}/.Options[NHCA];
m=mNHCA/.{opt}/.Options[NHCA];
k=kNHCA/.{opt}/.Options[NHCA];


If[((!SameQ[TP,{}]) \[And]  (!SameQ[TM,{}])),
ret=NHCA[v, {TP,TM},n,m,k];,
ret=NHCA[v,T,n,m,k];
]; 

incorrect= Complement[First/@{opt},First/@ Options[NHCA]];
Print["Warning: NHCA[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect;

Return[ret];
];


expandArrows[{Underoverscript[DoubleLongRightArrow[S_, P_],{activators_, inhibitors_, comptetitiveInhibitors_}, enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction,Slist,Alist, Ilist, Plist,CIlist, Klist, nA, nI, nS,nKneeded,nil},

 reaction={Underoverscript[DoubleLongRightArrow[S, P],{activators, inhibitors, comptetitiveInhibitors}, enzyme],GMWC[kcat, n,c, L, K]};
If[dbgArrows,Print["expandArrows:", reaction]];

Alist={activators}//Flatten;
Ilist={inhibitors}//Flatten;
Slist = {S}//Flatten;
Klist={K}//Flatten;
Plist={P}//Flatten;

CIlist=comptetitiveInhibitors;
If[!ListQ[CIlist], CIlist={CIlist}]; 

nS=Length[Slist]; 
nI=Length[Ilist]; 
nA=Length[Alist]; 
nCI=Length[CIlist//Flatten];
nKneeded=nS+nI+nA+nCI;

If[Length[Klist]>nKneeded,Print["Warning: expandArrows: expecting ",nKneeded," K values; found ", Length[Klist], " K values. Extra values ignored. Reaction: ",reaction];
Klist=Take[Klist,nKneeded];
];

Klist=PadRight[Klist, nKneeded,1];


If[!(And@@(ListQ/@CIlist)),
Print["Error: expandArrows: Competitive Inhibitors must be expressed as a list of lists. Up to ",nS+nA," sublists may be specified in the reaction ",reaction ];
];

CIlist=PadRight[CIlist,nS+nA,nil]/.{nil-> {}};

reaction={Underoverscript[DoubleLongRightArrow[Slist, Plist],{Alist, Ilist, CIlist}, enzyme],GMWC[kcat, n,c, L, Klist]};


Return[{reaction}];
];


expandArrows[{Underoverscript[DoubleLongRightArrow[S_, P_],{activators_, inhibitors_}, enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction},
reaction={Underoverscript[DoubleLongRightArrow[S, P],{activators, inhibitors, {}}, enzyme],GMWC[kcat, n,c, L, K]};
If[dbgArrows,Print["expandArrows:", reaction]];
reaction=expandArrows[reaction]; 
Return[reaction];
];
expandArrows[{Underoverscript[DoubleLongRightArrow[S_, P_],\[Alpha]_, enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction},
reaction=expandArrows[{Underoverscript[DoubleLongRightArrow[S, P],{\[Alpha],{}}, enzyme],GMWC[kcat, n,c, L, K]}];
Return[reaction];
];

expandArrows[{Overscript[DoubleLongRightArrow[S_, P_], enzyme_],GMWC[kcat_:1, n_:1,c_:1, L_:1, K_:1]}]:= 
Module[{reaction},
reaction=expandArrows[{Underoverscript[DoubleLongRightArrow[S, P],{{},{}}, enzyme],GMWC[kcat, n,c, L, K]}];
If[dbgArrows,Print["expandArrows:", reaction]];
Return[reaction];
];

expandArrows[{X___,GMWC[Y___]}]:= 
Module[{reaction},
reaction={X,GMWC[Y]};
If[dbgArrows,Print["expandArrows:", reaction]];
Print["Error: expandArrows: incorrect arrow format in ",reaction," correct format for GMWC reaction is ",{Underoverscript[DoubleLongRightArrow["{S1,S2,\[Ellipsis]}", "{P1,P2,\[Ellipsis]}"],{"{A1,A2,\[Ellipsis]}", "{I1,I2,\[Ellipsis]}", "{CI1,CI2,...}"}, "enzyme"],"GMWC[\!\(\*SubscriptBox[\(k\), \(cat\)]\),n,c,L,K]"}];
Return[{reaction}];
];

expandArrows[{X___,MWC[Y___]}]:= expandArrows[{X,GMWC[Y]}];




parseArrowForm[{Underoverscript[DoubleLongRightArrow[S_, P_],{A_, In_, CI_}, En_],GMWC[kcat_, n_,c_, L_, K_]}]:= 
Module[{reaction,rateLaw, svars, pvars,vars, odes, dvdt,
As,Is,CIs,Ss,Ps, Ks, normalize, nCIs, CIss,m,nS,nA, dbg=False,OnePlusS,OnePluscS,OnePlusA, OnePlusI,Prod1PlusX, modifierVariables, nmodifiers, modifierODES},

normalize[X_, Klist_]:= Module[{XX,KX,KNew,nn},
nn=Length[X];
KX=Take[Klist, nn];
XX=(#[Global`t]&)/@X;
XX=XX/KX;

Knew=Drop[Klist,nn];
Return[{XX,Knew}];
];

Prod1PlusX[X_]:=Times@@((1+Plus@@#)&/@X); 

reaction={Underoverscript[DoubleLongRightArrow[S, P],{A, In, CI}, En],GMWC[kcat, n,c, L, K]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

If[dbg, Print["A=", A, " In=", In, " CI=", CI, " En=", En]]; 
modifierVariables=Join[{A}, {In}, {CI}, {En}]//Flatten;
modifierVariables = (#[Global`t]&)/@modifierVariables; 
nmodifiers = Length[modifierVariables]; 
modifierODES=Table[0, {nmodifiers}]; 

If[dbg, Print["modifierVariables: ", modifierVariables]]; 

svars=(#[Global`t]&)/@S;
pvars=(#[Global`t]&)/@P;


Ks=K;
{Ss, Ks}=normalize[S,Ks];
{As, Ks}=normalize[A,Ks];
{Is, Ks}=normalize[In, Ks];

If [dbg,  Print["S=",Ss,"\nA=",As,"\nI=",Is,"\nK's left:",Ks]; ]; 

nCIs=Length/@CI;
{CIs, Ks}=normalize[Flatten[CI],Ks];

CIss={};
While[Length[nCIs]>0,
m=First[nCIs];
nCIs=Rest[nCIs];
CIss=Append[CIss,Take[CIs,m]];
CIs=Drop[CIs,m];
];
dvdt=En[Global`t]*kcat;

If[ dbg, Print["CI=",CIss, "\nK's left:",Ks, "\nnCI:",nCIs]; ] ;

nS=Length[Ss];
nA=Length[As];

CIs=Take[CIss,nS];
CIss=Drop[CIss,nS];
OnePlusS=MapThread[Join[#1,#2]&,{List/@Ss,CIs}]//Prod1PlusX;
OnePluscS=MapThread[Join[#1,#2]&,{c*List/@Ss,CIs}]//Prod1PlusX;

CIs=Take[CIss,nA];
OnePlusA=MapThread[Join[#1,#2]&,{List/@As,CIs}]//Prod1PlusX;
OnePlusI=Times@@((1+#)&/@Is);
CIs=Times@@(c*Ss);
Ss=Times@@Ss;

If[dbg, Print["1+S+Sbar:",OnePlusS,"\n1+cS+cSbar:",OnePluscS,"\n1+A+Abar:",OnePlusA,"\n1+I:",OnePlusI,"\ncS:",CIs]];

dvdt=dvdt*(OnePlusA^n*Ss*OnePlusS^(n-1)+L*CIs*OnePluscS^(n-1)*OnePlusI^n)/(OnePlusA^n OnePlusS^n+L*OnePluscS^n*OnePlusI^n);
If[dbg, Print["dvdt=",dvdt]];



odes=Join[{#,-dvdt}&/@svars, {#,dvdt}&/@pvars];
If[dbg, Print["odes: ", odes]]; 

modifierODES=Transpose[{modifierVariables, modifierODES}]; 
 If[dbg, Print["modifierODES: ", modifierODES]]; 

odes = Join[odes, modifierODES]; 

Return[odes];


];



GMWC[opt___?OptionQ]:= Module[{r, T, n, h,ret, f, incorrect},

ret=GMWC[
 kcatGMWC/.{opt}/.Options[GMWC], 
nGMWC/.{opt}/.Options[GMWC], 
cGMWC/.{opt}/.Options[GMWC],
LGMWC/.{opt}/.Options[GMWC], 
{KGMWC/.{opt}/.Options[GMWC]}//Flatten
]; 
incorrect= Complement[First/@{opt},First/@ Options[GMWC]];
Print["Warning: GMWC[...] unknown option ", # -> (#/.{opt}), " ignored."]&/@incorrect;
Return[ret];
];


expandArrows[{RightTeeArrow[X_,Y_ ],user_[r_, T_,n_,h_,f_]}]:= 
Module[{reaction},
reaction={RightTeeArrow[X,Y],user[r,T,n,h,f]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[Plus[X_,X1__],Y_ ],user_[r_,T_,n_,h_,f_]}]:= 
Module[{reaction,vars},
vars={X,X1}//Flatten;
reaction={RightTeeArrow[vars,Y],user[r,T,n,h,f]};
If[dbgArrows,Print["expandArrows:", reaction]];
Return[{reaction}];
];
expandArrows[{RightTeeArrow[X_,Y_ ],user_[x___]}]:= 
Module[{},
reaction={RightTeeArrow[X,Y],user[x]};
If[SameQ[user,Times],Print["Error: invalid user function name: "<>"\""<>ToString[({x}//Flatten)[[1]]]<>"\". Check for embedded blanks in function name, that are interpreted as \"Times\", "<>ToString[FullForm[user[x]]]
]];
Print["Error: invalid user defined reaction format: ",reaction," Correct format is {"<>ToString[X//InputForm]<>"\[RightTeeArrow]"<>ToString[Y//InputForm]<>","<>ToString[user//InputForm]<>"[r,T,n,h,f]}"];
Return[{}];
];



 parseArrowForm[{RightTeeArrow[Plus[X_,X1__],Y_ ],user_[r_,T_,n_,h_,f_]}]:= 
Module[{odes,rateLaw, vars,x, reaction},

reaction={RightTeeArrow[Plus[X],Y],user[r,T,n,h,f]};
If[dbgArrows,Print["parseArrowForm:", reaction]];
vars={X,X1}//Flatten;
odes = parseArrowForm[{RightTeeArrow[vars,Y],user[r,T,n,h,f]}];
Return[odes];
]; 

parseArrowForm[{RightTeeArrow[X_,Y_ ],user_[r_,T_,n_,h_,f_]}]:= 
Module[{reaction,vars,nvars,Tall,nall,x,Tlast,nLast,hused,rused,
dummy,
odes,rateLaw, V, K,nn,rr,multiplier},

reaction={RightTeeArrow[X,Y],user[r, T, n, h,f]};
If[dbgArrows,Print["parseArrowForm:", reaction]];

vars={X}//Flatten;
dummy = {Rule[#,#],1}&/@vars;
vars=(#[Global`t]&)/@vars;

If[dbgArrows,Print["parseArrowForm: vars: ", vars]];

nvars=Length[vars];
If[dbgArrows,Print["parseArrowForm: nvars: ", nvars]];

Tall={T}//Flatten;
Tlast=Last[Tall];
If[Length[Tall]<nvars, Tall=PadRight[Tall,nvars,Tlast]];
If[Length[Tall]>nvars, Tall=Take[Tall,nvars]];
If[dbgArrows,Print["parseArrowForm: Tall=",Tall]]; 


nall={n}//Flatten;
nLast=Last[nall];
If[Length[nall]<nvars, nall=PadRight[nall,nvars,nLast]];
If[Length[nall]>nvars, nall=Take[nall,nvars]];
If[dbgArrows,Print["parseArrowForm: nall=",nall]]; 


hused={h}//Flatten;
If[Length[hused]>0, hused=First[hused], hused=0];

rused={r}//Flatten;
If[Length[rused]>0, rused=First[rused],rused=1];

x = hused+Tall.(vars^nall);

rateLaw=rused*f[x];
rateLaw=rateLaw/.{Global`\[EmptySet][Global`t]-> 0};

dummy=Join@@(parseArrowForm/@dummy);
odes = {{Y[Global`t], rateLaw}};
odes = Join@@{odes,dummy};
Return[odes];
];
parseArrowForm[{RightTeeArrow[X_,Y_ ],{user_[z___]}}]:= parseArrowForm[{RightTeeArrow[X,Y],user[z]}];



expandArrows[{substrateExpression_\[Implies]productExpression_ ,rate___:1}]:= Module[{reaction, k},

reaction =substrateExpression\[Implies]productExpression;
If[dbgArrows,Print["expandArrows:", reaction]]; 

k={rate}//Flatten;
If[Length[k]<1, 
k=1, 
If[Length[k]>1, Print["Warning: Extra rate constants ", Drop[k,1]," in the reaction ", reaction, " will be ignored."]]; 
k=First[k]
]; 
Return[{{reaction,k}}];
]


parseArrowForm[{substrateExpression_\[Implies]productExpression_ ,rate___:1}]:= 


Module[{parseExpression, reaction, input, output, klaw,species, nspecies, dbg=False, netStoichiometry, rates,odes, k},

reaction = substrateExpression\[Implies]productExpression;
If[dbgArrows,Print["parseArrowForm:", reaction]]; 

{reaction,k}=expandArrows[{reaction,rate}][[1]];

input=parseReactants[True,substrateExpression];
output=parseReactants[True, productExpression];
klaw=k;

netStoichiometry[x_]:= Module[{in,out},
in = Cases[input,{x,_}];
If[Length[in]<1, 
in = 0, 
in = Transpose[in];
in=Plus@@in[[2]];
];

out=Cases[output,{x,_}];
If[Length[out]<1, 
out = 0, 
out = Transpose[out];
out=Plus@@out[[2]];
];

Return[out-in];

]; (* end netStoichiometry *)

species=Union[First/@input, First/@output]; 
rates=klaw*netStoichiometry/@species;

If[dbg,
Print["input stoichiometry:",input];
Print["klaw=",klaw];
Print["output stoichiometry:",output];
Print["species:", species];
Print["rates:",rates];
];

odes = {species,rates}//Transpose;
Return[odes];
]


expandArrows[]:= Module[{},Print["expandArrows: A reaction must be given as an argument. "];Return[{}]];
expandArrows[x___]:= Module[{},Print["expandArrows: Unable to identify the reactions: ",x];Return[x]];


parseArrowForm[x___]:= Module[{},Print["parseArrowForm: Unable to identify the reactions: ",x];Return[{}]];


 rateLaw[reaction_, variable_]:= Module[{odeterms,term},
odeterms=parseArrowForm[reaction];
term=Select[odeterms,SameQ[First[#],variable[Global`t]]&];
If[Length[term]<1, 
Print["Error: rateLaw: unknown reaction or variable not present in reaction: ",reaction," variable: ",variable];
Return[0]];
If[Length[term]>1, Print["Possible program error: multiple rate laws for same variable.", "reaction=",reaction," variable=",variable," odeterms=",odeterms," term=",term];
];
Return[term[[1,2]]];
] 


rateLaw[x___]:=Module[{},Print["rateLaw: invalid arguments: should be rateLaw[reaction,variable]"];Return[0]]


Headerize[header_, X__]:= ToString[header]<>"["<>StringReplace[ToString[{X}],{"{"-> "", "}"-> ""}]<>"]"; 
B2P[X_?StringQ]:= StringReplace[X, {"]"-> ")", "["->"("}]; 
B2P[X_]:= B2P[ToString[X]]; 
L2B[X_?StringQ]:= StringReplace[X, {"}"-> "]", "{"->"["}];
L2B[X_]:= L2B[ToString[X]]; 
IndexTypeQ[u_Integer]:= True;
IndexTypeQ[u_Symbol]:= True;
IndexTypeQ[u_]:= False; 
StoicTerm[X_Symbol]:= True;
StoicTerm[X_Symbol[index__?IndexTypeQ]]:= True;
StoicTerm[Times[m_?NumericQ, X_Symbol]]:=True;
StoicTerm[XYZ___]:= False; 
StoicExpression[U_?StoicTerm]:= True; 
StoicExpression[X_?StoicTerm + Y_?StoicExpression]:= True;
StoicExpression[XYZ___]:= False;

TextArrow[{ShortRightArrow[X_?StoicExpression,Y_?StoicExpression ]}]:= Module[{rules},
rules={"["->"(","]"->")", "{"-> "[", "}"-> "]", "\[ShortRightArrow]"-> "->", " "-> ""};
StringReplace[ToString[{\!\(\*
TagBox["X",
DisplayForm]\)\[ShortRightArrow]\!\(\*
TagBox["Y",
DisplayForm]\)}],rules]
];

TextArrow[{ShortRightArrow[X_?StoicExpression,Y_?StoicExpression ], k_}]:= Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[ShortRightArrow]"-> "->", " "-> ""};
StringReplace[ToString[{\!\(\*
TagBox["X",
DisplayForm]\)\[ShortRightArrow]\!\(\*
TagBox["Y",
DisplayForm]\),k}],rules]
];
TextArrow[{Rule[X_?StoicExpression,Y_?StoicExpression ]}]:= Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "->", " "-> ""};
StringReplace[ToString[{\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)}],rules]
];

TextArrow[{Rule[X_?StoicExpression,Y_?StoicExpression ], k_}]:= Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "->", " "-> ""};
StringReplace[ToString[{\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\),k}],rules]
];


TextArrow[{Overscript[ShortRightArrow[X_?StoicExpression,Y_?StoicExpression ],Z_], k_}]:= Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "-->", "->"-> "-->"," "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],Headerize["mod",B2P[Z]], k}],rules]
]; 
TextArrow[{Overscript[Rule[X_?StoicExpression,Y_?StoicExpression ],Z_], k_}]:= Module[{rules},
Print["bleh"]; 
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "-->", "->"-> "-->",  " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],Headerize["mod",B2P[Z]], k}],rules]
];
TextArrow[{Overscript[ShortRightArrow[X_?StoicExpression,Y_?StoicExpression ],Z_]}]:= Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "-->","->"-> "-->", " "-> ""};
StringReplace[ToString[{\!\(\*
TagBox["X",
DisplayForm]\)-> \!\(\*
TagBox["Y",
DisplayForm]\),Headerize["mod",B2P[Z]]}],rules]
]; 
TextArrow[{Overscript[Rule[X_?StoicExpression,Y_?StoicExpression ],Z_]}]:= Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "-->","->"-> "-->", " "-> ""};
StringReplace[ToString[{\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\),Headerize["mod",B2P[Z]]}],rules]
];


TextArrow[{RightArrowLeftArrow[X_?StoicExpression, Y_?StoicExpression],k__}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "<->","->"-> "<->", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],Headerize["rates",k]}],rules]
];
TextArrow[{RightArrowLeftArrow[X_?StoicExpression, Y_?StoicExpression]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "<->","->"-> "<->", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)]}],rules]
];  


TextArrow[{Overscript[RightArrowLeftArrow[X_, Y_],Z_],k__}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "=>","->"-> "=>", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["mod",B2P[Z]], Headerize["rates",k]}],rules]
];
TextArrow[{Overscript[RightArrowLeftArrow[X_, Y_],Z_]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "=>","->"-> "=>", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["mod",B2P[Z]]}],rules]
];


TextArrow[{Underoverscript[RightArrowLeftArrow[X_, Y_],Under_, Over_],k__}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "<=>","->"-> "<=>", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["mod",B2P[Over], B2P[Under]], Headerize["rates",k]}],rules]
];
TextArrow[{Underoverscript[RightArrowLeftArrow[X_, Y_],Under_,Over_]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "<=>","->"-> "<=>", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["mod",B2P[Over], B2P[Under]]}],rules]
];


TextArrow[{Overscript[Equilibrium[X_, Y_],Cat_],k__}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> ":=>","->"-> ":=>", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["mod",B2P[Cat]], Headerize["rates",k]}],rules]
];
TextArrow[{Overscript[Equilibrium[X_, Y_],Cat_]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> ":=>","->"-> ":=>", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["mod",B2P[Cat]]}],rules]
];


TextArrow[{DoubleLongRightArrow[X_, Y_],MM[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> ":->","->"-> ":->", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],  Headerize["MMH",k]}],rules]
];
TextArrow[{Overscript[DoubleLongRightArrow[X_, Y_],Cat_], MM[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> ":->","->"-> ":->", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],  Headerize["mod", B2P[Cat]], Headerize["MMH",k]}],rules]
];


TextArrow[{Overscript[DoubleLongRightArrow[X_, Y_],Cat_], MWC[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "==>","->"-> "==>", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],  Headerize["mod", B2P[Cat]], Headerize["MWC",k]}],rules]
];
TextArrow[{Underoverscript[DoubleLongRightArrow[X_, Y_],UnderCat_,OverCat_], MWC[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "==>","->"-> "==>", " "-> ""};
StringReplace[ToString[
{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],  
Headerize["mod", B2P[OverCat], L2B/@{B2P[UnderCat]}],
Headerize["MWC",k]
}],
rules]
];


TextArrow[{RightTeeArrow[X_, Y_], hill[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "|->","->"-> "|->", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["Hill",L2B/@{k}]}],rules]
];
TextArrow[{Overscript[RightTeeArrow[X_, Y_],Cat_],  hill[k__]}]:=Module[{rules},
rules={"{"-> "[", "}"-> "]", "\[Rule]"-> "|-->","->"-> "|-->", " "-> ""};
StringReplace[ToString[
{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],
Headerize["mod",B2P[Cat]],  
Headerize["Hill",L2B/@{k}]
}],rules]
];


TextArrow[{RightTeeArrow[X_, Y_], GRN[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "|->","->"-> "|->", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["NHCA",L2B/@{k}]}],rules]
];
TextArrow[{Overscript[RightTeeArrow[X_, Y_],Cat_],  GRN[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "|-->","->"-> "|-->", " "-> ""};
StringReplace[ToString[
{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],
Headerize["mod",B2P[Cat]],  
Headerize["GRN",L2B/@{k}]
}],rules]
];


TextArrow[{RightTeeArrow[X_, Y_], SSystem[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "|->","->"-> "|->", " "-> ""};
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["SSystem",L2B/@{k}]}],rules]
];


TextArrow[{RightTeeArrow[X_, Y_], NHCA[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "|->","->"-> "|->", " "-> ""};
StringReplace[
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["NHCA",L2B/@{k}]}],rules], 
{"[["-> "[", "]]"-> "]"}]
];
TextArrow[{Overscript[RightTeeArrow[X_, Y_],Cat_],  NHCA[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "|-->","->"-> "|-->", " "-> "" };
StringReplace[
StringReplace[ToString[
{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)],
Headerize["mod",B2P[Cat]],  
Headerize["NHCA",L2B/@{k}]
}],rules], 
{"[["-> "[", "]]"-> "]"}]
];


TextArrow[{DoubleLongRightArrow[X_, Y_], rational[k__]}]:=Module[{rules},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "==>","->"-> "==>", " "-> ""};

StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["rational",L2B/@{k}]}],rules]
];


MakeLambda[fun_]:=Module[{n,slots,expr,f1,X,slotvars,slot,fred,Temp,argument,decl},argument[f_[x_]]:=x;
slots[f_]:=Length[Union[Cases[f,Slot[_],Infinity]]];
n=slots[fun];
slotvars=Table["X"<>ToString[j],{j,1,n}];
slot[j_]:=slotvars[[j]];
expr=StringReplace[ToString[InputForm[argument[(fun/.{Function->Temp}/.{Slot->slot})]]],{"\""->""}];
decl="lambda ";
While[Length[slotvars]>0,If[Length[slotvars]==n,decl=decl<>" "<>First[slotvars],decl=decl<>", "<>First[slotvars]];
slotvars=Rest[slotvars];];
expr="\""<>decl<>": "<>expr<>"\""]
TextArrow[{RightTeeArrow[X_, Y_], unknown_[v_,T_,n_,h_,f_Function]}]:=Module[{rules,fun},
rules={"["->"(","]"->")","{"-> "[", "}"-> "]", "\[Rule]"-> "|->","->"-> "|->"};
fun=MakeLambda[f]; 
StringReplace[ToString[{B2P[\!\(\*
TagBox["X",
DisplayForm]\)->\!\(\*
TagBox["Y",
DisplayForm]\)], Headerize["USER",L2B/@{v,T,n,h,fun}]}],rules]
];



TextArrow[x___]:= (Print["A TextArrow translation has not been implemented for the following arrow: ", x]; Return[""]); 


FluxReactionStoichiometry[{ShortRightArrow[LHS_,RHS_ ],Flux[stuff__]}]:= Module[{species, stoics,defunctionate},
defunctionate[p_[q_]]:= p;
defunctionate[p_]:= p; 

{species, stoics} = reactionStoich[LHS, RHS]; 
species = defunctionate/@species; 
{species, stoics}
];
FluxReactionStoichiometry[{Rule[A_,B_], Flux[stuff__]}]:= FluxReactionStoichiometry[{ShortRightArrow[A,B],Flux[stuff]}]; 
FluxReactionStoichiometry[other___]:= (Print["Not a Flux model: ", other]; Abort[]); 


StoichiometryMatrix[model_]:= Module[{stuffs, allSpecies, NS, NR,N,S,R,missing,species,stoichs,RR},
stuffs = FluxReactionStoichiometry/@model;
allSpecies = Union[Flatten[First/@stuffs]];
NS = Length[allSpecies];
NR = Length[stuffs]; 
N={};
While[Length[stuffs]>0,
R=First[stuffs];
stuffs=Rest[stuffs];
{species, stoichs}=R; 
missing=Complement[allSpecies,species]; 
species = Join[species,missing]; 
stoichs = PadRight[stoichs,NS];
RR=Sort[{species,stoichs}//Transpose]//Transpose;
stoichs=RR[[2]];
N=Append[N, stoichs]; 
];
Transpose[N]
]


ParseFluxReaction[{ShortRightArrow[lhs_,rhs_], Flux[args___]}]:= 
Module[{input},
input={args};
(* increment Global (xlr8r`Private context) variable *)
iFluxArrows = iFluxArrows+1; 
If[Length[input]<1, input={-Infinity}]; 
If[Length[input]<2, AppendTo[input,  Unique["v"<>ToString[iFluxArrows]]]];
If[Length[input]<3,AppendTo[input, Infinity]]; 
If[Length[input]<4, AppendTo[input,0]]; 
If[Length[input]<5,AppendTo[input,0]]; 
If[Length[input]>5, input = Take[input, 5]]; 
input
];


ParseFluxReaction[{Rule[lhs_,rhs_],Flux[args___]}]:= ParseFluxReaction[{ShortRightArrow[lhs,rhs],Flux[args]}];
ParseFluxReaction[other___]:= (Print["Not a flux reaction: ", other]; Abort[]); 


OptimizeFluxModel[model_, debug_:False]:= Module[{inputs, lower, v, upper, fluxvals, f,M, lu, constraints},
iFluxArrows=0; (* initialize Global iFluxArrows *)
inputs = ParseFluxReaction/@model;
n = Length[inputs]; 
inputs  = Transpose[inputs];
{lower, v, upper, fluxvals, f} = inputs;
lu = MapThread[#1<#2<#3&, {lower, v, upper}];
M=StoichiometryMatrix[model];
constraints = Join[Equal[#,0]&/@(M.v), lu];
If[debug,
Print["Constraints: ", constraints];
Print["Objective Function: ", f.v]; 
]; 
NMaximize[{f.v, constraints}, v, Method-> "NelderMead"]
]


iFluxArrows=0; (* make global *)
interpret[{reactions__?ListQ}, opt___?OptionQ]:= Module[{dbg,r,odes, species,terms,odeterms,cpu,nextvar,nextterm,var,vardot,vardotarray,term,termarray,timer, n,i,vars, j,varnames,varnamearray,vararray,eqn, frozenvariables,somefrozen,\[EmptySet]s, defunctionate, raterules, complement, liquidvariables, f, v
},
iFluxArrows=0; (* reset *)
complement[p_][Global`t]:= 1-p[Global`t]; 

defunctionate[p_[Global`t]]:= p;
defunctionate[p_]:= p; 

dbg = debugflag/.{opt};
timer = Global`CPU/.{opt}/.{Global`CPU-> False};

raterules=rates/.{opt}/.Options[interpret];

If[dbg, Print["interpret: raterules=",raterules]]; 
r={reactions}/.raterules;
If[dbg, Print["interpret:input:",r]];

frozenvariables = "Frozen"/.{opt}/.Options[interpret];
(* check for deprecated version if new version is not used *) 
If[Length[frozenvariables]<1, 
frozenvariables = frozen/.{opt}/.Options[interpret]]; 
(* add dummy reaction for all frozen variables to force them to be species (11.26.07, v0.62) *)
f=frozenvariables;
While[Length[f]>0,
v=First[f]; f= Rest[f]; 
AppendTo[r, {v-> v}];
]; 
If[dbg, Print["interpret:revised input: ", r]]; 

frozenvariables = {frozenvariables,Global`\[EmptySet]}//Flatten;
If[dbg, Print["interpret:frozen:", frozenvariables]]; 




somefrozen=Length[frozenvariables]>0;
If[somefrozen, frozenvariables=#[Global`t]&/@frozenvariables];

(* add in pre-processing here *)

If[timer,cpu=TimeUsed[];];

r=Join@@expandArrows/@r;
If[dbg, Print["interpret:after expandArrows: ", r]]; 
r=combineRegulatoryReactions[r];
If[dbg, Print["interpret: after combineRegulatory: ", r]]; 


odes=parseArrowForm/@r;
If[dbg, Print["interpret: odes after parseArrowForm: ", odes]]; 

odes = Join@@odes;

If[dbg, Print["interpret: odes after parseArrowForm (2): ", odes]]; 


If[odes==={}, Return[{}]];

species =Union[First/@odes];

If[timer,
cpu=TimeUsed[]-cpu;
Print["1:",cpu];
cpu=TimeUsed[];
]; 

odes=Sort[odes];

If[timer,
cpu=TimeUsed[]-cpu;
Print["2:",cpu];
cpu=TimeUsed[];
];

{vars,odes}=Transpose[odes];
n=Length[odes];
termarray=Array[terms,n];
varnamearray=Array[varnames,n];
For[i=1,i<= n,i++,
terms[i]=odes[[i]];
varnames[i]=vars[[i]];
];


vararray=Array[var,n];
vardotarray=Array[vardot,n];

i=1;j=1;
var[j]=varnames[i];
If[MemberQ[frozenvariables,var[j]],
vardot[j]=0,
vardot[j]=terms[i]
];

While[i<n,
i++;
nextvar=varnames[i];
nextterm=terms[i];
If[nextvar===var[j],
If[MemberQ[frozenvariables,var[j]],
vardot[j]=0,
vardot[j]+= nextterm
];
,
j++;
var[j]=nextvar;
If[MemberQ[frozenvariables,var[j]],
vardot[j]=0,
vardot[j]=nextterm
];
(* if the current variable is frozen, "unsave" it *)
];

];
species=Take[vararray,j];
odeterms=Take[vardotarray,j]; 
If[timer,
cpu=TimeUsed[]-cpu;
Print["3:",cpu];
cpu=TimeUsed[];
];

If[dbg, 
Print["interpret:odes:",odes];
Print["interpret:species:",species];
Print["interpret:odeterms:",odeterms];
];

\[EmptySet]s=Position[species,Global`\[EmptySet][Global`t]];
If[Length[\[EmptySet]s]>0,
If[Length[\[EmptySet]s]>1,
Print["Error: Empty Set occurs at positions ",\[EmptySet]s];
,
\[EmptySet]s=\[EmptySet]s[[1]];
species=Drop[species,\[EmptySet]s];
odeterms=Drop[odeterms,\[EmptySet]s];
];
];

odes = MapThread[Equal[D[#1,Global`t], #2]&,{species,odeterms}]; 

odes = odes/.{Comp-> complement};

(* remove the odes for the frozen variables *)
(*  n=Length[odes];
liquidvariables=Position[MemberQ[frozenvariables,var[#]]&/@Range[n] , False]//Flatten;
odes = odes[[liquidvariables]];
species=species[[liquidvariables]];
 *)
If[timer,
cpu=TimeUsed[]-cpu;
Print["4:",cpu];
];
species=defunctionate/@species;
Return[{odes,species}]
];


interpret[x___]:=Module[{}, Print["Not a list of lists."];Return[{}];]


NonListAndNonInteger[x_]:= And[NonListQ[x],NonIntegerQ[x]] ;
ODE[{reaction__?ListQ}]:= interpret[{reaction}][[1]]; 
ODE[{reaction__?ListQ},n_Integer]:= interpret[{reaction}][[1,n]];
ODE[{reaction__?ListQ}, X_?NonListAndNonInteger]:= Module[{odes, positions},
odes = ODE[{reaction}]; 
positions = Position[odes,X]; 
If[Length[positions]>0,
positions = Select[positions,#[[2]]==1&];
];
If[Length[positions]>0,
positions = positions[[1,1]];
Return[odes[[positions]]]; 
]; 
Return[{}]; 
]; 
ODE[{reaction__?ListQ}, {X__Symbol}]:= ODE[{reaction},#]&/@{X}; 
ODE[reaction_]:= interpret[{reaction}][[1,1]]


lowLevelReactions[reactions_, opt___?OptionQ]:= Module[{RATES, r},

RATES = rates/.{opt}/.Options[rates];
r=xlr8r`Private`expandArrows/@(reactions); 
r=Join@@r;

If [!RATES,
r=First/@r;
]; 
Return[r];
]


interpreted[list_?ListQ]:= Module[{h},
If[Length[list]!= 2, Return[False]];
If[Length[list[[1]]]!= Lenth[list[[2]]], Return[False]]; 
h=Union[Head/@First[list]];
If[Length[h]!= 1, Return[False]];
h=First[h];
If[!SameQ[h,Equal], Return[False]];
Return[True];
];
interpreted[x_]:= False;


jacobianMatrix[r_,t_:Global`t]:= Module[{eqs,vars, dRow},
If[interpreted[r],
 eqs=r,
eqs=interpret[r]];
{eqs,vars}=eqs;
vars = #[t]&/@vars;
(* in 5.0++, equation will not necessarily be of the form x'=stuff but may be an equation will be an expression involving x': need to solve for x'[t] *)

eqs=Last/@Flatten[MapThread[Solve[#1,D[#2,{t,1}]]&, {eqs,vars}]];

dRow[equation_]:= Map[D[equation,{#,1}]&, vars];
dRow/@eqs
]


debugRun=False; 
run[system_, opt___?OptionQ]:= 
Module[{span,runspan,n, sym},
span=Flatten[List["TimeSpan"/.{opt}/.{"TimeSpan"-> {}}]]; 
If[span=={}, 
span=Flatten[List[timeSpan/.{opt}/.Options[run]]]];
Switch[Length[span],
0,runspan={0,100}; ,
1, runspan=Prepend[span,0];,
2,runspan=span;,
3, runspan=span;,
_, runspan= Take[span,3];
]; 
If[debugRun, Print["run:system:",system," runspan:", runspan," opt:",{opt}]]; 
n = run[system,runspan, opt]; 
Return[n];
];
run[system_, {t_, tstart_, tend_}, opt___?OptionQ]:= run[system, {tstart, tend}, timeVariable-> t, opt]; 
run[sys_,{tstart_, tend_}, opt___?OptionQ]:= Module[

{ic, r, n, eqs, vars, nopt, pvar, time, icsGiven, icsMissing,ruleToICequation, gpvar, deindex, deindexedvars, plt, bc, bcflag,bcvar, dbcvars, fv, dpr, quiet, equations,xtraSpecies,system,sym,initialRates, trace, tPrint},

quiet = "Quiet"/.{opt}/.Options[run]; 
If["Debug"/.{opt}/.Options[run], debugRun=True, debugRun=False]; 
trace = "GoDebug"/.{opt}/.{"GoDebug"-> False}; 
tPrint[u___]:= If[trace, Print["run: ", u]]; 

(* check to see if there are algebraic equations as well as ODEs*)
tPrint["Collecting Species from \"Equations\"."]; 
equations = "Equations"/.{opt}/.{"Equations"-> {}}; 
initialRates="InitialRates"/.{opt}/.{"InitialRates"-> {}}; 
xtraSpecies={}; 
If[Length[equations]>0,
xtraSpecies=Head/@First/@equations; 
]; 

dpr[x___]:= If[debugRun, Print["run: ", x]]; 

deindex[a_[b___]]:= deindex[a];
deindex[a_]:= a; 

time = timeVariable/.{opt}/.Options[run]; 

bc = "BoundaryConditions"/.{opt}/.{"BoundaryConditions"-> {}}; 
bcflag = Length[bc]>0;

(* make sure boundary conditions are included in frozen variables *)
(* xlr8r`frozen is for backward compatibility *)
tPrint["Checking for Frozen variables"]; 
fv="Frozen"/.{opt}/.{"Frozen"-> {}};
If[fv=={},fv=frozen/.{opt}/.{frozen-> {}}]; 

If[bcflag,
bcvar = First/@bc; 
bcvar = deindex/@bcvar; 

dpr["bc: ", bcvar]; 

fv = Union[Join[fv, bcvar]];  
dpr["fv: ", fv]; 

]; 

(* if necessary, convert the reactions to ODES *)

tPrint["Checking to see if system is already interpreted."]; 
If[interpreted[sys], system=sys, system=interpret[sys, "Frozen"-> fv]];



dpr["interpretd system: ", system]; 


(* make sure to remove any boundary conditions from the solve-for variables *)

tPrint["Removing xlr8r boundary conditions"]; 
If[bcflag,
{eqs, vars} = system;
vars = Complement[vars, bcvar]; 
dbcvars = D[#[time], {time, 1}]&/@bcvar;
eqs = Select[eqs,
!MemberQ[dbcvars,First[#]]&
];
eqs = eqs/.bc;
system = {eqs, vars};
dpr["revised system: ", system];
]; 


tPrint["Collecting IC, Parameters"]; 
ic = "IC"/.{opt}/.{"IC"->{}}; 
If[ic=={}, ic=initialConditions/.{opt}/.Options[run]];


r= "Parameters"/.{opt}/.{"Parameters"-> {}}; 
If[r=={},r=rates/.{opt}/.Options[run]];

vars = system[[2]]; 
vars = Union[Join[vars, xtraSpecies]]; 

(* convert any ics that are given as rules into NDSolve-compatible form *)

ruleToICequation[Rule[a_,b_]]:= Equal[a[tstart], b];
ruleToICequation[a_]:= a;
ic = ruleToICequation/@ic;

dpr[":ic:",ic,"\nr:", r,"\nvars:",vars];

(* determine missing initial conditions and set them to zero *)

icsGiven=Head/@First/@ic;
dpr["icsGiven: ", icsGiven]; 

tPrint["Checking for missing IC"]; 

icsMissing=Complement[vars, icsGiven];
dpr["icsMissing: ", icsMissing]; 

If[Length[icsMissing]>0,
If[!quiet, 
Print["Warning: "//boldRed,"Initial conditions are missing (and assumed to be zero) for the following variables: "//boldBlack, icsMissing//boldBlue]
];

icsMissing=Equal[#[tstart], 0]&/@icsMissing; 
ic=Join[ic, icsMissing];
];

(* create the NDSolve-compatible system *) 
tPrint["Building system."]; 
eqs = Join[system[[1]], equations, ic,initialRates]/.r;
dpr["eqs: ", eqs]; 

(* check for undefined variables/parameters/constants *) 

sym =getSymbols[eqs];
dpr["sym(1):", sym]; 

deindexedvars=Union[deindex/@vars]; 
sym = Complement[sym, vars, deindexedvars,{time}];
dpr["sym(2):", sym]; 

(* 6.24/08 remove system context variables like If and Which *)

sym = Select[sym, (Context[#]!= "System`")&]; 
 dpr["sym(3): ", sym]; 

If[Length[sym]>0, 
If[!quiet,
Print["Warning: "//boldRed," The following symbols are undefined (and assumed to be equal to one (1)): "//boldBlack, sym//boldBlue]
]; 
sym = Rule[#,1]&/@sym;
eqs = eqs/.sym;

dpr["sym(4):", sym]; 
dpr["eqs(2): ", eqs]; 
];


(* filter NDSolve options and solve the system *) 
Clear[system]; 
dpr["NDSolve."]; 
With[
{nopt=MyFilterOptions[NDSolve,opt]},
n=Check[Global`$$$SOLUTION=NDSolve[eqs, vars, {time, tstart, tend}, nopt],
(Print["Unable to continue full simulation. A partial solutian **MAY** have been saved to the variable $$$SOLUTION. "];Abort[])]; 
];
tPrint["Checking for Plotting."]; 
Block[{plotflag},
plotflag = "plot"/.{opt}/.Options[run]; 
If[!plotflag, plotflag =plot/.{opt}/.Options[run]]; 
If[plotflag,
(* if a plot is requested *) 


pvar = "plotVariables"/.{opt}/.Options[run];
If[Length[pvar]<1, 
pvar = plotVariables/.{opt}/.Options[run]];


If[!SameQ[pvar,None],
If[Length[pvar]>0,
plt= runPlot[n, pvar,opt],
plt=runPlot[n] 
];
If[$VersionNumber>5.5, Print[plt]]; 
 ]; 

(* if a gridPlot is requested *)

gpvar = "gridPlotVariables"/.{opt}/.Options[run];
If[Length[gpvar]<1, 
gpvar = gridPlotVariables/.{opt}/.Options[run]];
If[!SameQ[gpvar,None], 
If[SameQ[gpvar,All],
plt=gridPlot[n,All, {tstart, tend},opt];,
plt=gridPlot[n,Flatten[gpvar],{tstart, tend},opt];
];
If[$VersionNumber>5.5, Print[plt]]; 

]; 

];
]; 

(* return a list of interpolating functions *)

Return[n];
];



debugRunPlot=False;
runPlot[sys_, opt___?OptionQ]:= Module[{vars},
vars=First/@Flatten[sys]; 
If[debugRunPlot, Print["runPlot(1): vars: ", vars, " {opt}:", {opt}]]; 
Return[runPlot[sys,vars,opt]];
];
runPlot[sys_, {vars___}, opt___?OptionQ]:= Module[{n,arg, tstart, tend,p},

(* determine time span: plot everything *) 
If[debugRunPlot, Print["runPlot(2): {vars}: ", {vars}, " {opt}: ", {opt}]]; 

args[a_[b___]]:= {b}//Flatten; 
args[a___]:= {a}//Flatten;
n=Last/@Flatten[sys];
n=args/@n;
n=(Take[#,2]&/@n)//Union;
tstart=Max[First/@n];
tend=Min[Last/@n];
If[tstart>= tend, Print["Warning: runPlot: unable to plot results. Incompatible time domains."];
Return[];
]; 

p=runPlot[sys, {vars}, {tstart,tend},opt];
Return[p];
];

runPlot[sys_, var_,opt___?OptionQ]:=Module[{}, 
If[debugRunPlot, Print["runPlot(3): {vars}: ", {vars}, " {opt}: ", {opt}]]; 
 runPlot[sys,{var},opt]]; 

runPlot[sys_, {varseq___}, { tstart_, tend_}, opt___?OptionQ]:= Module[{plot, varsRequested, saveContext, n,nd, varsAvailable, missingVars, g, v},
If[debugRunPlot, Print["runPlot(4): {varseq}: ", {varseq}, " {tstart, tend}=",{tstart, tend}, " {opt}: ", {opt}]]; 

plot[x___]:= XPlot;

(* check for missing variables *)

varsRequested = {varseq}; 
n=Flatten[sys];
varsAvailable = First/@n;
missingVars = Complement[varsRequested, varsAvailable]; 
If[Length[missingVars]>0,
Print["Warning: "//boldRed, "The requested plot variables: "//boldBlack, missingVars//boldBlue," can not be found to be plotted."//boldBlack]; 
varsRequested=Complement[varsRequested, missingVars];
]; 


If[Length[varsRequested]>0,
(* saveContext=MathSBML`Private`$SBML$Context; 
MathSBML`Private`$SBML$Context="None`"; *)


nd = Flatten[n];
{v,nd}=(nd/.{Rule-> List})//Transpose;

(* The "Hold" is so that things like A\[Diamond]B become (A\[Diamond]B)[t] instead of A\[Diamond](B[t])*)

v=functionate[Hold/@v]/.{Hold-> Identity}; 
If[debugRunPlot, Print["runPlot: v: ", v]]; 
nd=Rule@@#&/@Transpose[{v, #[Global`t]&/@nd}];


If[debugRunPlot, Print["runPlot: calling XPlot: varsRequested: ", varsRequested, " nd=", nd]];

g=XPlot[InterpolationSet[nd], varsRequested, {tstart, tend}, opt];

(* MathSBML`Private`$SBML$Context=saveContext; *)
,
Print["Error: runPlot: "//boldRed," at least one valid variable must be specified to generate a plot."//boldBlack]; 
g={};
]; 
Return[g];
];

runPlot[sys_,var_,{tstart_, tend_}, opt___?OptionQ]:= runPlot[sys, {var},{tstart, tend}, opt];


gridPlot[sys_, opt___?OptionQ]:= Module[{vars},
vars=First/@Flatten[sys]; 
Return[gridPlot[sys,vars,opt]];
];
gridPlot[sys_, {vars___}, opt___?OptionQ]:= Module[{n,arg, tstart, tend,p},

(* determine time span: plot everything *) 

args[a_[b___]]:= {b}//Flatten; 
args[a___]:= {a}//Flatten;
n=Last/@Flatten[sys];
n=args/@n;
n=(Take[#,2]&/@n)//Union;
tstart=Max[First/@n];
tend=Min[Last/@n];
If[tstart>= tend, Print["Warning: gridPlot: unable to plot results. Incompatible time domains."];
Return[];
]; 
p=gridPlot[sys, {vars}, {tstart,tend},opt];
Return[p];
];


gridPlot[sys_, var_,opt___?OptionQ]:= gridPlot[sys,{var},opt]; 


gridPlot[sys_, vars_,{tstart_, tend_}, opt___?OptionQ] := Module[{p,v, colors, nv,ga,nc, rem, styles, plotoptions,h,w,a},


w="Width"/.{opt}/.{"Width"-> 300}; 
a="Aspect"/.{opt}/.{"Aspect"-> (1.0/GoldenRatio)}; 
h=a*w;

If[vars===All,
v=First/@Flatten[sys];,
v=vars;
]; 
nv=Length[v];
colors =Hue/@( Range[nv]/nv); 

styles ="styles"/.{opt}/.Options[gridPlot];
plotoptions="Options"/.{opt}/.{"Options"-> {PlotRange-> All}}; 
While[Length[styles]<nv, styles=Append[styles,{}]]; 
If[Length[styles]>nv, styles=Take[styles,nv]]; 

colors=MapThread[Directive[Flatten[{#1,#2}]]&, {colors, styles}]; 

(* colors = Prepend[styles,#]&/@colors; *)


p = MapThread[runPlot[sys, #1,{tstart, tend},PlotLabel-> #1,"holdLegend"-> True,PlotStyle-> #2, Sequence@@plotoptions]&,  {v, colors}];

With[{popt=MyFilterOptions[Plot,plotoptions]}, 
p = MapThread[Plot[#1[Global`t]/.Flatten[sys], {Global`t, tstart, tend},PlotLabel-> #1,PlotStyle-> #2, AspectRatio-> Full,ImageSize-> {w,h}, popt]&,  {v, colors}]
];


nc= ("Columns"/.{opt})/.{"Columns"-> (plotColumns/.{opt}/.Options[gridPlot])}; 


If[nc>1, ga=Partition[p,nc];
rem = Mod[nv, nc];
If[rem>0, 
ga = Append[ga, Take[p,-rem]]; 
];
]; 
With[{optsShow=MyFilterOptions[Plot,opt]},
If[nc>1,
Return[Show[GraphicsGrid[ga],  optsShow]],
Return[Show[GraphicsColumn[p], optsShow]]
]]
];


arrayGridPlot[n_, ncells_,tmax_, {vars__}, opt___?OptionQ]:= Module[
{singlePlot, plots, columns,df},

df = DisplayFunction/.{opt}/.{DisplayFunction-> $DisplayFunction}; 

singlePlot[variableName_]:= runPlot[n, #/@(Range[ncells]),{0,tmax},opt, PlotRange-> All,  "holdLegend"-> True, PlotLabel-> #, DisplayFunction-> Identity]&/@{variableName};
plots = singlePlot/@{vars};

columns = plotColumns/.{opt}/.{plotColumns-> 3};

plots = Flatten[plots];
plots=Partition[plots, columns, columns, {1,1}, {}]; 
Return[Show[MyGraphicsArray[plots], DisplayFunction-> df,opt]];

]



(* 
debugRun=False;

simulate[system_,tend_,  opt___?OptionQ]:= Module[{},
simulate[system, timeSpan\[Rule] tend, opt]
];  


simulate[sys_, opt___?OptionQ]:= Module[

{ic, r, n, eqs, odes, vars, nopt, pvar, time=Global`t, icsGiven, icsMissing,ruleToICequation, gpvar, deindex, deindexedvars},

If[interpreted[sys], system=sys, system=interpret[sys]];

deindex[a_[b___]]:= deindex[a];
deindex[a_]:= a; 

ic = initialConditions/.{opt}/.Options[run];
r= rates/.{opt}/.Options[run];
vars = system[[2]]; 

tend = timeSpan/.{opt}/.{timeSpan\[Rule] 100};


(* convert any ics that are given as rules into NDSolve-compatible form *)

ruleToICequation[Rule[a_,b_]]:= Equal[a[0], b];
ruleToICequation[a_]:= a;
ic = ruleToICequation/@ic;

If[debugRun, Print["simulate:ic:",ic,"\nr:", r,"\nvars:",vars,"\ntend:",tend]];

(* determine missing initial conditions and set them to zero *)

icsGiven=Head/@First/@ic;
icsMissing=Complement[vars, icsGiven];
If[Length[icsMissing]>0,
Print["Warning: "//boldRed,"Initial conditions are missing (and assumed to be zero) for the following variables: "//boldBlack, icsMissing//boldBlue];

icsMissing=Equal[#[0], 0]&/@icsMissing; 
ic=Join[ic, icsMissing];
];
If[debugRun, Print["simulate: ic:", ic]]; 

(* create the NDSolve-compatible system *) 

odes = system[[1]]; 
If[debugRun, Print["simulate: odes:", odes]]; 

eqs = Join[system[[1]], ic]/.r;

(* check for undefined variables/parameters/constants *) 

sym =getSymbols[eqs];
deindexedvars=Union[deindex/@vars]; 
sym = Complement[sym, vars, deindexedvars,{time}]; 
If[Length[sym]>0, 
Print["Warning: "//boldRed," The following symbols are undefined (and assumed to be equal to one (1)): "//boldBlack, sym//boldBlue]; 
sym = Rule[#,1]&/@sym;
eqs = eqs/.sym;
];

(* filter NDSolve options and solve the system *) 
(* 
With[
{nopt=MyFilterOptions[NDSolve,opt]},
n=NDSolve[eqs, vars, {time, tstart, tend}, nopt]; 
];
*)

Block[{model,constants, v, c,crule},
c= Global`compartment$1;
crule = c\[Rule] 1; 
constants = Append[r, crule];
v=functionate/@vars;

model={};
AppendTo[model, Global`SBMLAlgebraicRules\[Rule] {}]; 
AppendTo[model, Global`SBMLAssignmentRules\[Rule] {}]; 
AppendTo[model, Global`SBMLCompartments\[Rule] {c}]; 
AppendTo[model, Global`SBMLConstants\[Rule] constants]; 
AppendTo[model, Global`SBMLConstraints\[Rule]{}];
AppendTo[model, Global`SBMLContext\[Rule]"None`"];
AppendTo[model, Global`SBMLEvents\[Rule]{}];
AppendTo[model,Global`SBMLFunctions\[Rule]{}]; 
AppendTo[model,Global`SBMLIC\[Rule] ic]; 
AppendTo[model, Global`SBMLInitialAssignments\[Rule]{}];
AppendTo[model, Global`SBMLKineticLaws\[Rule]{}]; 
AppendTo[model, Global`SBMLMetaIDAssociations\[Rule]{}];
AppendTo[model, Global`SBMLModelid\[Rule]"xlr8rModel"];
AppendTo[model,Global`SBMLModelName\[Rule]"xCellerator Model"]; 
AppendTo[model, Global`SBMLModelVariables\[Rule] v]; 
AppendTo[model, Global`SBMLNameIDAssociations\[Rule]{}];
AppendTo[model, Global`SBMLODES\[Rule] odes];
AppendTo[model, Global`SBMLParameters\[Rule] (First/@r)]; 
AppendTo[model, Global`SBMLSpecies\[Rule] v]; 
AppendTo[model, Global`SBMLSpeciesCompartmentAssociations\[Rule] (
Rule[#, c]&/@vars)]; 
AppendTo[model, Global`SBMLSpeciesTypeAssociations\[Rule] {}]; 
AppendTo[model, Global`SBMLSpeciesTypes\[Rule] {}]; 
AppendTo[model, Global`SBMLUnitAssociations\[Rule]{}];
AppendTo[model, Global`SBMLUnitDefinitions\[Rule]{}]; 

If[debugRun, Print["simulate: model: ", model]]; 
n=SBMLNDSolve[model, tend, opt];
];

Return[n];

If[plot/.{opt}/.Options[run],
(* if a plot is requested *) 

pvar = plotVariables/.{opt}/.Options[run];
If[!SameQ[pvar,None],
If[Length[pvar]>0,
runPlot[n, pvar,opt];,
runPlot[n]; 
]; 
 ]; 

(* if a gridPlot is requested *)

gpvar = gridPlotVariables/.{opt}/.Options[run];
If[!SameQ[gpvar,None], 
If[SameQ[gpvar,All],
gridPlot[n,All, {tstart, tend},opt];,
gridPlot[n,Flatten[gpvar],{tstart, tend},opt];
]

]; 

];

(* return a list of interpolating functions *)

Return[n];
];
*)


InterpolationSetListQ[x_]:=Module[{},
If[!ListQ[x],Return[False]];
Return[Length[Complement[Head/@x,{InterpolationSet}]]<1];];
getInterpolatingFunction[InterpolationSet[t1_,t2_,if_]]:=if;


startAndEndValues[InterpolationSet[start_,end_,f_]]:=Module[{vars,startValues,endvalues},vars=First/@f;
startValues=vars/.f/.{Global`t->start};
endValues=vars/.f/.{Global`t->end};
vars=decontextify[vars];
startValues=MapThread[{#1,start,#2}&,{vars,startValues}];
endValues=MapThread[{#1,end,#2}&,{vars,endValues}];
Return[{startValues,endValues}]];
startAndEndValues[f_?InterpolationSetListQ]:=Join@@(startAndEndValues/@f);


X$LogPlotZero=0;
X$MultiPlot=False;
XPlot[$Failed]:=Module[{},Print["Error: "//boldRed,"XPlot: unable to plot: "//boldBlack,$Failed//boldBlue]];
XPlot[{}]:=Module[{},Print["Error: "//boldRed,"XPlot: unable to plot: "//boldBlack,{}//boldBlue]]

XPlot[q_?InterpolationSetListQ,{}]:=Module[{},Print["Error: "//boldRed,"XPlot: Invalid input."//boldBlack];
Abort[];];

DEBUGPLOT=False; 

XPlot[q_?InterpolationSetListQ,z___?OptionQ]:=Module[{p,s,opts,legend,savs,vars,datasets,createLines,connectingLines,debug=True,dbg,zbad,logplot,zerovalue,hold,colors,df, dPrint},
X$MultiPlot=True;
dbg=DEBUGPLOT;
dPrint[u___]:= If[dbg, Print["XPlot: "//boldRed, u//boldBlue]]; 
dPrint["InterpolationSetListQ (0): plotting interpolation set"]; 
opts=Select[{z},OptionQ];
hold="holdLegend"/.opts/.{"holdLegend"->False};
colors="PlotColors"/.opts/.{"PlotColors"->{}};
dPrint["InterpolationSetListQ: colors:",colors," hold:",hold];
zbad=Complement[{z},{opts}];
logplot=stringer["type"/.{z}/.{"type"->""}]=="Log";
zbad=Complement[zbad,{type->"Log"}];
zbad=Select[zbad,stringer[First[#1]]!="zero"&];
zbad=Select[zbad,!First[#1]==="holdLegend"];
zbad=Select[zbad,!First[#1]==="PlotColors"];
zbad=Select[zbad,!First[#1]==="PlotStyles"];
dPrint["InterpolationSetListQ: q:",q];
If[Length[zbad]>0,(Print[boldRed[">>Warning: "],boldBlack[" The option "],boldRed[#1],boldBlack[" is not allowed (or has not yet been implemented) for models that contain events."]]&)/@zbad;];
legend={MapThread[{Graphics[{Sequence@@#1,Line[{{0,0},{1,0}}]}],ToString[#2]}&,{MultiPlot$Styles,MultiPlot$Legends}]};

If[logplot,
dPrint["InterpolationSetListQ: ","About to call XPlot[interpolatingFunction] - LogPlot"];
zerovalue={"zero"/.{z}/.{"zero"->0}};
X$LogPlotZero=Max[zerovalue,0];
p=XLogPlot[q,Sequence@@opts,PlotRange->All];,dPrint["XPlot: InterpolationSetListQ: ","About to call XPlot[interpolatingFunction]"];
p=(XPlot[#1,Sequence@@opts,"holdLegend"->hold,"PlotColors"->colors,PlotRange->All]&)/@q];
dPrint["XPlot: InterpolationSetListQ: "," plotting interpolation sets: p: ",Show[p,DisplayFunction->$DisplayFunction]];
X$MultiPlot=False;
(*legend={MapThread[{Graphics[{Sequence@@#1,Line[{{0,0},{1,0}}]}],ToString[#2]}&,{MultiPlot$Styles,MultiPlot$Legends}]};*)
If[$VersionNumber<6,legend=Join[legend,{LegendSize->{1,1},LegendPosition->{1,-0.5`},TextStyle->{FontFamily->Times}}],legend=Join[legend,{LegendSize->{1,1},LegendPosition->{1,-0.5`},BaseStyle->{FontFamily->Times}}];
];
If[Length[p]>1&&!logplot,sav=startAndEndValues[q];
vars=(#1[Global`t]&)/@ToExpression/@MultiPlot$Legends;
dPrint["InterpolationSetListQ: ","sav: ",sav," vars:",vars];

datasets=(Cases[sav,{#1,___},\[Infinity]]&)/@vars;
dPrint["InterpolationSetListQ: "," plotting interpolation set: datasets(1): ",datasets];

datasets=(Drop[Drop[#1,1],-1]&)/@datasets;
dPrint["XPLOT: InterpolationSetListQ:  plotting interpolation set: datasets(2): ",datasets];

datasets=Transpose/@(Drop[#1,1]&)/@Transpose/@datasets;
datasets=(Partition[#1,2]&)/@datasets;
createLines[dataset_,style_]:=Module[{},dPrint["createLines: style:",style];(Graphics[{Sequence@@style,Line[{#1[[1]],#1[[2]]}]}]&)/@dataset];
datasets=MapThread[createLines,{datasets,MultiPlot$Styles}];
dPrint["InterpolationSetListQ: datasets:",datasets];

connectingLines=Show[Flatten[datasets],DisplayFunction->Identity];
p=Show[p,connectingLines];
drint["InterpolationSetListQ: p with connectingLines:",Show[p,DisplayFunction->$DisplayFunction]];
,
Off[Graphics::"gptn"];
p=Show[p,DisplayFunction->Identity];
On[Graphics::"gptn"];
];
If[AllowMultiPlot$Legends,
s=ShowLegend[p,legend],df=DisplayFunction/.opts/.{DisplayFunction->$DisplayFunction};
If[dbg,Print["XPlot: InterpolationSetListQ: "//boldRed,"df:",df]
];
p=Show[p,DisplayFunction->df]; 
dPrint[p]; 
Return[p]
]
];
XPlot[q_?InterpolationSetListQ,{var__},z___?OptionQ]:=Module[{tstart,tend},If[DEBUGPLOT,Print["XPlot: InterpolationSetListQ: (1): {var}: ",{var}]];
tstart=q[[1,1]];
tend=q[[Length[q],2]];
Return[XPlot[q,{var},{tstart,tend},z]];];

XPlot[q_?InterpolationSetListQ,{var__},{tstart_,tend_},z___?OptionQ]:=Module[{convars,devars,r,n,selvars, dPrint},
dPrint[u___]:= If[DEBUGPLOT, Print["XPLOT: ", u]]; 
dPrint["XPlot: InterpolationSetListQ: (2): {var}: ",{var}];
selvars[InterpolationSet[t1_,t2_,set_],vin_]:=Module[{newset,v,notfound,varsInSolution},v=If[StringQ[#],ToExpression[#],#]&/@vin;
newset=Select[set,MemberQ[v,First[#1]]&];
varsInSolution=First/@set;
dPrint["selvars: varsInSolution:",varsInSolution];
dPrint["selvars:  v:",v];
dPrint["selvars:  defunctionate/@v:",defunctionate/@v];
notFound=Complement[decontextify/@defunctionate/@v,decontextify/@defunctionate/@varsInSolution];
Print["Warning:"//boldRed,"XPlot: The requested variable "//boldBlack,defunctionate[#]//boldBlue," was not found in the solution set for the time period "//boldBlack,{t1,t2}//boldBlack]&/@notFound;
dPrint["v:",v, " set: ",set," newset:",newset];
If[Length[newset]==0,Print["Error: "//boldRed,"XPlot: requested variables: "//boldBlack,(defunctionate/@v)//boldBlue," not found in solution set. There is nothing to plot. "//boldBlack];
Abort[];];
Return[InterpolationSet[t1,t2,newset]];];
devars=decontextify/@{var};
convars=contextify/@devars;
devars=functionate/@devars;
convars=functionate/@convars;
r=MapThread[#1->#2&,{convars,devars}];
n=(selvars[#1,convars]&)/@q;
dPrint["InterpolationSetListQ: (2): n: ",n];
Return[XPlot[n,PlotRange->{{tstart,tend},All},z]];];

XPlot[InterpolationSet[t1_,t2_,sol_],{var__?nonOptionQ},{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},If[DEBUGPLOT,Print["XPlot:InterpolationSet: (1)"//boldRed]];
XPlot[sol,{var},{Max[tbegin,t1],Min[tend,t2]},opt]];

XPlot[InterpolationSet[t1_,t2_,sol_],var_?nonOptionQ,{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},If[DEBUGPLOT,Print["XPlot:InterpolationSet: (2)"//boldRed]];
XPlot[sol,var,{Max[tbegin,t1],Min[tend,t2]},opt]];

XPlot[InterpolationSet[t1_,t2_,sol_],{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{},If[DEBUGPLOT,Print["XPlot:InterpolationSet: (3)"//boldRed]];
XPlot[sol,{Max[tbegin,t1],Min[tend,t2]},opt]];

XPlot[InterpolationSet[t1_,t2_,sol_],var_?nonOptionQ,opt___?OptionQ]:=Module[{},
If[DEBUGPLOT,Print["XPlot:InterpolationSet: (4), var="//boldRed,var//boldBlue]];
XPlot[sol,var,{t1,t2},opt]];

XPlot[InterpolationSet[t1_,t2_,sol_],opt___?OptionQ]:=Module[{},
If[DEBUGPLOT,Print["XPlot:InterpolationSet: (5)"//boldRed]];
If[DEBUGPLOT,Print["XPlot: InterpolationSet: (5): sol:"//boldRed,sol//boldBlue]];
XPlot[sol,{t1,t2},opt]];


XPlot[sol_,{var__?nonOptionQ},{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{legends,variables,n,colors,defaultColors,plotType,soln,p,legend,allowLegend,popt,styles,trace,dbg=False,tt,vars,plot,gopt, dPrint},
dPrint[u___]:= If[dbg, Print["XPlot (IF): "//boldRed, u]]; 

trace=DEBUGPLOT;
dbg=DEBUGPLOT;
If[dbg\[Or]trace,Print["==== XPlot Trace ON ====\nXPlot: {var}="//boldRed,{var}//boldBlue,"\nXPlot: {tbegin, tend}="//boldRed,{tbegin,tend}//boldBlue,"\nXPlot: {opt}="//boldRed,{opt}//boldBlue]];
soln=selectSolution[sol];
dPrint["decontextify/@{var}: ",decontextify/@stringer/@{var}];
dPrint["contextify/@decontextify/@{var}: ",contextify/@decontextify/@stringer/@{var}];
variables=contextify/@decontextify/@stringer/@{var};
variables=Map[If[StringQ[#],ToExpression[#],#]&,variables];
vars=variables;
variables=Map[#[Global`t]&,variables];
legends=decontextify[Map[ToString,{var}]];
n=Length[legends];
(*get styles and make sure it is a list of lists*)styles="PlotStyles"/.{opt}/.{"PlotStyles"->{}};
If[Length[styles]<1,styles="PlotStyle"/.{opt}/.{"PlotStyle"->{}}];
dPrint["styles (1):",styles];
(*If there is just one style,apply it to each variable*)If[\[Not]ListQ[styles],styles=Table[{styles},{n}]];
dPrint["styles (2):",styles];
(*If there is more than one style,but only a one level list,apply them to all variables*)If[Length[styles]>0,If[\[Not]ListQ[First[styles]],styles={styles}];];
If[dbg,Print["styles (3):",styles]];
While[Length[styles]<n,styles=Append[styles,{}]];
If[Length[styles]>n,Print["Warning: "//boldRed," XPlot: "//boldBlack,Length[styles]//boldBlue," PlotStyles supplied only "//boldBlack,n//boldBlue," expected. Extra styles ignored. "//boldBlack];
styles=Take[styles,n];];
dPrint["styles (4):",styles];
(*add in colors if not supplied in PlotStyles*)colors=Flatten["PlotColors"/.{opt}/.{"PlotColors"->{}}];
(*If[SameQ[colors,None],colors=Map[Hue,Range[n]/(1.0*n)]];*)If[Length[colors]>0,If[Length[colors]>n,Print["Warning: "//boldRed,"XPlot: "//boldBlack,"PlotColors\[Rule]"<>ToString[colors]//boldBlue," contains "//boldBlack,Length[colors]//boldBlue," colors; only "//boldBlack,n//boldBlue,boldBlack["\nare expected. The input will be interpreted as"],boldBlue["PlotColors\[Rule]"<>ToString[Take[colors,n]]]];
colors=Take[colors,n];
];
];
dPrint["n=",n," Length[colors]:",Length[colors]];
If[Length[colors]<n,defaultColors=Map[Hue,Range[n]/(1.0*n)];
defaultColors=Drop[defaultColors,Length[colors]];
colors=Join[colors,defaultColors];];
dPrint["colors:",colors];
dPrint["original styles:",styles];
(*Seems that Mathematica choose the LAST style to use,not the FIRST,like Options*)styles=MapThread[Prepend[#1,#2]&,{styles,colors}];
dPrint["revised styles:",styles];
plotType=stringer[("type"/.{opt}/.{"type"-> ""})];
If[plotType=="Log",
dPrint["log plot. soln: ", soln]; 
p=XLogPlot[soln,{var},{tbegin,tend},opt];
dPrint["returned from xLotPlot."]; 
dPrint[p]; 

Return[p];
];
allowLegend=\[Not]("holdLegend"/.{opt}/.{"holdLegend"->False});
AllowMultiPlot$Legends=allowLegend;
If[trace,Print["XPlot: "//boldRed,"variables: "//boldRed,variables//boldBlue];
Print["XPlot: "//boldRed,"styles: "//boldRed,styles//boldBlue];
Print["XPlot: "//boldRed,"legends: "//boldRed,legends//boldBlue];];

Block[{solution, s},
solution[InterpolationSet[u_]]:= u;
solution[u_?ListQ]:= u;
solution[u___]:= (Print["Error: XPlot: "//boldRed, "unexpected format for solution: ", u];Abort[];);
s=solution[soln]; 

With[{popt=MyFilterOptions[Plot,opt]},If[trace,Print["XPlot: "//boldRed,"{popt}:"//boldRed,{popt}//boldBlue]];
If[X$MultiPlot,If[trace,Print["XPlot: X$MultiPlot"//boldRed]];
If[$VersionNumber<6,p=Plot[Evaluate[variables/.soln],{Global`t,tbegin,tend},PlotStyle->styles,Sequence[popt],DisplayFunction->Identity],plot[x_,directives_]:=Plot[x/.soln,{Global`t,tbegin,tend},PlotStyle->directives,popt];
p=MapThread[plot,{variables,Directive/@styles}]];
MultiPlot$Colors=colors;
MultiPlot$Legends=legends;
MultiPlot$Styles=styles;,If[trace,Print["XPlot: "//boldRed,"It is Not X$MultiPlot: allowLegend: "//boldRed,allowLegend//boldBlue]];
If[$VersionNumber<6,If[allowLegend,p=Plot[Evaluate[variables/.soln],{Global`t,tbegin,tend},Sequence[popt],Graphics`Legend`PlotLegend->legends,PlotStyle->styles,Graphics`Legend`LegendPosition->{1,-0.5},Graphics`Legend`LegendSize->{.5,1}],p=Plot[Evaluate[variables/.s],{Global`t,tbegin,tend},Sequence[popt],PlotStyle->styles]],


(* version number > 6 starts here *)

If[trace,
Print["XPlot (version number > 6): variables:"//boldRed,variables//boldBlue]];


plot[x_,directives_]:=
Plot[x/.s,{Global`t,tbegin,tend},PlotStyle->directives,popt,PlotRange->All];


dPrint["s: ", s]; 

If[allowLegend,p={Show[MyLegend[legends,colors],AspectRatio->1/GoldenRatio],MapThread[plot,{variables,Directive/@styles}]};
If[trace,Print["XPlot: p "//boldRed,p//boldBlue]];
With[{gopt=MyFilterOptions[Graphics,opt]},p=Show[p,gopt,Axes->True]],p=Show[MapThread[plot,{variables,Directive/@styles}]]
]
];
]
];
];(* end of the BLOCK *)

If[trace,Print["XPlot: Plot: "//boldRed,p,"\n=== XPlot Trace: EXIT ==="//boldRed]];

dPrint[p]; 

Return[p]

];

MyLegend[names_?ListQ,colors_?ListQ]:=Module[{p,n,nc,x,y,xy},n=Length[names];
nc=Length[colors];
If[n!=nc,Print["Error:"//boldRed,"MyLegend:"//boldBlue," number of names = "//boldBlack,n//boldBlack," is different from the number of colors = "//boldBlack,nc//boldBlack];
Return[$Failed]];
x=1.1;

xy=Table[Scaled[{x,1-1.0*y/(n+1)}],{y,1,n}];

p=MapThread[Text,{stringer/@names,xy}];
p=Transpose[{colors,p}];
p=Graphics/@p
];



XPlot[sol_,variable_?AtomQ,{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{vars,lvars,r,n,pvar,p,dbg},
dbg=DEBUGPLOT;
If[dbg,Print["XPlot 2: variable: "//boldRed,variable//boldBlue," {begin, end}:"//boldRed,{tbegin,tend}//boldBlue," {options}:"//boldRed,{opt}//boldBlue];];
(*rev 2.6.2 to check for "ALL" here*)If[ToUpperCase[ToString[variable]]=="ALL",Return[XPlot[sol,{tbegin,tend},"variables"-> "All", opt]]];
XPlot[sol,{variable},{tbegin,tend},opt]];



XPlot[sol_,{tbegin_?NumberQ,tend_?NumberQ},opt___?OptionQ]:=Module[{soln,vars,dbg ,dPrint},
dbg=DEBUGPLOT;
dPrint[u___]:= If[dbg, Print["XPlot 3:"//boldRed, u]]; 
dPrint["{tbegin,tend}:", {tbegin, tend}, " {opt}: ", {opt}]; 

soln=selectSolution[sol];
(*added the following check 2.7.3 in responsed to bug 1892076*)vars="variables"/.{opt}/.{"variables"->"All"};
If[
ToUpperCase[vars]== "ALL", 
vars=First/@soln];
dPrint["vars: ", vars//boldBlue];

Return[XPlot[soln,vars,{tbegin,tend},opt]]];


XPlot[sol_,variable_?nonOptionQ,opt___?OptionQ]:=Module[{p,tbegin,tend,soln,dbg},
dbg=DEBUGPLOT;
If[dbg,Print["XPlot 4: variable: "//boldRed,variable//boldBlue," {options}:"//boldRed,{opt}//boldRed]];(*allow plotting of either solutions or solutions incorporated within a model*)
soln=selectSolution[sol];
{tbegin,tend}=getPlotTimes[soln];
p=XPlot[soln,variable,{tbegin,tend},opt];
Return[p];];

XPlot[sol_,opt___?OptionQ]:=Module[{vars,svars,tbegin,tend,soln,dbg, dPrint},
dbg=DEBUGPLOT;
dPrint[u___]:=If[dbg, Print["XPlot 5: "//boldRed, u]]; 
dPrint["opt: ", {opt}]; 

soln=selectSolution[sol];
{tbegin,tend}=getPlotTimes[soln];
vars=Flatten[{"variables"/.{opt}/."variables"->{"All"}}];
dPrint["variables: ", vars];

svars=ToUpperCase/@ToString/@vars;
dPrint["svars: ", svars]; 
If[MemberQ[svars,"ALL"],
dPrint["Option ALL"]; 
Return[XPlot[soln,{tbegin,tend},opt]]
];
dPrint["default Option"]; 

Return[XPlot[soln,vars,{tbegin,tend},opt]];];

(* revised v.093 from MathSBML fork to use InterpolatingFunctionAnatomy instead of searching for Text String*)

getPlotTimes[soln_]:=Module[{solTimes,n1,tbegin,tend,pos,part, dbg=DEBUGPLOT, dPrint, domain, domains},
dPrint[u___]:= If[dbg, Print["getPlotTimes: "//boldRed, u]]; 

domain[if_]:= InterpolatingFunctionDomain[if]; 
domains = domain/@(Last/@soln); 
domains = Union [Flatten/@domains]; 
dPrint["domains: ", domains]; 
{tbegin, tend}=Transpose[domains]; 
tbegin=Max[tbegin];
tend=Min[tend]; 
dPrint["tbegin: ", tbegin, " tend: ", tend]; 

Return[{tbegin,tend}];];

(* this converts a mathsbml solution into a mathematica style solution *)

(* if the input is a solution and not a mathsbml solution, it just passes the input through to the output *)


selectSolution[sol_]:=Module[{},
If[MemberQ[ToString/@First/@sol,"SBMLNumericalSolution"],Return[Global`SBMLNumericalSolution/.sol];,
Return[sol//Flatten];];
Print[boldOrange["Error:"],boldRed["selectSolution: law of excluded middles violation. Catastrophic failure of nature."];];
Abort[];
];



XLogPlot[q_?InterpolationSetListQ,opt___?OptionQ]:=Module[{dbg=False,vars,data,getvars,times,tbegin,tend,legends,colors,n,p,selectRealPositives, dPrint},

dPrint[u___]:= If[dbg, Print["XLogPlot:"//boldRed, u]]; 

getvars[InterpolationSet[t1_,t2_,sol_]]:=Module[{vars},vars=First/@sol;
vars=StringReplace[stringer/@vars,"[t]"->""]//ToExpression;
dPrint["Interpolation Set: getVars: "//boldBlue,"{t1,t2}="//boldBlack,{t1,t2}//boldRed,"vars="//boldBlack,vars//boldRed];
Return[{{t1,t2},vars}];
];
vars=getvars/@q;

times=First/@vars;
vars=Last/@vars;
tbegin=Min[times];tend=Max[times];
vars=Intersection[vars]//Flatten;(*might loose variables if the sets are different*)legends=decontextify[stringer/@vars];
n=Length[legends];
colors=Map[Hue,Range[n]/(1.0*n)];
MultiPlot$Colors=colors;
MultiPlot$Styles=colors;
MultiPlot$Legends=legends;

dPrint["Interpolation Set:"//boldBlue,"vars="//boldBlack,vars//boldRed];
dPrint["Interpolation Set:"//boldBlue,"times="//boldBlack,times//boldRed," tbegin="//boldBlack,tbegin//boldRed," tend="//boldBlack,tend//boldRed];

data=dataTable[#,{Global`t,tbegin,tend,(tend-tbegin)/50.},q]&/@vars;
data=Rest/@data;
selectRealPositives[z_]:=Select[z,(Im[Last[#]]==0&&Re[Last[#]]>X$LogPlotZero)&];
data=selectRealPositives/@data;
Off[Graphics::gptn];
p=MapThread[LogListPlot[#1,opt,PlotJoined->True,PlotStyle->#2,DisplayFunction->Identity]&,{data,colors}];
On[Graphics::gptn];
Return[Show[p,opt,PlotRange->All]];];


XLogPlot[sol_,var_?ListQ,{tbegin_,tend_},opt___?OptionQ]:=Module[{n,p,colors,legend,autoscale,man,mans,exps,dbg=False, soln, dPrint, plottable},(*add autoscaling 6-2-04*)
dbg=DEBUGPLOT; 
dPrint[u___]:= If[dbg, Print["XLogPlot: "//boldRed, u]]; 
(*figure out the max& minimum value plotted*)
soln = sol;
If[ToString[Head[sol]]=="InterpolationSet", soln=argument[soln]]; 


dPrint["var: ", var, " {tbegin, tend}: ", {tbegin, tend}, " opt: ", {opt}]; 
plottable=var;
dPrint["plottable: ", plottable]; 

autoscale=findMiniMax[soln,#,{tbegin,tend},"filterNonPositives"->True,opt]&/@var;
autoscale=Select[Flatten[autoscale],Positive];
autoscale={Min[autoscale],Max[autoscale]};
dPrint["autoscale: ", autoscale]; 

n=Length[plottable];
colors=Map[Hue,Range[n]/(1.0*n)];
(*now round off the mantissa*)man=MantissaExponent/@autoscale;
{mans,exps}=Transpose[man];
mans=10*mans;
mans={Floor[mans[[1]]],Ceiling[mans[[2]]]};
mans=mans/10.;
man=Transpose[{mans,exps}];
autoscale=#[[1]]*(10^#[[2]])&/@man;
If[autoscale[[2]]<0,Print["Warning:"//boldOrange," unable to autoscale logarithmic plot due to all data values being negative. Range of data values is "//boldBlack,autoscale//boldRed];
autoscale={autoscale[[1]],1};];
If[autoscale[[1]]<0,Print["Warning:"//boldOrange," unable to fully autoscale logarithmic plot due to negative data value. Range of data values is: "//boldBlack,autoscale//boldRed];
autoscale={autoscale[[2]]*0.1,autoscale[[2]]};];
dPrint["autoscale = ",autoscale];
dPrint["opt = ",{opt}];
p=MapThread[XLogPlot[soln,#1[Global`t],{tbegin,tend},PlotStyle->#2,DisplayFunction->Identity,opt,PlotRange->{{tbegin, tend+.2*(tend-tbegin)}, autoscale}]&,{plottable,colors}];
dPrint["p generated."];

p=Show[p];
legend={MapThread[{Graphics[{#1,Line[{{0,0},{1,0}}]}],decontextify[ToString[#2]]}&,{colors,plottable}]};
legend=Append[legend,LegendPosition->{1,-.5}];
(* p=ShowLegend[p,legend]; *)

p=Show[{p, 
LogLegend[plottable,colors, {tbegin, tend}, autoscale]}];


Return[p];];

XLogPlot[soln_,var_,{tbegin_,tend_},opt___?OptionQ]:=Module[
{dbg=False},
dbg=DEBUGPLOT;
If[dbg,Print["xLogPLOT: (single-var): opt ",{opt}]];
With[{ops=MyFilterOptions[LogPlot, opt]}, 
LogPlot[Evaluate[var/.soln],{Global`t,tbegin,tend},ops]]
];



LogLegend[names_?ListQ,colors_?ListQ, xscale_, yscale_]:=Module[{p,n,nc,x,y,xy, xmax, xmin,ymax,ymin},
n=Length[names];
nc=Length[colors];
If[n!=nc,Print["Error:"//boldRed,"MyLegend:"//boldBlue," number of names = "//boldBlack,n//boldBlack," is different from the number of colors = "//boldBlack,nc//boldBlack];
Return[$Failed]];
x=1.1;
{xmin,xmax}=xscale;
{ymin,ymax}=yscale; 

x=xmax + (xmax-xmin)*.1; 

xy=Table[Scaled[{x,1-1.0*y/(n+1)}],{y,1,n}];

xy= Table[{x, Log[10,ymin]+ y* Log[10,ymax/ymin]/(n+1.0)}, {y, 1, n}]; 

p=MapThread[Text,{stringer/@names,xy}];
p=Transpose[{colors,p}];
p=Show[Graphics/@p, AspectRatio-> 1.0/GoldenRatio]
];


findMiniMax[n_,var_,{tbegin_,tend_},opt___?OptionQ]:=Module[{npts,ops,dt,max,min,i,x,times,if,positiveOnly,msave, dbg, dPrint},ops=Flatten[{opt}];
positiveOnly="filterNonPositives"/.ops/.{"filterNonPositives"->False};
dbg=DEBUGPLOT; 
dPrint[u___]:= If[dbg, Print["findMiniMax: "//boldRed, u]]; 
dPrint["ops: ", ops]; 

npts=(PlotPoints/.ops/.{PlotPoints->50});
dt=Abs[(tbegin-tend)/(1.0*npts)];
times=Range[Min[tbegin,tend],Max[tbegin,tend],dt];
if=var[Global`t]/.n;
dPrint["if: ", if]; 

max=Evaluate[if/.{Global`t->#}]&/@times;
max=Flatten[max];
dPrint["var: ", var, " max: ", Short[max]]; 

If[positiveOnly,msave=max;
max=Select[max,Positive];
If[Length[max]<1,Print["Warning:"//boldOrange," unable to plot the variable "//boldBlack,var//boldRed," on a logarithmic scale because it never takes on a positive value."//boldBlack];max=msave;
plottable=Complement[plottable,{var}];];
(* 
If[Length[max]\[NotEqual]Length[msave],Print["Warning:"//boldOrange," Some values of the variable "//boldBlack,var//boldRed," can not be plotted on a logarithmic scale because they do not evaluate to a positive number."//boldBlack]]; *)
];
min=Min[max];
max=Max[max];
dPrint["{min,max}: ", {min,max}]; 
Return[{min,max}];]


steadyState[r_,t_:Global`t]:= Module[{eqs,vars},
If[interpreted[r], eqs=r,eqs=interpret[r]];
{eqs,vars}=eqs;
vars =#[t]&/@vars;

(* in 5.0++, equation will not necessarily be of the form x'=stuff but may be an equation will be an expression involving x': need to solve for x'[t] *)

eqs=Last/@Flatten[MapThread[Solve[#1,D[#2,{t,1}]]&, {eqs,vars}]];
eqs=Equal[#,0]&/@eqs;
Solve[eqs,vars]
];

steadyState[r_,t_, varlist_]:= Module[{teqs,vars,p},
If[interpreted[r], eqs=r,eqs=interpret[r]];
teqs=Transpose[eqs];
{eqs,vars}=eqs;

p=Flatten[Position[vars,#]&/@varlist];

{eqs,vars}=Transpose[teqs[[p]]];

eqs=Last/@Flatten[MapThread[Solve[#1,D[#2,{t,1}]]&, {eqs,vars}]];
eqs=Equal[#,0]&/@eqs;
Solve[eqs,vars]
]


PhasePlot[sim_, {x_,y_}, {tstart_, tend_},opt___?OptionQ]:= Module[{r, p},
r=Flatten[sim]; 
p = ParametricPlot[Evaluate[{x[t],y[t]}/.r],{t,tstart,tend},
AxesLabel-> {x,y},
opt];
Return[p];
];




PredictTransferFunction[stn_, {time_, tbegin_, tend_}, {inputVariable_, inmin_, inmax_, indelta_},
outputVariable_,opt___?OptionQ]:= 
Module[
{getvar, dbg=False, dpr, getopt, ic, value, currentICs, currentrates,num, output, nextoutput, outvars, integrate,results, f, ratemode, ICmode, col1label, eqs, vars, syms, r},

dbg = "Debug"/.{opt}/.{"Debug"-> False}; 

dpr[x___]:= If[dbg, Print["PredictTransferFunction: ", x]]; 
getopt[x_, defaultvalue_]:= x/.{opt}/.{x-> defaultvalue};
outvars=(#[time]&/@(Flatten[{outputVariable}])); 

(*  do an interpret to make sure system is well formed *)

{eqs, vars}=interpret[stn]; 
syms=Complement[Select[getSymbols[eqs], Not[Context[#]=="System`"]&], vars]; 
syms = Complement[syms, {time}]; 

(* determine if the requested inputVariable is a variable or a parameter *)

If[MemberQ[syms, inputVariable],
ratemode=True; ICmode=False;,
If[MemberQ[vars, inputVariable], 
ratemode=False; ICmode=True;, 
Print["Error: PredictTransferFunction: symbol ", inputVariable, " not found!"]; 
Return[$Failed]; 
]; 
]; 

dpr["ratemode=", ratemode, " ICmode=", ICmode]; 

(* format the rate constants *)
(* global variable rates is for backward compatibility *)

r=getopt["Parameters",{}]; 
If[Length[r]<1, r = getopt[rates, {}]]; 

If[ratemode,
r=(r/.{Rule-> List}); 
r = Select[r, Not[SameQ[inputVariable, First[#]]]&]; 
r= (#/.{List-> Rule})&/@r; 
col1label=inputVariable;
dpr["r=", r]; 
]; 

(* format the initial conditions *)
(* global variable initialConditions is for backwards compatibility *)

ic = getopt["IC",{}]; 
If[Length[ic]<1, ic = getopt[initialConditions,{}]]; 
 
If[ICmode,
ic = ic/.{Rule-> List}; 
ic = Select[ic, Not[SameQ[inputVariable, First[#]]]&]; 
ic = (#/.{List-> Rule})&/@ic; 
col1label=inputVariable[tbegin];
dpr["ic=", ic]; 

]; 

integrate=getopt["Integrate", False]; 
f[x_]:= getopt["Function", (#&)][x]; 

dpr["r: ", r]; 
dpr["ic: ", ic]; 

output={Flatten[{col1label, #[tend]&/@Flatten[{outputVariable}]}]}; 

For[value = inmin, value<= inmax, value=value+indelta,

dpr["------ value: ", value]; 

If[ICmode,
currentICs=Append[ic, inputVariable-> value],
currentICs=ic
]; 

If[ratemode,
currentrates=Append[r, inputVariable-> value], 
currentrates=r
]; 

dpr["currentICs: ", currentICs]; 
dpr["currentrates: ", currentrates]; 


num=run[stn, 
timeSpan-> {tbegin, tend}, 
"Parameters"-> currentrates, 
"IC"-> currentICs,
opt
]; 
dpr["num:", num]; 

If[integrate,
results=Map[NIntegrate[f[#/.num],{time,tbegin,tend}]&, outvars], 
results =f/@( (outvars/.Flatten[num])/.{time-> tend})
]; 

nextoutput=Flatten[{value, results}];
AppendTo[output, nextoutput];

dpr["end of step: r=", r, " currentrates=", currentrates]; 

];

Return[output]; 

]


xlr8rhelp[]:= Module[{names, usagestrings, print, ok}, 
names=decontextify/@Names["xlr8r`*"];
usagestrings = ToExpression/@((ToString[#]<>"::usage")&/@names); 

ok = StringQ/@usagestrings; 
usagestrings = Pick[usagestrings, ok]; 
names = Pick[names, ok]; 

ok = (StringLength[#]>0)&/@usagestrings;
usagestrings = Pick[usagestrings, ok]; 
names = Pick[names, ok]; 

print[a_, b_]:= Module[{}, 
StylePrint[a, "Subsection"]; 
Print[b]; 
]; 
StylePrint["xlr8r Help", "Section"]; 
Print["This is the xlr8r Help file. It provides some reference information about each of the externally visible xlr8r functions. It is not a users guide and does not provide any introduction to using xlr8r. It also does not include plugin reference information. \nPlease note that xlr8r is experimental software and as such many of the functions may only contain partial implementations. And like a lot of software documentation in the cybersphere it does not always keep up with the latest implementation. Please check with the developer if you have any questions."];
Print["This file was generated by xlr8r version "<>$xlr8r$Version<>" on "<>DateString[{"Day", " ", "MonthNameShort", " ", "Year", " at ", "Hour", ":", "Minute", ":", "Second", " (", "TimeZone",")"}]<>" using Mathematica "<>$Version<>" (Version "<>ToString[ $VersionNumber]<>", Release "<>ToString[ $ReleaseNumber]<> ")"];  
MapThread[print, {names, usagestrings}]; 
];
(* MathSBML`AddHelp["xlr8r`"];
xlr8rHelp[]:= xlr8rhelp[]; *)


VR=" (Version "<>ToString[$VersionNumber]<>", Release "<>ToString[$ReleaseNumber]<>")"; If[xlr8r`Private`msgflag, 
Print[
Style["xCellerator ", FontWeight-> "Bold", FontFamily-> "Ubuntu,Arial", FontSize-> 12], Style[$xlr8r$Version<>" ("<>$xverdate$<>") loaded "<>DateString[]<>"\nusing Mathematica "<>$Version<>VR,   
FontFamily-> "Ubuntu,Arial",FontSize-> 12], 
Style[Hyperlink["GPL License Terms Apply", "http://www.gnu.org/licenses/gpl.html"], FontWeight-> Bold, FontFamily-> "Ubuntu,Arial",FontSize-> 12]
]
]; 
Remove[xlr8r`Private`msgflag]; 
End[];
EndPackage[];
